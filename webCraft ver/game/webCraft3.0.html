<!DOCTYPE html>
<head>
  <title>webCraft version3.0</title>
  <link rel="icon" type="image/png" href="https://terraria.org/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=0.5, maximum-scale=3">
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
</head>
<style>

    @font-face {
      font-family: 'DungGeunMo';
      src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_six@1.2/DungGeunMo.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }

    
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

        body {
      width: 9000px;
      height: 6000px;
      cursor: url('cur/cur531.cur'), auto !important;
      overflow: auto;
      background-color: black;
    }





    html, body {
      font-family: 'DungGeunMo', sans-serif !important;
      font-size: 100%;

      color: white;
      scroll-behavior: smooth;
    }


    body::-webkit-scrollbar {
      display: none;
    }




/*이미지 변경 프리로드*/
.background-container {
    position: fixed;
    width: 100vw;
    height: 100vh;
    top: 0;
    left: 0;
    z-index: -1;
    transition: opacity 0.5s ease-in-out;
}

.sky-block {
    position: absolute;
    width: 100%;
    height: 100%;
    background-size: cover;
    image-rendering: pixelated;
    will-change: transform;
}




/*메인 인터베이스 박스 가로 세로값은 body 설정한값과 동일*/
.mainBox{
     position: absolute;
    width:9000px;
    height:6000px;
    border:0px black solid;
    padding :0px;
    margin :0px;
    text-align: center;
    overflow: hidden;
       will-change: background-image; /* 배경 이미지 전환 시 필요 */
       transition: background-image 1s ease-in-out;
       z-index:2;

}

.mainBox::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: var(--sky-image, none); /* CSS 변수 사용 */
    background-size: 30px 33px;
    background-repeat: repeat;
    opacity: 0.2;
    z-index: -1;
    pointer-events: none;
}

.mainBox2{
     position: absolute;
    width:9000px;
    height:1590px;
    border:0px red solid;
    padding :0px;
    margin :0px;
    text-align: center;
    overflow: hidden;
    will-change: background-image; /* 배경 이미지 전환 시 필요 */
    will-change: opacity;
    transition: opacity 2s cubic-bezier(0.33, 0.11, 0.5, 1.3);
    transition: opacity 0.5s ease; /* 부드러운 전환 */

       z-index:-2;
       opacity: 0.5;
}

.mainBox2::before {
    content: '';
    position: absolute;
    top: -10%;
    left: -10%;
    width: 120%;
    height: 120%;
    background-image: inherit;
    background-size: cover;
    background-position: center;
    animation: 
        biomePan 20s linear infinite,
        biomeZoom 20s ease-in-out infinite alternate;
    will-change: transform;
    z-index: -1;
}

.mainBox, .mainBox2 {
    transition: 
        filter 2.5s cubic-bezier(0.4, 0, 0.2, 1),
        opacity 2.5s ease-in-out;
}
/*지하*/
.mainBox3{
     position: absolute;
    width:9000px;
    top:1590px;
    height:3090px;
    border:0px blue solid;
    padding :0px;
    margin :0px;
    text-align: center;
    overflow: hidden;
    will-change: background-image; /* 배경 이미지 전환 시 필요 */
    will-change: opacity;
    filter: brightness(0.5);
       z-index:-2;
       opacity: 1;
}

.mainBox3::before {
    content: '';
    position: absolute;
    top: -10%;
    left: -10%;
    width: 120%;
    height: 120%;
    background-image: inherit;
    background-position: center;
    will-change: transform;
    z-index: -1;
}


.mainBox4{/*지하도시*/
     position: absolute;
    width:9000px;
    top:4680px;
    height:1320px;
    border:0px yellow solid;
    padding :0px;
    margin :0px;
    text-align: center;
    overflow: hidden;
    will-change: background-image; /* 배경 이미지 전환 시 필요 */
    will-change: opacity;
    filter: brightness(0.5);
       z-index:0;
       opacity: 1;
}

.mainBox4::before {
    content: '';
    position: absolute;
    top: -10%;
    left: -10%;
    width: 120%;
    height: 120%;
    background-image: inherit;
    background-position: center;
    will-change: transform;
    z-index: 0;
}


@keyframes biomePan {
    0% { transform: translate(0, 0); }
    50% { transform: translate(-5%, 5%); }
    100% { transform: translate(0, 0); }
}

@keyframes biomeZoom {
    0% { transform: scale(1); }
    100% { transform: scale(1.1); }
}
/*표지판배경*/


.signBoxMain{
     position: fixed;
    width:20%;
    height:15%;
    top:45%;
    left:43%;
    border:0px blue solid;
    margin :0px;
    text-align: center;
    overflow: hidden;
       z-index:10;
       opacity: 1;
       background-color:rgba(255,255,255,0);
       background-size: 100% 100%;
       flex-direction: column;
       display: none;
       font-size:25px;
           color:black;
}

.signBox{
     position: absolute;
    width:90%;
    height:90%;
    font-size:25px;
    border:0px black solid;
    margin :0px;
    text-align: center;
    overflow: hidden;
    color:black;
       z-index:11;
       opacity: 1;
       background-image: url("img/sign.png");
       background-color: black;
       background-size: 100% 100%;
       flex-direction: column;
}

.signBoxClose{
     position:absolute;
    width:30px;
    height:30px;
    font-size:12px;
    margin-left:91%;
    margin-top:1%;
    border:2px red solid;
    color:red;
    z-index:11;
    opacity: 1;
}

.signBoxClose:hover{
       

        transform: scale(1.15);
        font-size: 15px;
        
    }
.signBoxClose:active{
        transform: scale(0.85);
        
    }


.mainBoxTop{
    position:fixed;
    width:100px;
    height:50px;
    z-index:991;
    border:0.5px black solid;
    margin-left:70px;
    padding:0px;
    font-size: 20px;
    text-align: center;
    color:black;
    overflow: hidden;
    word-break:break-all;
    background-color: rgba(255,255,255,0);
}
.dayTimeBox{
position : fixed;
width :100px;
height:50px;
z-index:991;
border : 1px white solid;
margin-left:180px;
padding:0px;
font-size:20px;
text-align:center;
color:black;
background-color: rgba(255,255,255,0);
overflow: hidden;
word-break: break-all;
}
.hpBox{
position : fixed;
width :100px;
height:15px;
z-index:991;
border : 1px white solid;
margin-left:293px;
padding:0px;
font-size:10px;
text-align:center;
color:white;
background-color: red;
overflow: hidden;
word-break: break-all;
}
.armorBox{
position : fixed;
width :1px;
height:15px;
z-index:991;
border : 0.5px white solid;
margin-left:293px;
margin-top:20px;
padding:0px;
font-size:10px;
text-align:center;
color:white;
background-color: gray;
overflow: hidden;
word-break: break-all;
}
.selectedBlockDisplay{
position : fixed;
width :50px;
height:50px;
z-index:991;
border : 0.5px black solid;
margin-left:400px;
margin-top:0px;
padding:0px;
font-size:16px;
text-align:center;
color:black;
background-color:rgba(255,255,255,0);
overflow: hidden;
word-break: break-all;
background-size:cover;
}

.craftDisplay{
position : fixed;
width :30%;
height:20%;
z-index:991;
border : 1px white solid;
margin-left:35%;
bottom: 200px;
padding:0px;
font-size:13px;
text-align:center;
background-color: rgba(255,255,255,0);
color:white;
overflow: hidden;
word-break: break-all;
display: none;
}

.craftDisplayClose {
    position: absolute;
    z-index:992;
    top: 5px;
    right: 5px;
    width: 25px;
    height: 25px;
    font-size: 15px;
    color : red;
    background-color: rgba(255,255,255,0);
    border: 1px solid #ff4444;
    z-index: 10000;
}

/**/
.bossBar {
    position: fixed;
    width: 1000px; /* 최대 너비 고정 */
    height: 18px; /* 1.8% → 픽셀 값으로 변경 */
    z-index: 991;
    border: 1px white solid;
    margin-left: 35%;
    bottom: 30px;
    padding: 0;
    font-size: 13px;
    text-align: center;
    background-color: green;
    color: white;
    overflow: hidden;
    word-break: break-all;
    display: none;
    transition: width 0.3s ease; /* 부드러운 애니메이션 추가 */
}



.saveDisplay{
position : fixed;
width :50px;
height:50px;
z-index:991;
border : 1px white solid;
margin-left:500px;
margin-top:0px;
padding:0px;
font-size:18px;
text-align:center;
color:white;
overflow: hidden;
word-break: break-all;
background-size:cover;
}

.saveDisplay2, .saveDisplay3, .saveDisplay4 {
  position: fixed;
  width: 50px;
  height: 50px;
  overflow: hidden;
  box-sizing: border-box;
  z-index: 9999;
  border: 1px solid white;


  display: flex;
  justify-content: center;
  align-items: center;
}

.saveDisplay2 { margin-left: 550px; border-left:0px; border-right:0px; top:0px; }
.saveDisplay3 { margin-left: 600px; border-left:0px; border-right:0px; top:0px; }
.saveDisplay4 { margin-left: 650px; border-left:0px; top:0px; }

.equipment-icon {
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  image-rendering: pixelated;
  pointer-events: none;
  display: block;
}



.goHome{
position : fixed;
width :50px;
height:50px;
z-index:991;
border : 1px black solid;
margin-left:5px;
margin-top:0px;
padding:1px;
font-size:18px;
text-align:center;
color:black;
background-color:rgba(255,255,255,0);
overflow: hidden;
word-break: break-all;
background-size:cover;
}
   
    .goHome:hover{
        opacity:1;
        transform: scale(1.1);
        border:1px solid black;
        color : yellow;
        font-size: 14px;
        
    }
  
    .goHome:active{
        transform: scale(0.9);
        color : yellow;
        
    }

.fullScreen{
position : fixed;
width :50px;
height:50px;
z-index:991;
border : 1px black solid;
margin-left:5px;
margin-top:60px;
padding:1px;
font-size:18px;
text-align:center;
color:black;
background-color:rgba(255,255,255,0);
overflow: hidden;
word-break: break-all;
background-size:cover;

    }

    .fullScreen:hover{
        opacity:1;
        transform: scale(1.1);
        border:1px solid black;
        color : yellow;
        font-size: 14px;
        
    }
  
    .fullScreen:active{
        transform: scale(0.9);
        color : yellow;
        
    }
  


/**/

.musicSoundControl{
position : fixed;
width :50px;
height:50px;
z-index:991;
border : 1px black solid;
margin-left:5px;
margin-top:120px;
padding:1px;
font-size:18px;
text-align:center;
color:black;
background-color:rgba(255,255,255,0);
overflow: hidden;
word-break: break-all;
background-size:cover;
    }
   
    .musicSoundControl:hover{
        opacity:1;
        transform: scale(1.1);
        border:1px solid black;
        color : yellow;
        
    }
    .musicSoundControl:active{
    transform: scale(0.9);
        color : yellow;
        
    }


/* 네이버 폼 컨테이너 */
.naverFormBox {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 85vw;
    height: 85vh;
    transform: translate(-50%, -50%);
    border: 2px solid #333;
    margin: 0;
    padding:1px;
font-size:18px;
    text-align: center;
    overflow: auto;
    z-index: 9999;
    opacity: 1;
    background-color: rgba(255,255,255,0.95);
    background-size: cover;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);
    max-width: 90%;
    max-height: 90%;
}

/* 닫기 버튼 */
.naverFormClose {
    position: absolute;
    top: 15px;
    right: 15px;
    width: 35px;
    height: 35px;
    font-size: 17px;
    border: 2px solid #333;  /* 테두리 색상 검은색으로 변경 */
    color: #333;  /* 글자 색상 검은색으로 변경 */
    background: white;  /* 배경은 여전히 흰색 */
    border-radius: 50%;
    z-index: 10000;
    cursor: pointer;
    transition: all 0.3s ease;
}

.naverFormClose:hover {
    background: #333;  /* 호버 시 배경 검은색으로 변경 */
    color: white;  /* 호버 시 글자 색상 흰색으로 변경 */
    transform: rotate(90deg);
}

.naverFormClose:active {
    transform: scale(0.9);
}




    /* API 폼 컨테이너 */
.apiFormBox {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 85vw;
  height: 85vh;
  transform: translate(-50%, -50%);
  border: 2px solid #333;
  margin: 0;
  padding: 1px;
  font-size: 18px;
  text-align: center;
  overflow: auto;
  z-index: 9999;
  opacity: 1;
    background-color: rgba(0, 0, 0, 0.4);
  background-size: cover;
  display: none; /* 기본적으로 숨김 */
  flex-direction: column;
  justify-content: center;
  align-items: center;
  border-radius: 10px;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
  max-width: 90%;
  max-height: 90%;
}

/* 닫기 버튼 */
.apiFormClose {
  position: absolute;
  top: 15px;
  right: 15px;
  width: 35px;
  height: 35px;
  font-size: 17px;
  border: 2px solid #333;  /* 테두리 색상 검은색으로 변경 */
  color: #333;  /* 글자 색상 검은색으로 변경 */
  background: white;  /* 배경은 여전히 흰색 */
  border-radius: 50%;
  z-index: 10000;
  cursor: pointer;
  transition: all 0.3s ease;
}

.apiFormClose:hover {
  background: #333;  /* 호버 시 배경 검은색으로 변경 */
  color: white;  /* 호버 시 글자 색상 흰색으로 변경 */
  transform: rotate(90deg);
}

.apiFormClose:active {
  transform: scale(0.9);
}



/* 스크롤 차단 */
body.form-open {
    overflow: hidden;
}


   


    .naverFormBtn{
    position : fixed;
    width :50px;
    height:50px;
    z-index:991;
    border : 1px black solid;
    margin-left:5px;
    margin-top:180px;
    padding:1px;
    font-size:18px;
    text-align:center;
    color:black;
    background-color:rgba(255,255,255,0);
    overflow: hidden;
    word-break: break-all;
    background-size:cover;
    }
   
    .naverFormBtn:hover{
        opacity:1;
        transform: scale(1.1);
        border:1px solid black;
        color : yellow;
        
    }
    .naverFormBtn:active{
    transform: scale(0.9);
        color : yellow;
        
    }



    .attackControl {
    position: fixed;
    width: 50px;
    height: 50px;
    z-index: 1200;
    border: 1px black solid;
    margin-top: 300px;
    margin-left:5px;
    padding: 1px;
    font-size: 12px;
    text-align: center;
    color: black;
    background-color: rgba(255,255,255,0);
    overflow: hidden;
    word-break: break-all;
    background-image: url("img/attackIcon.png");
 background-color: rgba(0, 0, 0, 0.1);
}
.attackControl:hover {
    transform: scale(1.1);
}.attackControl:active {
    transform: scale(0.9);
}

.zoomControl {
    position: fixed;
    width: 50px; /* 가로 크기 50px */
    height: 50px; /* 세로 크기 50px */
    z-index: 991;
    border: 1px solid white;
    margin-top: 240px;
    margin-left: 5px;
    font-size: 12px;
    text-align: center;
    color: black;
    background-color: rgba(0, 0, 0, 0);
    overflow: hidden;
    word-break: break-all;
    background-size: cover;
    display: grid; /* Grid 레이아웃 사용 */
    grid-template-rows: repeat(2, 25px); /* 2개의 행으로 25px씩 설정 */
    grid-template-columns: repeat(2, 25px); /* 2개의 열로 25px씩 설정 */
    grid-gap: 0px;
}


/* 버튼 공통 스타일 */
.zoomBtn {
    width: 5px;
    height: 10px;
    font-size: 15px;
    border: 0px solid #aaa;
    border-radius: 3px;
    background: transparent; /* 배경을 완전히 투명하게 설정 */
    transition: background 0.2s;
    padding: 0;
    outline: none;
}

/* 호버 시 배경색 변경 */
.zoomBtn:hover {
    background: #ffe5b4;
}

/* zoomInit 스타일 유지 */


.zoomInit:hover,.zoomUp:hover, .zoomLeft:hover, .zoomRight:hover, .zoomDown:hover {
    transform: scale(1.1);
}

.zoomInit:active,.zoomUp:active, .zoomLeft:active, .zoomRight:active, .zoomDown:active {
    transform: scale(0.9);
}

/* 버튼 그리드 위치 지정 */
.zoomUp    { grid-row: 1; grid-column: 1; background-color: rgba(0, 0, 0, 0.1); border:1px;}
.zoomLeft  { grid-row: 2; grid-column: 1;background-color: rgba(0, 0, 0, 0.1); border:1px;}
.zoomRight { grid-row: 2; grid-column: 2; background-color: rgba(0, 0, 0, 0.1);border:1px;}
.zoomDown  { grid-row: 1; grid-column: 2;background-color: rgba(0, 0, 0, 0.1); border:1px;}


#zoomRoot {
    width: 9000px;
    height: 6000px;
    position: absolute;
    overflow: auto;
    transform-origin: left top;
    transition: transform 0.3s ease;
    background: rgba(0,0,0,0.05); /* 디버깅용 배경 */
}


    /**/
.goLeft{
position: fixed;
width:30px;
height:30px;


margin-left:659px;
margin-top:40px;
border: 1px white solid;
color : white;
font-size: 12px;
padding-left: 10px;
padding-top: 10px;
background-color: black;
}
    .goLeft:hover{
        opacity:1;
        transform: scale(1.1);
        border:1px solid grey;
        color : yellow;
        
    }
    .goLeft:active{
    transform: scale(0.9);
        color : yellow;
        
    }


.goRight{
position: fixed;
width:30px;
height:30px;
margin-left:740px;
margin-top:40px;
border: 1px white solid;
color : white;
font-size: 12px;
padding-left: 10px;
padding-top: 10px;
background-color: black;
}
    .goRight:hover{
        opacity:1;
        transform: scale(1.1);
        border:1px solid grey;
        color : yellow;
        
    }
    .goRight:active{
        transform: scale(0.9);
        color : yellow;
        
    }


.goUp{
position: fixed;
width:30px;
height:30px;
margin-left:700px;
border: 1px white solid;
color : white;
font-size: 12px;
padding-left: 10px;
padding-top: 10px;
background-color: black;
}
    .goUp:hover{
        opacity:1;
        transform: scale(1.1);
        border:1px solid grey;
        color : yellow;
        
    }
    .goUp:active{
        transform: scale(0.9);
        color : yellow;
        
     }


.goDown{
position: fixed;
width:30px;
height:30px;
margin-left:700px;
margin-top:40px;
border: 1px white solid;
color : white;
font-size: 12px;
padding-left: 10px;
padding-top: 10px;
background-color: black;
}
    .goDown:hover{
        opacity:1;
        transform: scale(1.1);
        border:1px solid grey;
        color : yellow;
        
    }
    .goDown:active{
         transform: scale(0.9);
        color : yellow;
        
    }

.tableBox{
border-spacing: 0;
border-style: none;
}


.titlePad{
width:30px;
height:30px;
padding:0px;
margin:0px;
color:red;
text-align: center;
font-size: 1px;
border-spacing: 0;
border-style:none;
color:rgba(255,255,255,0);
overflow:hidden;
word-break: break-all;
}


    .tilePad:hover{
         opacity:1;
        color:rgba(255,255,255,0);
        transform: scale(1.15);
        border:1px solid red;
         
    }
 .tilePad:active{
         opacity:0.9;
        transform: scale(0.9);
        border:1px solid orange;
        
    }

    
    .itemBag{
    position: fixed;
    width:405px;
    height:207px;
    border:1px solid black;
    z-index:991;
    margin-top: 60px;
    margin-left: 70px;
    padding: 0px;
    border-spacing: 0; /* 변경: none → 0 (표준 속성) */
   
    background-color: rgba(255,255,255,0);
overflow: hidden;

}
/*고정*/
/*고정*/




.itemBagBtn {
    position: fixed;
    width: 33px;
    height: 33px;
    border: 1px solid black;
    z-index: 991;
    margin-top: 60px;
    margin-left: 480px;
    font-size: 15px;
    text-align: center;
    background-color: transparent;

}

.itemBagBtn2 {
    position: fixed;
    width: 33px;
    height: 33px;
    border: 1px solid black;
    z-index: 991;
    margin-top: 100px;
    margin-left: 480px;
    font-size: 15px;
    text-align: center;
    background-color: transparent;

}





.itemPad{
width:100%;
height: 100%;
font-size:15px;
border-spacing: 0; /* 변경: none → 0 (표준 속성) */
border :solid 0px black;
color:white;
position: relative;
overflow: hidden;
}




.itemPadIn:hover{
      cursor: url('cur/cur117.cur'), pointer !important;
}
.itemPadIn{
    width:33px;
    height:33px;
    padding:0px;
    margin:0px;
    color:white;
    text-align: center;
    font-size: 12px;
    border-spacing: 0;
    border-style:none;
    overflow:hidden;
    word-break: break-all;
       background-repeat: round; 
        background-position:center; 

        filter: brightness(1);
        opacity: 1;

    }
    .itemBagBtn:hover,
    .itemBagBtn2:hover,
         .itemBagBtn3:hover,
        .itemPadIn:hover{
            will-change: transform; /* 호버 시 변환 예고 */
            transition: transform 0.3s ease;
        opacity:1;
        transform: scale(1.05);
        border:1px solid yellow;
        color : yellow;
        
        }
        .itemBagBtn:active,
        .itemBagBtn2:active,
        .itemBagBtn3:active,
        .itemPadIn:active{
        opacity:0.9;
        transform: scale(0.95);
        border:1px solid orange;
        
        }

        .b1b  { background-image: url("img/1.bmp"); background-size: 30px 33px; }
.b2b  { background-image: url("img/2.bmp"); background-size: 30px 33px; }
.b3b  { background-image: url("img/3.bmp"); background-size: 30px 33px; }
.b4b  { background-image: url("img/4.bmp"); background-size: 30px 33px; }
.b5b  { background-image: url("img/5.bmp"); background-size: 30px 33px; }
.b6b  { background-image: url("img/6.png"); background-size: 30px 33px; }
.b7b  { background-image: url("img/7.png"); background-size: 30px 33px; }
.b8b  { background-image: url("img/8.png"); background-size: 30px 33px;}
.b9b  { background-image: url("img/9.png"); background-size: 30px 33px; }
.b10b { background-image: url("img/10.png"); background-size: 30px 33px; }
.b11b { background-image: url("img/11.png"); background-size: 30px 33px; }
.b12b { background-image: url("img/12.png"); background-size: 30px 33px; }
.b13b { background-image: url("img/13.png"); background-size: 30px 33px; }
.b14b { background-image: url("img/14.png"); background-size: 30px 33px; }
.b15b { 
    background-size: 30px 33px;opacity:0;/*하늘블럭*/
}
.b16b { background-image: url("img/16.bmp"); background-size: 30px 33px; }
.b17b { background-image: url("img/17.bmp"); background-size: 30px 33px; }
.b18b { background-image: url("img/18.bmp"); background-size: 30px 33px; }
.b19b { background-image: url("img/19.bmp"); background-size: 30px 33px; }
.b20b { background-image: url("img/20.bmp"); background-size: 30px 33px; }
.b21b { background-image: url("img/21.bmp"); background-size: 30px 33px; }
.b22b { background-image: url("img/22.bmp"); background-size: 30px 33px; }
.b23b { background-image: url("img/23.bmp"); background-size: 30px 33px; }
.b24b { background-image: url("img/24.bmp"); background-size: 30px 33px; }
.b25b { background-image: url("img/25.bmp"); background-size: 30px 33px; }
.b26b { background-image: url("img/26.bmp"); background-size: 30px 33px; }
.b27b { background-image: url("img/27.bmp"); background-size: 30px 33px; }
.b28b { background-image: url("img/28.bmp"); background-size: 30px 33px; }
.b29b { background-image: url("img/29.bmp"); background-size: 30px 33px; }
.b30b { background-image: url("img/30.bmp"); background-size: 30px 33px; }
.b31b { background-image: url("img/31.bmp"); background-size: 30px 33px; }
.b32b { background-image: url("img/32.bmp"); background-size: 30px 33px; }
.b33b { background-image: url("img/33.bmp"); background-size: 30px 33px; }
.b34b { background-image: url("img/34.bmp"); background-size: 30px 33px; }
.b35b { background-image: url("img/35.bmp"); background-size: 30px 33px; }
.b36b { background-image: url("img/36.bmp"); background-size: 30px 33px; }
.b37b { background-image: url("img/37.bmp"); background-size: 30px 33px; }
.b38b { background-image: url("img/38.bmp"); background-size: 30px 33px; }
.b46b { background-image: url("img/46.gif"); background-size: 30px 33px; }
.b47b { background-image: url("img/47.png"); background-size: 30px 33px; }
.b48b { background-image: url("img/48.png"); background-size: 30px 33px; }
.b49b { background-image: url("img/49.png"); background-size: 30px 33px; }
.b50b { background-image: url("img/50.png"); background-size: 30px 33px; }
.b51b { background-image: url("img/51.png"); background-size: 30px 33px; }
.b52b { background-image: url("img/52.png"); background-size: 30px 33px; }
.b53b { background-image: url("img/53.png"); background-size: 30px 33px; }
.b54b { background-image: url("img/54.gif"); background-size: 30px 33px; }
.b55b {background-image: url("img/55.png"); background-size: 30px 33px; }
.b57b { background-image: url("img/57.png"); background-size: 30px 33px; }
.b58b { background-image: url("img/58.png"); background-size: 30px 33px; }
.b59b { background-image: url("img/59.png"); background-size: 30px 33px; }
.b60b { background-image: url("img/60.png"); background-size: 30px 33px; }
.b61b { background-image: url("img/61.png"); background-size: 30px 33px; }
.b62b { background-image: url("img/62.gif"); background-size: 30px 33px; }
.b63b { background-image: url("img/63.png"); background-size: 30px 33px; }
.b64b { background-image: url("img/64.png"); background-size: 30px 33px; }
.b65b { background-image: url("img/65.png"); background-size: 30px 33px; }
.b66b { background-image: url("img/66.png"); background-size: 30px 33px; }
.b67b { background-image: url("img/67.png"); background-size: 30px 33px; }
.b68b { background-image: url("img/68.png"); background-size: 30px 33px; }
.b69b { background-image: url("img/69.png"); background-size: 30px 33px; }
.b70b { background-image: url("img/70.png"); background-size: 30px 33px; }
.b71b { background-image: url("img/71.png"); background-size: 30px 33px; }
.b72b { background-image: url("img/72.png"); background-size: 30px 33px; }
.b73b { background-image: url("img/73.png"); background-size: 30px 33px; }
.b74b { background-image: url("img/74.png"); background-size: 30px 33px; }
.b75b { background-image: url("img/75.png"); background-size: 30px 33px; }
.b76b { background-image: url("img/76.png"); background-size: 30px 33px; }
.b77b { background-image: url("img/77.png"); background-size: 30px 33px; }
.b78b { background-image: url("img/78.png"); background-size: 30px 33px; }
.b79b { background-image: url("img/79.png"); background-size: 30px 33px; }
.b80b { background-image: url("img/80.png"); background-size: 30px 33px; }
.b81b { background-image: url("img/81.png"); background-size: 30px 33px; }
.b82b { background-image: url("img/82.png"); background-size: 30px 33px; }

.b84b { background-image: url("img/84.png"); background-size: 30px 33px; }

.b95b { background-image: url("img/95.png"); background-size: 30px 33px; }
.b96b {  background-image: url("img/96.png"); background-size: 30px 33px; }
.b97b {  background-image: url("img/97.png"); background-size: 30px 33px; }
.b98b {  background-image: url("img/98.png"); background-size: 30px 33px; }
.b99b {  background-image: url("img/99.gif"); background-size: 30px 33px; }
.b100b { background-image: url("img/100.png"); background-size: 30px 33px; }
.b101b { background-image: url("img/101.png"); background-size: 30px 33px; }
.b102b { background-image: url("img/102.png"); background-size: 30px 33px; }
.b103b { background-image: url("img/103.png"); background-size: 30px 33px; }
.b104b { background-image: url("img/104.png"); background-size: 30px 33px; }
.b105b { background-image: url("img/105.png"); background-size: 30px 33px; }
.b106b { background-image: url("img/106.png"); background-size: 30px 33px; }
.b107b { background-image: url("img/107.png"); background-size: 30px 33px; }
.b108b { background-image: url("img/108.png"); background-size: 30px 33px; }
.b109b { background-image: url("img/109.png"); background-size: 30px 33px; }
.b110b { background-image: url("img/110.png"); background-size: 30px 33px; }
.b111b { background-image: url("img/111.png"); background-size: 30px 33px; }
.b112b { background-image: url("img/112.png"); background-size: 30px 33px; }
.b113b { background-image: url("img/113.png"); background-size: 30px 33px; }
.b114b { background-image: url("img/114.gif"); background-size: 30px 33px; }
.b115b { background-image: url("img/115.png"); background-size: 30px 33px;background-repeat: no-repeat;}
.b116b { background-image: url("img/116.png"); background-size: 30px 33px; background-repeat: no-repeat;}
.b117b { background-image: url("img/117.png"); background-size: 30px 33px;background-repeat: no-repeat; }
.b118b { background-image: url("img/118.png"); background-size: 30px 33px;background-repeat: no-repeat;}
.b119b { background-image: url("img/119.png"); background-size: 30px 33px;background-repeat: no-repeat;}
.b120b { background-image: url("img/120.png"); background-size: 30px 33px; background-repeat: no-repeat;}
.b121b { background-image: url("img/121.png"); background-size: 30px 33px;background-repeat: no-repeat; }
.b122b { background-image: url("img/122.png"); background-size: 30px 33px;background-repeat: no-repeat;}
.b123b { background-image: url("img/123.png"); background-size: 30px 33px; background-repeat: no-repeat;}
.b124b { background-image: url("img/124.png"); background-size: 30px 33px;background-repeat: no-repeat; }
.b125b { background-image: url("img/125.png"); background-size: 30px 33px;background-repeat: no-repeat; }
.b126b { background-image: url("img/126.png"); background-size: 30px 33px;background-repeat: no-repeat; }
.b127b { background-image: url("img/127.png"); background-size: 30px 33px;background-repeat: no-repeat;}
.b128b { background-image: url("img/128.png"); background-size: 30px 33px; background-repeat: no-repeat;}
.b129b { background-image: url("img/129.png"); background-size: 30px 33px;background-repeat: no-repeat; }
.b130b { background-image: url("img/130.png"); background-size: 30px 33px;background-repeat: no-repeat; }
.b131b { background-image: url("img/131.png"); background-size: 30px 33px;background-repeat: no-repeat; }
.b132b { background-image: url("img/132.png"); background-size: 30px 33px;background-repeat: no-repeat; }



.b149b { background-image: url("img/149.png"); background-size: 30px 33px; }
.b150b { background-image: url("img/150.png"); background-size: 30px 33px; }
.b151b { background-image: url("img/151.png"); background-size: 30px 33px; }
.b152b { background-image: url("img/152.png"); background-size: 30px 33px; background-repeat: no-repeat;}
.b153b { background-image: url("img/153.png"); background-size: 30px 33px; }
.b154b { background-image: url("img/154.png"); background-size: 30px 33px; }
.b155b { background-image: url("img/155.png"); background-size: 30px 33px; }
.b156b { background-image: url("img/156.png"); background-size: 30px 33px; }
.b157b { background-image: url("img/157.png"); background-size: 30px 33px; }
.b158b { background-image: url("img/158.png"); background-size: 30px 33px; }
.b159b { background-image: url("img/159.png"); background-size: 30px 33px; }
.b160b { background-image: url("img/160.png"); background-size: 30px 33px; }
.b161b { background-image: url("img/161.png"); background-size: 30px 33px; }
.b162b { background-image: url("img/162.png"); background-size: 30px 33px; }
.b163b { background-image: url("img/163.png"); background-size: 30px 33px; }
.b164b { background-image: url("img/164.png"); background-size: 30px 33px; }
.b165b { background-image: url("img/165.png"); background-size: 30px 33px; }
.b166b { background-image: url("img/166.png"); background-size: 30px 33px;background-repeat: no-repeat; }

.b167b { background-image: url("img/167.webp"); background-size: 60px 60px;background-repeat: no-repeat; color:white;background-color: black;}



.b83b, .b85b, .b86b { /* 불타는화염, 무지개, 용암 블럭 */
    filter: brightness(1) !important;
    opacity: 1 !important;
    background-size: 30px 33px !important;
}

/* 기존 블럭 클래스에 추가 */
.b83b { background-image: url("img/83.gif"); }
.b85b { background-image: url("img/85.gif"); }
.b86b { background-image: url("img/86.png"); }


.b999b { background-image: url(""); }



/*
https://terraria.wiki.gg/wiki/Category:Placed_block_images
*/




.b1b, .b2b, .b3b, .b4b, .b48b, .b61b, .b10b, .b11b, .b12b,
.b13b, .b14b, .b46b, .b54b, .b52b, .b49b, .b50b, .b51b, .b56b {
    filter: var(--block-brightness, brightness(0.85));
}


/* 모든 고정 요소에 적용 */
.goHome, .fullScreen, .musicSoundControl, .zoomControl,.itemBag,.itemBagBtn,.itemBagBtn2
.mainBoxTop, .dayTimeBox, .hpBox, .armorBox, .selectedBlockDisplay {
    z-index: 1000 !important;
}


/*https://gifer.com/en/Ryzw*/
/*https://terraria.wiki.gg/wiki/Category:Placed_block_images*/
/*테이블 데이터 내부값*/
.td{
    border-spacing: 0;
    border-style: none;
}

/*
https://steamcommunity.com/id/RunicPixels/myworkshopfiles/?appid=431960&p=2 메인 스타트 배경화면 참고 주소
*/


.startBeforeScreen {
    position: fixed;
    width: 100%;
    height: 100%;
    background-color: black;
    background-size: cover;
    z-index: 10002;
    overflow: hidden;
}

.startScreen {
    position: fixed;
    width: 100%;
    height: 100%;
    background: url('titleImg/backimg.jpg') no-repeat center center;
    background-size: cover;
    z-index: 10001;
    overflow: hidden;
}




#startScreenMiniBackground {
    color : white;
  position: fixed;
  top: 25%; /* 화면 상단에 배치 */
  left: 25%; /* 화면 중앙에 배치 */
  transform: translateX(-50%); /* 수평으로 정확히 중앙에 맞추기 위한 변환 */
 
 
        width: 15%; /* 기본값을 20%로 설정 */
    height: 15%; /* 기본값을 20%로 설정 */
    min-width: 10%; /* 최소 너비를 10%로 설정 */
    max-width: 20%; /* 최대 너비를 30%로 설정 */
    min-height: 15%; /* 최소 높이를 10%로 설정 */
    max-height: 25%; /* 최대 높이를 30%로 설정 */

  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  border: 2px solid white;
  z-index: 1;
  font-size: 1.5rem;
  padding:10px;
  text-align: center;
 animation: moveUpDown 6s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
       cursor: url('cur/cur117.cur'), pointer !important;
}

/* Hover effect - 커지거나 색상 변경 */
#startScreenMiniBackground:hover {
  transform: scale(1.2); /* Hover 시 더 크게 */
  transition: transform 0.3s ease; /* 부드러운 변환 */
  background-color: rgba(255, 255, 255, 0.2); /* 배경 색상 살짝 변경 */
  transform-origin: center center; /* 중심을 화면 중앙으로 설정 */
}

/* Active effect - 클릭 시 크기가 더 작아지거나 효과 */
#startScreenMiniBackground:active {
  transform: scale(0.95); /* 클릭 시 작아짐 */
  transition: transform 0.1s ease; /* 클릭 시 빠른 변화 */
  background-color: rgba(255, 255, 255, 0.4); /* 클릭 시 배경 색상 더 밝게 */
  transform-origin: center center; /* 중심을 화면 중앙으로 설정 */
}


#updateNote {
    color: white;
    position: fixed;
    top: 25%; /* 화면 상단에 배치 */
    left: 75%; /* 화면 오른쪽에 배치 */

        width: 15%; /* 기본값을 20%로 설정 */
    height: 15%; /* 기본값을 20%로 설정 */
    min-width: 10%; /* 최소 너비를 10%로 설정 */
    max-width: 20%; /* 최대 너비를 30%로 설정 */
    min-height: 15%; /* 최소 높이를 10%로 설정 */
    max-height: 25%; /* 최대 높이를 30%로 설정 */

    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border: 2px solid white;
    z-index: 1;
    font-size: 1.5rem; /* 글자 크기 반으로 줄임 */
    padding: 10px;
    text-align: center;
    animation: moveUpDown 9s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
    cursor: url('cur/cur117.cur'), pointer !important;
     background-image: url('https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlfrHs%2FbtsOirvcAn5%2FkjEmfKRPT9WuBeYTksORCK%2Fimg.png');
}

/* Hover effect - 커지거나 색상 변경 */
#updateNote:hover {
    transform: scale(1.2); /* Hover 시 더 크게 */
    transition: transform 0.3s ease; /* 부드러운 변환 */
    background-color: rgba(255, 255, 255, 0.2); /* 배경 색상 살짝 변경 */
    transform-origin: center center; /* 중심을 화면 중앙으로 설정 */
}

/* Active effect - 클릭 시 크기가 더 작아지거나 효과 */
#updateNote:active {
    transform: scale(0.95); /* 클릭 시 작아짐 */
    transition: transform 0.1s ease; /* 클릭 시 빠른 변화 */
    background-color: rgba(255, 255, 255, 0.4); /* 클릭 시 배경 색상 더 밝게 */
    transform-origin: center center; /* 중심을 화면 중앙으로 설정 */
}


#userImg1 {
    opacity: 0.85;
    color: white;
    position: fixed;
    top: 47%; /* 화면 상단에 배치 */
    left: 25%; /* 화면 오른쪽에 배치 */

        width: 15%; /* 기본값을 20%로 설정 */
    height: 15%; /* 기본값을 20%로 설정 */
    min-width: 10%; /* 최소 너비를 10%로 설정 */
    max-width: 20%; /* 최대 너비를 30%로 설정 */
    min-height: 15%; /* 최소 높이를 10%로 설정 */
    max-height: 25%; /* 최대 높이를 30%로 설정 */

    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border: 2px solid white;
    z-index: 1;
    font-size: 1.5rem; /* 글자 크기 반으로 줄임 */
    padding: 10px;
    text-align: center;
    animation: moveUpDown 9s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
 
     background-image: url('https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FriO8Y%2FbtsOhoF2ATS%2FIRdT0l5daJTdVQgG1qUfHk%2Fimg.png');
}

#userImg2 {
    opacity: 0.85;

    color: white;
    position: fixed;
    top: 47%; /* 화면 상단에 배치 */
    left: 75%; /* 화면 오른쪽에 배치 */

        width: 15%; /* 기본값을 20%로 설정 */
    height: 15%; /* 기본값을 20%로 설정 */
    min-width: 10%; /* 최소 너비를 10%로 설정 */
    max-width: 20%; /* 최대 너비를 30%로 설정 */
    min-height: 15%; /* 최소 높이를 10%로 설정 */
    max-height: 25%; /* 최대 높이를 30%로 설정 */

    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border: 2px solid white;
    z-index: 1;
    font-size: 1.5rem; /* 글자 크기 반으로 줄임 */
    padding: 10px;
    text-align: center;
    animation: moveUpDown 9s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
   
     background-image: url('https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnyWum%2FbtsOh2PZQod%2FvABrkwWP4piKysIL68lSkk%2Fimg.png');
}

.startText {
    position: fixed;
    padding: 10px;
    top: 25%;
    left: 50%;
    transform: translateX(-50%);
    width: 800px;
    height: 115px;
    border: 0px solid #00bfff; /* startBtn과 동일한 네온 하늘색 테두리 */
    border-radius: 8px;
    color: white; /* 밝은 네온 블루 텍스트 색상 */
    background-color: rgba(0, 0, 0, 0.25); /* 채도를 낮춘 연한 파란색 배경 */
    font-size: 2rem;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* 어두운 파란색 텍스트 그림자 */
    font-family: 'DungGeunMo', sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6); /* 어두운 파란색 그림자 */
    transition: all 0.3s ease;
    animation: moveUpDown 10s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
}



/* startText2 스타일 수정 */
.startText2 {
    position: fixed;
    top: 65%;
    left: 33%;
    transform: translateX(-50%);
         width: 275px;
    height: 65px;
    border: none; /* 테두리 제거 */
    border-radius: 8px;
    color: #ffffff; /* 흰색 텍스트 색상 */
    background-color: rgba(0, 0, 0, 0.5); /* 어두운 배경 */
    font-size: 1.8rem;
    font-weight: bold;
    text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8); /* 검은색 텍스트 그림자 */
    font-family: 'DungGeunMo', sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7); /* 검은색 그림자 */
    transition: all 0.6s cubic-bezier(0.25, 0.1, 0.25, 1); /* 초반 빠르고 후반 느리게 변화 */
      animation: moveUpDown 20s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
}

/* startText2 호버 효과 */
.startText2:hover {
    transform: translateX(-50%) scale(1.05); /* transform만 부드럽게 변화 */
    background-color: rgba(255, 255, 255, 0.3); /* 배경 색상 변화 */
    color: #000000; /* 텍스트 색상 변경 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.9); /* 그림자 강조 */
    cursor: url('cur/cur117.cur'), pointer !important;
    transition: background-color 1s cubic-bezier(0.25, 0.1, 0.25, 1), box-shadow 5s cubic-bezier(0.25, 0.1, 0.25, 1); /* 배경색과 그림자만 부드럽게 변화 */
    will-change: transform, background-color, box-shadow; /* 렌더링 최적화 */
}

/* startText2 클릭 시 효과 */
.startText2:active {
    transform: translateX(-50%) scale(0.95);
    background-color: rgba(150, 150, 150, 0.3); /* 클릭 시 어두운 배경 */
    color: #ffffff; /* 클릭 시 텍스트 색상 변화 */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); /* 클릭 시 그림자 감소 */
    transition: background-color 0.1s ease, box-shadow 0.1s ease; /* 클릭 시 배경색과 그림자만 빠르게 변화 */
}

/* startText3 스타일 수정 */
.startText3 {
    position: fixed;
    top: 65%;
    left: 67%;
    transform: translateX(-50%);
   width: 275px;
    height: 65px;
    border: none; /* 테두리 제거 */
    border-radius: 8px;
    color: #ffffff; /* 흰색 텍스트 색상 */
    background-color: rgba(0, 0, 0, 0.5); /* 어두운 배경 */
    font-size: 1.8rem;
    font-weight: bold;
    text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8); /* 검은색 텍스트 그림자 */
    font-family: 'DungGeunMo', sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7); /* 검은색 그림자 */
    transition: all 0.6s cubic-bezier(0.25, 0.1, 0.25, 1); /* 초반 빠르고 후반 느리게 변화 */
      animation: moveUpDown 20s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
}

/* startText3 호버 효과 */
.startText3:hover {
    transform: translateX(-50%) scale(1.05); /* transform만 부드럽게 변화 */
    background-color: rgba(255, 255, 255, 0.3); /* 배경 색상 변화 */
    color: #000000; /* 텍스트 색상 변경 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.9); /* 그림자 강조 */
    cursor: url('cur/cur117.cur'), pointer !important;
    transition: background-color 1s cubic-bezier(0.25, 0.1, 0.25, 1), box-shadow 6s cubic-bezier(0.25, 0.1, 0.25, 1); /* 배경색과 그림자만 부드럽게 변화 */
    will-change: transform, background-color, box-shadow; /* 렌더링 최적화 */
}

/* startText3 클릭 시 효과 */
.startText3:active {
    transform: translateX(-50%) scale(0.95);
    background-color: rgba(150, 150, 150, 0.3); /* 클릭 시 어두운 배경 */
    color: #ffffff; /* 클릭 시 텍스트 색상 변화 */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); /* 클릭 시 그림자 감소 */
    transition: background-color 0.1s ease, box-shadow 0.1s ease; /* 클릭 시 배경색과 그림자만 빠르게 변화 */
}


.hrefLink {
    color: white; /* 기본 텍스트 흰색 */
    background-color: rgba(0, 0, 0, 0.4); /* 반투명 검정 배경 */
    text-decoration: none;
    position: relative;
    display: inline-block;
    padding: 5px 10px;
    transition: color 0.3s, background-color 0.3s;
    font-size: 1.4rem;
}

.hrefLink:visited {
    color: #dddddd; /* 방문 후 연한 회색 */
}

.hrefLink:hover {
    background-color: rgba(255, 255, 255, 0.2); /* 살짝 밝게 */
    color: white; /* hover에도 흰색 유지 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.9);
    cursor: url('cur/cur117.cur'), pointer !important;

    will-change: transform, background-color, box-shadow;
}

.hrefLink:active {
    background-color: rgba(255, 255, 255, 0.1); /* 클릭 시 약간 밝은 배경 */
    color: white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    transition: background-color 0.1s ease, box-shadow 0.1s ease;
}


.hrefLink2 {
    color: white; /* 기본 텍스트 흰색 */
    background-color: rgba(0, 0, 0, 0.2); /* 반투명 검정 배경 */
    text-decoration: none;
    position: relative;
    display: inline-block;
    padding: 5px;
    transition: color 0.3s, background-color 0.3s;
    font-size: 1.4rem;
}

.hrefLink2:visited {
    color: #dddddd; /* 방문 후 연한 회색 */
}

.hrefLink2:hover {
    background-color: rgba(255, 255, 255, 0.1); /* 살짝 밝게 */
    color: white; /* hover에도 흰색 유지 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.9);
    cursor: url('cur/cur117.cur'), pointer !important;

    will-change: transform, background-color, box-shadow;
}

.hrefLink2:active {
    background-color: rgba(255, 255, 255, 0.1); /* 클릭 시 약간 밝은 배경 */
    color: white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    transition: background-color 0.1s ease, box-shadow 0.1s ease;
}


    .hrefLinkBlogData {
    color: white;
    text-decoration: underline;
         font-size: 1.8rem;
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
    }

    /* 방문한 링크 */
    .hrefLinkBlogData:visited {
    color: #ccc;
    }

    /* 마우스 오버 시 */
    .hrefLinkBlogData:hover {
    background-color: rgba(255, 255, 255, 0.2); /* 살짝 밝게 */
    color: white; /* 흰색 유지 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.9);
    cursor: url('cur/cur117.cur'), pointer !important;
    will-change: transform, background-color, box-shadow;
    }

    /* 클릭 중 */
    .hrefLinkBlogData:active {
    background-color: rgba(255, 255, 255, 0.1); /* 더 얕은 배경 */
    color: white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    transition: background-color 0.1s ease, box-shadow 0.1s ease;
    }

      .hrefLinkBlogData2 { 
      color: white;
      text-align: center;
      text-decoration: underline;
      font-size: 1rem;
    }

    #loginModal {
      display: none; /* 기본적으로 숨겨져 있음 */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5); /* 반투명 배경 */
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }

    /* 모달 내용 */
    #loginModalContent {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      width: 80%;
      max-width: 400px;
      box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.2);
      position: relative;
    }

    /* 닫기 버튼 */
    #loginCloseBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      background-color: red;
      color: white;
      border: none;
      border-radius: 5px;
    }



/* startBtn 스타일 수정 */
.startBtn {
    position: fixed;
    top: 48%;
    left: 33%;
    transform: translateX(-50%);
    width: 290px;
    height: 70px;
    z-index: 1003;
    border: none; /* 테두리 제거 */
    border-radius: 8px;
    color: #ffffff; /* 흰색 텍스트 색상 */
    background-color: rgba(0, 0, 0, 0.5); /* 어두운 배경 */
    font-size: 1.6rem;
    font-weight: bold; /* 텍스트를 더 진하게 */
    text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8); /* 검은색 텍스트 그림자 */
    font-family: 'DungGeunMo', sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7); /* 검은색 그림자 */
  animation: moveUpDown 20s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
}

/* startBtn 호버 효과 */
.startBtn:hover {
    transform: translateX(-50%) scale(1.05); /* transform만 부드럽게 변화 */
    background-color: rgba(255, 255, 255, 0.3); /* 배경 색상 변화 */
    color: #000000; /* 텍스트 색상 변경 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.9); /* 그림자 강조 */
    cursor: url('cur/cur117.cur'), pointer !important;
    transition: background-color 1s cubic-bezier(0.25, 0.1, 0.25, 1), box-shadow 1s cubic-bezier(0.25, 0.1, 0.25, 1); /* 배경색과 그림자만 부드럽게 변화 */
    will-change: transform, background-color, box-shadow; /* 렌더링 최적화 */
}

/* startBtn 클릭 시 효과 */
.startBtn:active {
    transform: translateX(-50%) scale(0.95); /* 클릭 시 빠르게 크기 변화 */
    background-color: rgba(150, 150, 150, 0.3); /* 클릭 시 어두운 배경 */
    color: #ffffff; /* 클릭 시 텍스트 색상 변화 */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); /* 클릭 시 그림자 감소 */
    transition: background-color 0.1s ease, box-shadow 0.1s ease; /* 클릭 시 빠르게 변화 */
}

/* loadBtn 스타일 수정 */
.loadBtn {
    position: fixed;
    top: 48%;
    left: 67%;
    transform: translateX(-50%);
      width: 290px;
    height: 70px;
    z-index: 1003;
    border: none; /* 테두리 제거 */
    border-radius: 8px;
    color: #ffffff; /* 흰색 텍스트 색상 */
    background-color: rgba(0, 0, 0, 0.5); /* 어두운 배경 */
    font-size: 1.6rem;
    font-weight: bold; /* 텍스트를 더 진하게 */
    text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8); /* 검은색 텍스트 그림자 */
    font-family: 'DungGeunMo', sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7); /* 검은색 그림자 */
  animation: moveUpDown 20s infinite; /* 애니메이션 추가 */
    transform-origin: center; /* 변환 기준을 중앙으로 설정 */
}

/* loadBtn 호버 시 효과 */
.loadBtn:hover {
    transform: translateX(-50%) scale(1.05); /* transform만 부드럽게 변화 */
    background-color: rgba(255, 255, 255, 0.3); /* 배경 색상 변화 */
    color: #000000; /* 텍스트 색상 변경 */
    box-shadow: 0 5px 15px rgba(81, 62, 62, 0.9); /* 그림자 강조 */
    cursor: url('cur/cur117.cur'), pointer !important;
    transition: background-color 1s cubic-bezier(0.25, 0.1, 0.25, 1), box-shadow 1s cubic-bezier(0.25, 0.1, 0.25, 1); /* 배경색과 그림자만 부드럽게 변화 */
    will-change: transform, background-color, box-shadow; /* 렌더링 최적화 */
}

/* loadBtn 클릭 시 효과 */
.loadBtn:active {
    transform: translateX(-50%) scale(0.95); /* 클릭 시 빠르게 크기 변화 */
    background-color: rgba(150, 150, 150, 0.3); /* 클릭 시 어두운 배경 */
    color: #ffffff; /* 클릭 시 텍스트 색상 변화 */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); /* 클릭 시 그림자 감소 */
    transition: background-color 0.1s ease, box-shadow 0.1s ease; /* 클릭 시 배경색과 그림자만 빠르게 변화 */
}





/* Keyframes for the vertical movement animation with size change */
@keyframes moveUpDown {
    0% {
        transform: translate(-50%, -50%) scale(1); /* 원래 크기 */
    }
    3.33% {
        transform: translate(-50%, -50%) scale(0.99); /* 아주 조금 줄어듦 */
    }
    6.67% {
        transform: translate(-50%, -50%) scale(0.98); /* 조금 줄어듦 */
    }
    10% {
        transform: translate(-50%, -50%) scale(0.97); /* 점점 줄어듦 */
    }
    13.33% {
        transform: translate(-50%, -50%) scale(0.96); /* 줄어듦 */
    }
    16.67% {
        transform: translate(-50%, -50%) scale(0.95); /* 더 줄어듦 */
    }
    20% {
        transform: translate(-50%, -50%) scale(0.94); /* 더 줄어듦 */
    }
    23.33% {
        transform: translate(-50%, -50%) scale(0.93); /* 조금 더 줄어듦 */
    }
    26.67% {
        transform: translate(-50%, -50%) scale(0.92); /* 점차 줄어듦 */
    }
    30% {
        transform: translate(-50%, -50%) scale(0.91); /* 줄어듦 */
    }
    33.33% {
        transform: translate(-50%, -50%) scale(0.9); /* 최대로 줄어듦 */
    }
    36.67% {
        transform: translate(-50%, -50%) scale(0.91); /* 다시 커짐 */
    }
    40% {
        transform: translate(-50%, -50%) scale(0.92); /* 다시 커짐 */
    }
    43.33% {
        transform: translate(-50%, -50%) scale(0.93); /* 커짐 */
    }
    46.67% {
        transform: translate(-50%, -50%) scale(0.94); /* 더 커짐 */
    }
    50% {
        transform: translate(-50%, -50%) scale(0.95); /* 다시 커짐 */
    }
    53.33% {
        transform: translate(-50%, -50%) scale(0.96); /* 더 커짐 */
    }
    56.67% {
        transform: translate(-50%, -50%) scale(0.97); /* 거의 원래 크기 */
    }
    60% {
        transform: translate(-50%, -50%) scale(0.98); /* 거의 원래 크기 */
    }
    63.33% {
        transform: translate(-50%, -50%) scale(0.99); /* 거의 원래 크기 */
    }
    66.67% {
        transform: translate(-50%, -50%) scale(1); /* 원래 크기로 돌아옴 */
    }
    70% {
        transform: translate(-50%, -50%) scale(1.01); /* 다시 조금 커짐 */
    }
    73.33% {
        transform: translate(-50%, -50%) scale(1.02); /* 더 커짐 */
    }
    76.67% {
        transform: translate(-50%, -50%) scale(1.03); /* 커짐 */
    }
    80% {
        transform: translate(-50%, -50%) scale(1.04); /* 더 커짐 */
    }
    83.33% {
        transform: translate(-50%, -50%) scale(1.05); /* 최대로 커짐 */
    }
    86.67% {
        transform: translate(-50%, -50%) scale(1.04); /* 다시 조금 줄어듦 */
    }
    90% {
        transform: translate(-50%, -50%) scale(1.03); /* 조금 줄어듦 */
    }
    93.33% {
        transform: translate(-50%, -50%) scale(1.02); /* 다시 줄어듦 */
    }
    96.67% {
        transform: translate(-50%, -50%) scale(1.01); /* 조금 더 줄어듦 */
    }
    100% {
        transform: translate(-50%, -50%) scale(1); /* 원래 크기로 돌아옴 */
    }
}



.startText,
.startText2,
.startText3,
.startBtn,
.loadBtn {
  font-family: 'DungGeunMo', sans-serif !important;
}

        /* 기존 CSS 유지 */
        #chat-box {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 30%;
            background: rgba(0,0,0,0.7);
            border-radius: 8px;
            padding: 10px;
            color: white;
            z-index: 1000;
            font-size: 1.2rem;
              font-family: 'DungGeunMo', sans-serif !important;
        }
        #chat-log {
            height: 120px;
            overflow-y: hidden;
            font-size: 1rem;
            margin-bottom: 10px;
              font-family: 'DungGeunMo', sans-serif !important;
        }
        #chat-input {
            width: 50%;
            max-height:20%;
            padding: 5px;
  font-family: 'DungGeunMo', sans-serif !important;
            margin-right: 5px;

        }
        #chat-open-btn{
            font:black;
     font-family: 'DungGeunMo', sans-serif !important;
            /**/
        }
        #chat-size-btn{
            font:black;
       font-family: 'DungGeunMo', sans-serif !important;
            /**/
        }
        #chat-sign-title{
       font-family: 'DungGeunMo', sans-serif !important;
            font:black;
            /**/
        }
        #chat-sign-content{
  font-family: 'DungGeunMo', sans-serif !important;
            font:black;
            /**/
        }
        #send-btn {
  font-family: 'DungGeunMo', sans-serif !important;


        }
      /* 모든 클릭 가능한 요소에 커서 적용 */
/* 모든 클릭 가능한 요소에 커서 적용 */
.naverFormBtn,
.goHome,
.fullScreen,
.musicSoundControl,
.zoomControl,
.itemBagBtn,
.itemBagBtn2,
.itemBagBtn3,
.itemPadIn,
.signBoxClose,
.startBtn,
.startText,
#chat-open-btn,
#chat-size-btn,
#chat-sign-title,
#chat-sign-content,
#chat-box button,
#chat-box [onclick],
/* 줌 방향 버튼 추가 */
.zoomUp,
.zoomDown,
.zoomLeft,
.zoomRight
{
    cursor: url('cur/cur117.cur'), pointer !important;
}

/* 호버/액티브 상태에서도 커서 유지 */
.naverFormBtn,
.goHome:hover,
.fullScreen:hover,
.musicSoundControl:hover,
.zoomControl:hover,
.itemBagBtn:hover,
.itemBagBtn2:hover,
.itemBagBtn3:hover,
.itemPadIn:hover,
.signBoxClose:hover,
.startBtn:hover,
.startText:hover,
#chat-open-btn:hover,
#chat-size-btn:hover,
#chat-sign-title:hover,
#chat-sign-content:hover,
#chat-box button:hover,
#chat-box [onclick]:hover,
.zoomUp:hover,
.zoomDown:hover,
.zoomLeft:hover,
.zoomRight:hover
{
    cursor: url('cur/cur117.cur'), pointer !important;
}

.goHome:active,
.naverFormBtn,
.fullScreen:active,
.musicSoundControl:active,
.zoomControl:active,
.itemBagBtn:active,
.itemBagBtn2:active,
.itemBagBtn3:active,
.itemPadIn:active,
.signBoxClose:active,
.startBtn:active,
.startText:active,
#chat-open-btn:active,
#chat-size-btn:active,
#chat-sign-title:active,
#chat-sign-content:active,
#chat-box button:active,
#chat-box [onclick]:active,
.zoomUp:active,
.zoomDown:active,
.zoomLeft:active,
.zoomRight:active
{
    cursor: url('cur/cur117.cur'), pointer !important;
}




.flash-effect {
  position: fixed;
  top: 0; left: 0; width: 100vw; height: 100vh;
  background: white;
  opacity: 0.85;
  pointer-events: none;
  z-index: 9999;
  animation: flash 0.65s ease;
}

@keyframes flash {
  0%, 100% { opacity: 0; }
  10%, 90% { opacity: 0.8; }
}


.block-particle {
  position: fixed;
  width:0.5px;              /* 더 작게 */
  height: 0.5px;
  background: #000000;        /* 진한 회색 */
  border-radius: 50%;
  pointer-events: none;
  animation: particle-burst 0.7s ease-out forwards; /* 더 짧게 */
  z-index: 9999;
  opacity: 0.7;
}

@keyframes particle-burst {
  0% {
    opacity: 0.7;
    transform: translate(0, 0) scale(1);
  }
  100% {
    opacity: 0;
    transform: 
      translate(
        calc(var(--tx) * 0.5px), 
        calc(var(--ty) * 0.5px)
      ) 
      scale(0.2);
  }
}

@keyframes boss-damage-flash {
  0% { border-color: #ff0000; }
  50% { border-color: #ff4444; }
  100% { border-color: #ff0000; }
}

.boss-damage {
  animation: boss-damage-flash 0.2s linear;
}

.arrow {
  position: fixed;
  width: 50px;
  height: 50px;
  background-image: url("img/120.png");
  border-radius: 3px;
  pointer-events: none;
  z-index: 9999;
  transition: transform 0.1s;
}

.flash-effect,
.block-particle,
.arrow {
  will-change: transform, opacity;
}

@keyframes screen-shake {
    0%,100%{transform:translate(0,0);}
    10%{transform:translate(-15px,10px);}
    20%{transform:translate(10px,-8px);}
    30%{transform:translate(-8px,15px);}
    40%{transform:translate(15px,-10px);}
    50%{transform:translate(-10px,8px);}
    60%{transform:translate(8px,-15px);}
    70%{transform:translate(-5px,5px);}
    80%{transform:translate(5px,-5px);}
    90%{transform:translate(-3px,3px);}
}



.shake-active {
  animation: subtle-shake 0.18s infinite linear;
  /* 흔들림 강도를 더 약하게 하려면 translate값을 1px로 줄이세요 */
}

#zoomRoot.shake-active {
  animation: subtle-shake 0.18s infinite linear;
}


/* 수정된 CSS */
.speech-bubble {
  position: fixed; /* absolute → fixed 변경 */
  white-space: pre-wrap; /* 개행 문자 처리 */
  pointer-events: none; /* 클릭 방해 방지 */
  opacity: 1; /* 초기 투명도 설정 */
  transition: opacity 0.5s; /* 부드러운 사라짐 효과 */
    z-index: 1100;
    display: none;
}

.fade-out {
  opacity: 0 !important;
    display: none;

}

.speech-bubble::after {
  content: '';
  position: absolute;
  bottom: -10px;
  left: 50%;
  transform: translateX(-50%);
  border-width: 10px 10px 0;
  z-index: 1100;
  border-style: solid;
  border-color: rgba(255, 255, 255, 0.9) transparent transparent;
    display: none;

}


a:link {
  color : white;
  text-decoration: none;
}
a:visited {
  color : white;
  text-decoration: none;
}
a:hover {
  color :white;
  text-decoration: underline;
}
a:active {
  color :white;
  text-decoration: none;
}


 /* 스크롤 영역의 스타일을 적용 */
        .scrollContainer {
            border: 0px white solid;
            position: absolute;
            width: 35%;
            height: 60%;
            margin-top: 5%;
            margin-left: 32.25%;

            display: flex;
            justify-content: center; /* 수평 중앙 정렬 */
            align-items: center; /* 수직 중앙 정렬 */
            background-color: black; /* 배경색 */
            overflow: hidden;
            vertical-align: center;
            text-align: center;
        }

        .scrollContent {
            color: white;
            font-size: 20px;
            text-align: center; /* 텍스트 중앙 정렬 */
        }

        /* marquee 대체 효과 */
        @keyframes marquee {
            0% {
                transform: translateY(+70%);
            }
            100% {
                transform: translateY(-100%);
            }
        }

        .scrollingText {
            animation: marquee 35s linear infinite;
        }
#ascii-dancer-wrapper {
    margin-left:50%;
   
    display: inline-block;
text-align: center;
vertical-align: middle;
  transition: transform 0.3s ease-in-out;
  cursor: pointer;
}

#ascii-dancer-wrapper:hover {
        cursor: url('cur/cur117.cur'), pointer !important;
    opacity: 0.5;
  transform: scale(1.3);
  transition: transform 0.2s ease-in-out;
}

#ascii-dancer-wrapper.enlarged {
  transform: scale(2);
  transition: transform 1s ease-in-out;
}

#ascii-dancer {
  font-size: 20px;
  line-height: 1.6em;
  white-space: pre;
  text-align: center;
}
    #ascii-talk {
  text-align: center;
}

    #ascii-dancer-wrapper2 {
    margin-left:7%;
    display: none;
  transition: transform 0.3s ease-in-out;
  cursor: pointer;
}

#ascii-dancer-wrapper2:hover {
        cursor: url('cur/cur117.cur'), pointer !important;
    opacity: 0.5;
  transform: scale(1.3);
  transition: transform 0.2s ease-in-out;
}

#ascii-dancer-wrapper2.enlarged {
  transform: scale(2);
  transition: transform 1s ease-in-out;
}

#ascii-dancer2 {
  font-size: 20px;
  line-height: 1.6em;
  white-space: pre;
}

    #ascii-dancer-wrapper3 {
    margin-left:40%;
    display: none;
  transition: transform 0.3s ease-in-out;
  cursor: pointer;
}

#ascii-dancer-wrapper3:hover {
        cursor: url('cur/cur117.cur'), pointer !important;
    opacity: 0.5;
  transform: scale(1.3);
  transition: transform 0.2s ease-in-out;
}

#ascii-dancer-wrapper3.enlarged {
  transform: scale(2);
  transition: transform 1s ease-in-out;
}

#ascii-dancer3 {
  font-size: 20px;
  line-height: 1.6em;
  white-space: pre;
  text-align: center;
}
</style>
<body ondragstart="return false" onselectstart="return false" contextmenu="return false">
  
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <div class="startBeforeScreen">
<div id="main-note"></div>

<div id="updateNote" title="updateNote/titlePage"onclick="scrollToNote()">UpdateNote</div>
<div id="userImg1">
<a href="https://webcraft.tistory.com/2"title="show userImg"target="_blank" onclick="effectSound('scream')" style="text-decoration: underline;"class="hrefLink2">
  user_img1
</a>
</div>

    <div id="userImg2">
<a href="webCraft1.5.html" title="enter last ver!"target="_blank"onclick="effectSound('scream')" style="text-decoration: underline;"class="hrefLink2">
  last_version (1.5)
</a>    
</div>


<div id="startScreenMiniBackground"  title="go!"onclick="removeStartBeforePage();">Click to start</div>


<!--<center><img src="https://images.unsplash.com/photo-1501862700950-18382cd41497?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1947&q=80"alt="earth"width="auto" height="100%"class="back"></center>--><br><br><br>


<div class="scrollContainer">
    <div class="scrollContent">
        <div class="scrollingText">
        Welcome to WebCraft.<br><br><br><br><br><br><br>

        You can move the player using the arrow keys on your keyboard.<br><br><br><br><br><br>
        We recommend using a PC or desktop with the Chrome browser.<br><br><br><br><br><br>
        Some features may not work if pop-ups or cookies are disabled.<br><br><br><br><br>

        WebCraft is a game where you can build anything you imagine.<br><br><br><br><br><br><br><br>
        Now, unleash your creativity and imagination.<br><br><br><br><br><br><br><br>
        Use a variety of blocks to create any shape you want.<br><br><br><br><br><br><br><br>
        Everything begins at your fingertips.<br><br><br><br><br><br><br><br>
        If you've come this far, press the start button<br><br><br><br><br><br>
        &emsp;&emsp;&emsp;and enter the world of WebCraft!<br><br><br><br><br><br><br><br><br><br><br>

        Build Mode: type "gamemode1"
       
        </div>
    </div>
</div>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>




  <div id="ascii-dancer-wrapper" title="easterEgg">
    <center><p id="ascii-talk"> touch me!</p></center>
    <br>
    <div id="ascii-dancer"></div></div>
  <div id="ascii-dancer-wrapper2"><div id="ascii-dancer2"></div></div>
  <div id="ascii-dancer-wrapper3"><div id="ascii-dancer3"></div></div>


<hr>
<div id="developer-note">
   
    <center>
     <font color="white" size="6px" id="typing-text">2025-05-27 [ Developer's Note ]  Hello, players! Current Version: 3.0</font>
 </div>
 <hr>
<center>
<font color="white" size="6px" class="hrefLink" onclick="effectSound('playerDie')">
  <a href="https://github.com/HunchKR/webCraft" target="_blank" style="color: white; text-decoration: underline;">
    🔗 Frontend: Hunch`s webCraft GitHub Repository
  </a>
</font>
<hr>

<font color="white" size="6px" class="hrefLink"  onclick="effectSound('playerDie')">
  <a href="https://github.com/VectR-Shin/webcraft.git" target="_blank" style="color: white; text-decoration: underline;">
    🔗 Backend: VectR-Shin/webcraft GitHub Repository
  </a>
</font>
<hr>

  <font color="white" size="6px" class="hrefLink" id="hrefLinkBlogData">
<a href="#" target="_blank" id="hrefLinkBlogData2">Fetching latest blog post...</a>
  </font>

  </center>


<!-- 각기 다른 속도, 크기, 방향의 달팽이들 -->
<marquee direction="right" scrollamount="1" scrolldelay="50"><font color="white"><span>_@^ </span></font></marquee>
<marquee direction="left" scrollamount="6" scrolldelay="200"><font color="white"><span>^@_ </span></font></marquee>
<marquee direction="left" scrollamount="10" scrolldelay="0"><font color="white"><span>^@_ </span></font></marquee>
<marquee direction="right" scrollamount="7" scrolldelay="200"><font color="white"><span>_@^ </span></font></marquee>

<!-- 추가된 6마리의 달팽이 -->
<marquee direction="right" scrollamount="3" scrolldelay="100"><font color="white"><span>_@^ </span></font></marquee>
<marquee direction="left" scrollamount="5" scrolldelay="150"><font color="white"><span>^@_ </span></font></marquee>
<marquee direction="left" scrollamount="6" scrolldelay="250"><font color="white"><span>^@_ </span></font></marquee>
<marquee direction="right" scrollamount="7" scrolldelay="300"><font color="white"><span>_@^ </span></font></marquee>
<marquee direction="left" scrollamount="4" scrolldelay="200"><font color="white"><span>^@_</span></font></marquee>
<hr>


</div>








  </div>
    <div class="startScreen">
  

  <button class="startBtn" onclick="removeStartPage();" title="게임 시작"> <span>START</span></button>
  <button class="loadBtn" onclick="loadMap();" title="맵 로드"> <span>load map</span></button>
  <button class="startText">information</button>
<a href="https://webcraft.tistory.com/1" class="startText2" target="_blank">game Blog</a>
  <a href="javascript:void(0);" class="startText3" onclick="apiForm();">api/Server</a> <!-- 클릭 이벤트로 변경 -->

  <div class="apiFormBox">
    <iframe src="api/api.html" title="API Page"></iframe>
    <div class="apiFormClose" onclick="apiFormClose()" title="폼 닫기">X</div>
  </div>
</div>




    <div class="selectedBlockDisplay"title="선택된 블럭을 보여줍니다.">0</div>
    <div class="saveDisplay"title="게임을 저장합니다."onclick="saveMap();">SAVE</div>
    <div class="saveDisplay2"title="장비창""></div>

    <div class="saveDisplay3"title="무기창""></div>
    <div class="saveDisplay4"title="도구창""></div>

    <div class="bossBar"title="Boss"></div>


    <div class="goHome" onclick="goHomeScreen();"title="스폰 포인트로 이동합니다.">Spawn</div>
    <div class="fullScreen" onclick="fullScreen();"title="전체화면으로 변경합니다.">Full</div>
    <div class="musicSoundControl" onclick="soundVolControl();"title="소리를 조정합니다">Sound</div>
    <div class="naverFormBtn" onclick="naverForm();"title="네이버폼 작성">form</div>
    <div class="naverFormBox"> 
         <iframe src="https://naver.me/G0DgMdSW"></iframe> 
          <div class="naverFormClose" onclick="naverFormClose()"title="폼 닫기">X</div>
            </div>





            <div class="craftDisplay" onclick="showCraftingTable();"title="제작창">

                <button class="b115b" onclick="craftItem(`선인장곡괭이`);"title="선인장 곡괭이"style="width:90px; height:40px;"> <span> 재료   : 선인장5, 나무3</span>
                    <button class="b116b" onclick="craftItem(`철곡괭이`)"title="철 곡괭이"style="width:90px; height:40px;"> <span> 재료   : 철광석10, 나무6</span>
                        <button class="b117b" onclick="craftItem(`다이아곡괭이`)"title="다이아 곡괭이"style="width:90px; height:40px;"> <span>재료   : 다이아몬드7, 나무10</span>
                            <button class="b166b" onclick="craftItem(`랜덤박스`)"title="랜덤박스 오픈"style="width:90px; height:40px;"> <span>재료   : 상자1, 황금상자1</span>
                <button class="b118b" onclick="craftItem(`철검`);"title="철검"style="width:90px; height:40px;"> <span> 재료   : 철광석5, 나무2</span>
                <button class="b119b" onclick="craftItem(`철활`)"title="철활"style="width:90px; height:40px;"> <span> 재료   : 철광석2, 나무5, 거미줄1</span>
                <button class="b120b" onclick="craftItem(`화살`)"title="화살"style="width:90px; height:40px;"> <span> 재료   : 조약돌1, 나무1</span>
                <button class="b121b" onclick="craftItem(`포션`)"title="포션3"style="width:90px; height:40px;"> <span> 재료   : 구름1</span>
                              


                    <button class="b127b" onclick="craftItem(`나무갑옷`);"title="나무갑옷"style="width:90px; height:40px;"> <span> 재료   : 나무15</span>
                <button class="b128b" onclick="craftItem(`선인장갑옷`)"title="선인장갑옷"style="width:90px; height:40px;"> <span> 재료   : 선인장10</span>
                <button class="b129b" onclick="craftItem(`벌갑옷`)"title="벌갑옷"style="width:90px; height:40px;"> <span>재료   : 벌통5,꿀블럭5</span>
                <button class="b130b" onclick="craftItem(`흑요석갑옷`)"title="흑요석갑옷"style="width:90px; height:40px;"> <span>재료   :흑요석7,화강암7</span>
                                <button class="b131b" onclick="craftItem(`네크로갑옷`)"title="네크로갑옷"style="width:90px; height:40px;"> <span>재료   :거미줄10,철광석15</span>
                          
                            <button class="b167b" onclick="craftItem(`슬라임킹`)"title="슬라임킹"style="width:60px; height:60px;"> <span>재료 : 스타트패키지1</span>
                <div class="craftDisplayClose" onclick="closeCraftingTable();"title="제작창닫기">X</div>

            </div>
    <div class="zoomControl">
        <button class="zoomUp" onclick="zoom('up')">▲</button>
        <button class="zoomDown" onclick="zoom('down')">▼</button>
        <button class="zoomLeft" onclick="zoom('left')">◀</button>
        <button class="zoomRight" onclick="zoom('right')">▶</button>
    </div>
          <div class="attackControl"onclick="attackActiveBtn();"></div>

     <div class="mainBoxTop"title="블럭 부수기 남은 시간을 보여줍니다."></div>
     <div class="dayTimeBox"title="현재 플레이 타임을 보여줍니다."></div>
       <div class="hpBox"title="체력 수치 : 기본체력100"></div>
         <div class="armorBox"title="갑옷 수치 : 기본방어력1"></div>

         
         <div id="chat-box">
            <div id="chat-log"></div>
            <input type="text" id="chat-input" placeholder="input message">
            <button id="send-btn"onclick="sendChat(false,'none','user')"title="메시지 보내기">Send</button>
            <button id="chat-size-btn"onclick="chatReSize();"title="사이즈 조절">Resize</button>
            <button id="chat-open-btn" onclick="chatOpen();"title="창 열기/닫기">close</button>
            <button id="chat-sign-title" onclick="signInput1(false,'none','sign')"title="표지판 제목 작성">Title</button>
            <button id="chat-sign-content" onclick="signInput2(false,'none','sign')"title="표지판 내용 작성">Content</button>
        </div>


        <div id="flashScreen" style="display:none"></div>

        <div class="itemBag">
            <table border='1' class="itemPad">
                <tr>
                    <td class="itemPadIn b1b" id="i00" onclick="useBlock('i00','b1b',1)" data-stiffness="5" title="잔디">0</td>
                    <td class="itemPadIn b2b" id="i01" onclick="useBlock('i01','b2b',2)" data-stiffness="7" title="흙">0</td>
                    <td class="itemPadIn b3b" id="i02" onclick="useBlock('i02','b3b',3)" data-stiffness="15" title="진흙">0</td>
                    <td class="itemPadIn b4b" id="i03" onclick="useBlock('i03','b4b',4)" data-stiffness="10" title="나무">0</td>
                    <td class="itemPadIn b48b" id="i04" onclick="useBlock('i04','b48b',48)" data-stiffness="1" title="나뭇잎">0</td>
                    <td class="itemPadIn b61b" id="i05" onclick="useBlock('i05','b61b',61)" data-stiffness="50" title="던전가시">0</td>
                    <td class="itemPadIn b10b" id="i06" onclick="useBlock('i06','b10b',10)" data-stiffness="20" title="조약돌">0</td>
                    <td class="itemPadIn b11b" id="i07" onclick="useBlock('i07','b11b',11)" data-stiffness="0" title="철광석">0</td>
                    <td class="itemPadIn b12b" id="i08" onclick="useBlock('i08','b12b',12)" data-stiffness="500" title="루비">0</td>
                    <td class="itemPadIn b63b" id="i09" onclick="useBlock('i09','b63b',63)" data-stiffness="500" title="표지판">0</td>
                    <td class="itemPadIn b49b" id="i090" onclick="useBlock('i090','b49b',49)" data-stiffness="50" title="제작나무">0</td>
                    <td class="itemPadIn b114b" id="i091" onclick="useBlock('i091','b114b',114)" data-stiffness="5" title="연기">0</td>
                    <td class="itemPadIn b64b" id="i092" onclick="useBlock('i092','b64b',64)" data-stiffness="10" title="상호작용">999</td>
        
                </tr>
                <tr>
                    <td class="itemPadIn b13b" id="i10" onclick="useBlock('i10','b13b',13)" data-stiffness="300" title="에메랄드">0</td>
                    <td class="itemPadIn b14b" id="i11" onclick="useBlock('i11','b14b',14)" data-stiffness="1000" title="다이아">0</td>
                    <td class="itemPadIn b46b" id="i12" onclick="useBlock('i12','b46b',46)" data-stiffness="9999" title="우주하늘">0</td>
                    <td class="itemPadIn b54b" id="i13" onclick="useBlock('i13','b54b',54)" data-stiffness="100" title="신비한블럭">0</td>
                    <td class="itemPadIn b52b" id="i14" onclick="useBlock('i14','b52b',52)" data-stiffness="400" title="흑요석">0</td>
                    <td class="itemPadIn b62b" id="i15" onclick="useBlock('i15','b62b',62)" data-stiffness="10" title="횃불">100</td>
                    <td class="itemPadIn b50b" id="i16" onclick="useBlock('i16','b50b',50)" data-stiffness="75" title="벌통">0</td>
                    <td class="itemPadIn b51b" id="i17" onclick="useBlock('i17','b51b',51)" data-stiffness="30" title="꿀블럭">0</td>
                    <td class="itemPadIn b113b" id="i18" onclick="useBlock('i18','b113b',113)" data-stiffness="5" title="밧줄(사다리)">150</td>
                    <td class="itemPadIn b65b" id="i19" onclick="useBlock('i19','b65b',65)" data-stiffness="500" title="TNT">0</td>
                    <td class="itemPadIn b66b" id="i190" onclick="useBlock('i190','b66b',66)" data-stiffness="10" title="쥬크박스">0</td>

                    <td class="itemPadIn b57b" id="i191" onclick="useBlock('i191','b57b',57)" data-stiffness="50" title="던전블록1">0</td>
                    <td class="itemPadIn b53b" id="i192" onclick="useBlock('i192','b53b',53)" data-stiffness="60" title="화강암">0</td>
                

                </tr>
                <tr>
                    <td class="itemPadIn b73b" id="i20" onclick="useBlock('i20','b73b',73)" data-stiffness="10" title="TNT_VER2">0</td>
                    <td class="itemPadIn b7b" id="i21" onclick="useBlock('i21','b7b',7)" data-stiffness="2" title="구름">0</td>
                    <td class="itemPadIn b8b" id="i22" onclick="useBlock('i22','b8b',8)" data-stiffness="2" title="먹구름">0</td>

                    <td class="itemPadIn b79b" id="i23" onclick="useBlock('i23','b79b',79)" data-stiffness="3" title="트리">0</td>

                    <td class="itemPadIn b76b" id="i24" onclick="useBlock('i24','b76b',76)" data-stiffness="2" title="닫힌문상단">0</td>
                    <td class="itemPadIn b77b" id="i25" onclick="useBlock('i25','b77b',77)" data-stiffness="2" title="닫힌문하단">0</td>
                    <td class="itemPadIn b80b" id="i26" onclick="useBlock('i26','b80b',80)" data-stiffness="5" title="재블럭">0</td>
                    <td class="itemPadIn b81b" id="i27" onclick="useBlock('i27','b81b',81)" data-stiffness="25" title="지옥석">0</td>
                    <td class="itemPadIn b82b" id="i28" onclick="useBlock('i28','b82b',82)" data-stiffness="25" title="단단한지옥석">0</td>
                    <td class="itemPadIn b83b" id="i29" onclick="useBlock('i29','b83b',83)" data-stiffness="5" title="불타는화염">0</td>
                    <td class="itemPadIn b84b" id="i290" onclick="useBlock('i290','b84b',84)" data-stiffness="5" title="핏빛돌">0</td>
                    <td class="itemPadIn b149b" id="i291" onclick="useBlock('i291','b149b',149)" data-stiffness="5" title="액자(변경)">0</td>
                    <td class="itemPadIn b100b" id="i292" onclick="useBlock('i292','b100b',100)" data-stiffness="5" title="거미줄">0</td>

         
        
                </tr>
                <tr>
                    <td class="itemPadIn b85b" id="i30" onclick="useBlock('i30','b85b',85)" data-stiffness="5" title="무지개블럭">0</td>
                    <td class="itemPadIn b67b" id="i31" onclick="useBlock('i31','b67b',67)" data-stiffness="10" title="상자">0</td>
                    <td class="itemPadIn b68b" id="i32" onclick="useBlock('i32','b68b',68)" data-stiffness="20" title="정글상자">0</td>
                    <td class="itemPadIn b69b" id="i33" onclick="useBlock('i33','b69b',69)" data-stiffness="30" title="황금상자">0</td>
                    <td class="itemPadIn b70b" id="i34" onclick="useBlock('i34','b70b',70)" data-stiffness="40" title="스타트패키지">0</td>
                    <td class="itemPadIn b72b" id="i35" onclick="useBlock('i35','b72b',72)" data-stiffness="50" title="하늘상자">0</td>
                    <td class="itemPadIn b71b" id="i36" onclick="useBlock('i36','b71b',71)" data-stiffness="60" title="흑요석상자">0</td>
                    <td class="itemPadIn b55b" id="i37" onclick="useBlock('i37','b55b',55)" data-stiffness="50" title="물">0</td>
                    <td class="itemPadIn b86b" id="i38" onclick="useBlock('i38','b86b',86)" data-stiffness="60" title="용암">0</td>
                    <td class="itemPadIn b78b" id="i39" onclick="useBlock('i39','b78b',78)" data-stiffness="1" title="유리">0</td>
                    <td class="itemPadIn b95b" id="i390" onclick="useBlock('i390','b95b',95)" data-stiffness="1" title="폭탄">10</td>
                    <td class="itemPadIn b109b" id="i391" onclick="useBlock('i391','b109b',109)" data-stiffness="5" title="선인장">0</td>
                    <td class="itemPadIn b108b" id="i392" onclick="useBlock('i392','b108b',108)" data-stiffness="5" title="사암">0</td>

        
                </tr>
            
                <tr>
                    <td class="itemPadIn b97b" id="i40" onclick="useBlock('i40','b97b',97)" data-stiffness="5" title="모루">0</td>
                    <td class="itemPadIn b98b" id="i41" onclick="useBlock('i41','b98b',98)" data-stiffness="5" title="화로">0</td>
                    <td class="itemPadIn b99b" id="i42" onclick="useBlock('i42','b99b',99)" data-stiffness="5" title="모닥불">5</td>
                    <td class="itemPadIn b96b" id="i43" onclick="useBlock('i43','b96b',96)" data-stiffness="40" title="조합대">200</td>
                    <td class="itemPadIn b101b" id="i44" onclick="useBlock('i44','b101b',101)" data-stiffness="5" title="얼음">0</td>
                    <td class="itemPadIn b102b" id="i45" onclick="useBlock('i45','b102b',102)" data-stiffness="5" title="단단한얼음">0</td>
                    <td class="itemPadIn b103b" id="i46" onclick="useBlock('i46','b103b',103)" data-stiffness="5" title="눈">0</td>
                    <td class="itemPadIn b104b" id="i47" onclick="useBlock('i47','b104b',104)" data-stiffness="5" title="눈블럭">0</td>
                    <td class="itemPadIn b105b" id="i48" onclick="useBlock('i48','b105b',105)" data-stiffness="5" title="크리스탈블럭">0</td>
                    <td class="itemPadIn b106b" id="i49" onclick="useBlock('i49','b106b',106)" data-stiffness="5" title="모래">0</td>
                    <td class="itemPadIn b107b" id="i490" onclick="useBlock('i490','b107b',107)" data-stiffness="15" title="모래벽돌">0</td>
                    <td class="itemPadIn b110b" id="i491" onclick="useBlock('i491','b110b',110)" data-stiffness="5" title="광산수레">0</td>
                    <td class="itemPadIn b111b" id="i492" onclick="useBlock('i492','b111b',111)" data-stiffness="5" title="철로">0</td>
    
                    <tr>
                        <td class="itemPadIn b112b" id="i54" onclick="useBlock('i54','b112b',112)" data-stiffness="5" title="핵폭탄">0</td>
                        <td class="itemPadIn b115b" id="i590" onclick="useBlock('i590','b115b',115)" data-stiffness="5" title="선인장곡괭이">0</td>
                        <td class="itemPadIn b116b" id="i591" onclick="useBlock('i591','b116b',116)" data-stiffness="5" title="철곡괭이">0</td>
                        <td class="itemPadIn b117b" id="i592" onclick="useBlock('i592','b117b',117)" data-stiffness="5" title="다이아곡괭이">0</td>
                        <td class="itemPadIn b118b" id="i593" onclick="useBlock('i593','b118b',118)" data-stiffness="5" title="철검">0</td>
                        <td class="itemPadIn b119b" id="i594" onclick="useBlock('i594','b119b',119)" data-stiffness="5" title="철활">0</td>
                        <td class="itemPadIn b120b" id="i595" onclick="useBlock('i595','b120b',120)" data-stiffness="5" title="화살">0</td>
                        <td class="itemPadIn b121b" id="i596" onclick="useBlock('i596','b121b',121)" data-stiffness="50" title="포션">5</td>
                        <td class="itemPadIn b122b" id="i597" onclick="useBlock('i597','b122b',122)" data-stiffness="5" title="동트로피">0</td>
                        <td class="itemPadIn b123b" id="i598" onclick="useBlock('i598','b123b',123)" data-stiffness="5" title="은트로피">0</td>
                        <td class="itemPadIn b124b" id="i599" onclick="useBlock('i599','b124b',124)" data-stiffness="5" title="금트로피">0</td>
                        <td class="itemPadIn b125b" id="i60" onclick="useBlock('i60','b125b',125)" data-stiffness="1" title="플랫폼">200</td>
                        <td class="itemPadIn b126b" id="i61" onclick="useBlock('i61','b126b',126)" data-stiffness="1" title="고대의상자">0</td>

                    </tr>


                </tr>
            </table> 
        </div>
        
  

        <div class="itemBagBtn"onclick="itemBagResize()"title="인벤토리 최소/최대화">on</div>
        <div class="itemBagBtn2"onclick="itemBagResize2()"title="인벤토리 세로정렬">on</div>

   
        <div class="signBoxMain"title="표지판 외곽">
            <div class="signBox"title="표지판 내용"></div>
            <div class="signBoxClose"onclick="signBoxClose();"title="표지판 닫기">X</div>
        </div>

 
        <div id="zoomRoot">
    <div class="mainBox">

        <table border='1'class='tableBox'>
        </table>
   </div>
  

    <div class="mainBox2"></div>
    <div class="mainBox3"></div>
    <div class="mainBox4"></div>

</div> 













</body>



  <!-- FontFaceObserver 라이브러리 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fontfaceobserver/2.1.0/fontfaceobserver.standalone.js"></script>
  <script>
    let removeStartBeforePageVar=false;

 let randomMusic=null;
 let musicTitle;

    let BackFullScreenFirst=true;

    const dungFont = new FontFaceObserver('DungGeunMo');

    dungFont.load().then(() => {
      console.log('DungGeunMo 폰트 로드 완료');
    }).catch(() => {
      console.warn('DungGeunMo 폰트 로드 실패');
      // 폰트가 실패해도 보여주긴 해야 함
    });


    function isMobileDevice() {
    // 대표적인 모바일 User-Agent 체크
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// 현재 접속 환경의 userAgent 정보
const userAgent = navigator.userAgent; // [5][8]



// Dancer 1
const dancer1 = document.getElementById("ascii-dancer");
const frames1 = [
  "(＾▽＾)", "(≧◡≦)", "(｡♥‿♥｡)", "(•̀ᴗ•́)و", "(´｡• ω •｡)", "(o^▽^o)",
  "(⊃｡•́‿•̀｡)⊃", "(｡•̀ᴗ-)✧", "(╯✧▽✧)╯", "( ´ ▽ ` )"
];

let idx1 = 0, shiftX1 = 0, shiftY1 = 0, dirX1 = 3, dirY1 = 1;

setInterval(() => {
  dancer1.textContent = frames1[idx1];
  idx1 = (idx1 + 1) % frames1.length;

  shiftX1 += dirX1;
  if (shiftX1 > 10 || shiftX1 < -10) dirX1 *= -1;

  const jump = Math.floor(Math.random() * 3) + 1;
  shiftY1 = dirY1 > 0 ? -5 * jump : 0;
  dirY1 *= -1;

  dancer1.style.transform = `translate(${shiftX1}px, ${shiftY1}px)`;
}, 350);
// Dancer 2 - 격한 점프
const dancer2 = document.getElementById("ascii-dancer2");
const frames2 = [
  "(✿◕‿◕)", "(｡•́‿•̀｡)", "(・∀・)", "(づ｡◕‿‿◕｡)づ", "(^_^)", "(^ω^)"
];

let idx2 = 0, shiftX2 = 0, shiftY2 = 0, dirX2 = 2, dirY2 = 1;

setInterval(() => {
  dancer2.textContent = frames2[idx2];
  idx2 = (idx2 + 1) % frames2.length;

  shiftX2 += dirX2;
  if (shiftX2 > 10 || shiftX2 < -10) dirX2 *= -1;

  const jump = Math.floor(Math.random() * 3) + 1;
  shiftY2 = dirY2 > 0 ? -15 * jump : 0; // 격한 점프 (기존 -5 → -15)
  dirY2 *= -1;

  dancer2.style.transform = `translate(${shiftX2}px, ${shiftY2}px)`;
}, 300); // 약간 빠르게


// Dancer 3 - 격한 점프
const dancer3 = document.getElementById("ascii-dancer3");
const frames3 = [
  "(^з^)-☆", "(≧ω≦)", "(^ワ^＝)", "(ノ^_^)ノ", "(^-^*)", "(●’◡’●)"
];

let idx3 = 0, shiftX3 = 0, shiftY3 = 0, dirX3 = 4, dirY3 = 1;

setInterval(() => {
  dancer3.textContent = frames3[idx3];
  idx3 = (idx3 + 1) % frames3.length;

  shiftX3 += dirX3;
  if (shiftX3 > 10 || shiftX3 < -10) dirX3 *= -1;

  const jump = Math.floor(Math.random() * 4) + 2;
  shiftY3 = dirY3 > 0 ? -12 * jump : 0; // 좀 더 격한 점프
  dirY3 *= -1;

  dancer3.style.transform = `translate(${shiftX3}px, ${shiftY3}px)`;
}, 280); // 더 빠른 반응성


const wrapper = document.getElementById("ascii-dancer-wrapper");
const wrapper2 = document.getElementById("ascii-dancer-wrapper2");
const wrapper3 = document.getElementById("ascii-dancer-wrapper3");
 const talk = document.getElementById("ascii-talk");

const messages = [
  "Hi there~ (๑˃̵ᴗ˂̵)و ♡",
  "Let's play together~ ヾ(≧▽≦*)o",
  "You're really awesome! ",
  "Hehe~ I'm shy >///<",
  "Let's be friends! "
];

wrapper.addEventListener("click", () => {
  // 확대
  wrapper.classList.add("enlarged");

  // 모든 음악 멈춤
  musicMain1.pause();
  musicMain2.pause();
  musicMain3.pause();
  musicMain4.pause();
  musicMain5.pause();
  musicCute.play();

  // 대사 배열
  const messages = [
    "Hi there~ (๑˃̵ᴗ˂̵)و ",
    "Let's play together~",
    "You're really awesome! ",
    "Hehe~ I'm shy >///<",
    "Let's be friends! "
  ];

  // 친구들 보이기
  wrapper2.style.display = "inline-block";
  wrapper3.style.display = "inline-block";

  // 대사 순차 출력
  let msgIndex = 0;
  const msgInterval = setInterval(() => {
    talk.textContent = messages[msgIndex];
    msgIndex++;

    if (msgIndex >= messages.length) {
      clearInterval(msgInterval);
    }
  }, 2000);

  // 3초 후 확대 해제
  setTimeout(() => {
    wrapper.classList.remove("enlarged");
  }, 10000);

  // 10초 후 친구 숨기고 상태 복원
  setTimeout(() => {
    wrapper2.style.display = "none";
    wrapper3.style.display = "none";
    talk.textContent = "touch me!";
    musicCute.pause();

    
    const rand = Math.random();
    if(removeStartBeforePageVar==false){
    if (rand < 0.2) {
      randomMusic = musicMain1;
    } else if (rand < 0.4) {
      randomMusic = musicMain2;
    } else if (rand < 0.6) {
      randomMusic = musicMain3;
    } else if (rand < 0.8) {
      randomMusic = musicMain4;
    } else {
      randomMusic = musicMain5;
    }
    randomMusic.play();
    }
  }, 10000);

});



    const musicMain1 = new Audio("sound/mainMusic1.mp3");
    musicMain1.loop = true;
    musicMain1.playbackRate = 1.0;

    const musicMain2 = new Audio("sound/mainMusic2.mp3");
    musicMain2.loop = true;
    musicMain2.playbackRate = 1.0;

    const musicMain3 = new Audio("sound/mainMusic3.mp3");
    musicMain3.loop = true;
    musicMain3.playbackRate = 1.0;

    const musicMain4 = new Audio("sound/mainMusic4.mp3");
    musicMain4.loop = true;
    musicMain4.playbackRate = 1.0;


    const musicMain5 = new Audio("sound/mainMusic5.mp3");
    musicMain5.loop = true;
    musicMain5.playbackRate = 1.0;

    document.addEventListener('DOMContentLoaded', function() {


   
    // 랜덤으로 세 음악 중 하나를 선택하여 자동 재생
///////////////////////

//const proxyUrl = 'https://api.allorigins.win/get?disableCache=true&url=' + encodeURIComponent(rssUrl);

/////////////////////
       // RSS 피드 URL
const rssUrl = 'https://webcraft.tistory.com/rss';
const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(rssUrl);

fetch(proxyUrl)
  .then(response => response.text())
  .then(xmlString => {
    const parser = new DOMParser();
    const xml = parser.parseFromString(xmlString, "application/xml");

    const firstItem = xml.querySelector("item");
    const title = firstItem?.querySelector("title")?.textContent || "제목 없음";
    const link = firstItem?.querySelector("link")?.textContent || "#";
    let descriptionRaw = firstItem?.querySelector("description")?.textContent || "";

    // 이미지들 모두 추출
    const imgMatches = [...descriptionRaw.matchAll(/<img[^>]+src="([^">]+)"/gi)];
    const imgTags = imgMatches
      .slice(0, 12) // 최대 6장만
      .map(match => {
        let src = match[1];
        if (src.startsWith("//")) src = "https:" + src;
        return `<img src="${src}" style="width:200px; height:auto; margin:2px; border-radius:4px;">`;
      })
      .join("");

    // 텍스트 설명 정리
    let description = descriptionRaw.replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();
    if (description.length > 100) {
      description = description.slice(0, 100) + '...';
    }

    const container = document.getElementById("hrefLinkBlogData");
    container.innerHTML = `
      <a href="${link}" target="_blank" style="text-decoration:none; display:block;">
        <strong>${title}</strong><br>
        <small>${description}</small><br>
        <div style="margin-top:6px;">${imgTags}</div>
      </a>
    `;
  })
  .catch(error => {
    console.error("RSS 불러오기 실패:", error);
    const container = document.getElementById("hrefLinkBlogData");
    container.innerHTML = `<a href="#" target="_blank">Failed to load latest post.</a>`;
  });





  // 3D 배경 이미지 변경 함수 (5초마다)
  function change3DImage() {
    const randomNumber = Math.floor(Math.random() * 31) + 1; // 1~31
    const miniBg = document.getElementById("startScreenMiniBackground");
    if (miniBg) {
      miniBg.style.backgroundImage = `url("img/3d${randomNumber}.gif")`;
    }
  }

  // 메인 배경 이미지 변경 함수 (15초마다)
  function changeMainBackground() {
    const randomNum = Math.floor(Math.random() * 8) + 1; // 1~8
    const backgroundUrl = `titleImg/s${randomNum}.gif`;
    const startScreen = document.querySelector('.startScreen');

    if (startScreen) {
      startScreen.style.background = `url('${backgroundUrl}') no-repeat center center`;
      startScreen.style.backgroundSize = 'cover';
    }
  }

  // 5초마다 3D 이미지 변경
  setInterval(change3DImage, 5000);

  // 15초마다 메인 배경 이미지 변경
  setInterval(changeMainBackground, 15000);

  // 처음 로딩 시 배경 이미지 설정
  change3DImage();
  changeMainBackground();
});


// ▼▼▼ 전역 변수 선언 ▼▼▼
let loadedMapData = {
    blocks: [], // {x: number, y: number, bid: string} 형태 저장
    signs: [],
    gameMode : [],
    metadata: null
};
let loadedGame=false;

//스크룰 스크롤 차단 
const preventScroll = (e) => {
  e.preventDefault();
  e.stopPropagation();
  return false;
};

window.addEventListener('wheel', preventScroll, { passive: false });
window.addEventListener('mousewheel', preventScroll, { passive: false });
window.addEventListener('DOMMouseScroll', preventScroll, { passive: false });



//var power =prompt("곡괭이 파워 입력 1~50");
var power =0.33;//곡괭이 힘 (블럭 캐지는 속도)
var globalInputElement=null;
var globalBlockId;
var globalBlockPower;
var globalBlockOpacity;
var defaultOpacity=0;
var timeUpStart=false;
var shadowCounterVal=150;
     var ranSky=parseInt((Math.random()*6)+10);

// 동굴 1 (가장 큰 동굴)
var ranCave1X = parseInt(Math.random() * 250); // 0~199 (x축 유지)
var ranCave1Y = parseInt(Math.random() * 40) + 55; // 55~94 (기존 35~74 → +20)
var ranCave1XC = parseInt(Math.random() * 150) + 50; // 50~199 (너비 150~200 유지)
var ranCave1YC = parseInt(Math.random() * 60) + 20; // 20~79 (높이 60~80 유지)

// 동굴 2 (중형 동굴)
var ranCave2X = parseInt(Math.random() * 250); // 0~199 
var ranCave2Y = parseInt(Math.random() * 40) + 55; // 55~94
var ranCave2XC = parseInt(Math.random() * 100) + 80; // 80~179 (너비 80~180 유지)
var ranCave2YC = parseInt(Math.random() * 50) + 30; // 30~79 (높이 50~80 유지)

// 동굴 3 (소형 동굴)
var ranCave3X = parseInt(Math.random() * 250); // 0~199
var ranCave3Y = parseInt(Math.random() * 40) + 55; // 55~94
var ranCave3XC = parseInt(Math.random() * 80) + 60; // 60~139 (너비 60~140 유지)
var ranCave3YC = parseInt(Math.random() * 40) + 40; // 40~79 (높이 40~80 유지)


// 물 웅덩이 - 작은
var waterSmallX = parseInt(Math.random() * 250);
var waterSmallY = parseInt(Math.random() * 20) + 55;
var waterSmallWidth = parseInt(Math.random() * 7) + 6;    // 6~12
var waterSmallHeight = parseInt(Math.random() * 6) + 5;   // 5~10

// 물 웅덩이 - 중간
var waterMediumX = parseInt(Math.random() * 250);
var waterMediumY = parseInt(Math.random() * 20) + 60;
var waterMediumWidth = parseInt(Math.random() * 10) + 9;  // 9~18
var waterMediumHeight = parseInt(Math.random() * 7) + 6;  // 6~12

// 물 웅덩이 - 큰
var waterLargeX = parseInt(Math.random() * 250);
var waterLargeY = parseInt(Math.random() * 20) + 65;
var waterLargeWidth = parseInt(Math.random() * 13) + 11;  // 11~23
var waterLargeHeight = parseInt(Math.random() * 9) + 7;   // 7~15

// 용암 웅덩이 - 작은
var lavaSmallX = parseInt(Math.random() * 250);
var lavaSmallY = parseInt(Math.random() * 15) + 80;
var lavaSmallWidth = parseInt(Math.random() * 6) + 5;     // 5~10
var lavaSmallHeight = parseInt(Math.random() * 4) + 4;    // 4~7

// 용암 웅덩이 - 중간
var lavaMediumX = parseInt(Math.random() * 250);
var lavaMediumY = parseInt(Math.random() * 15) + 85;
var lavaMediumWidth = parseInt(Math.random() * 9) + 7;    // 7~15
var lavaMediumHeight = parseInt(Math.random() * 6) + 5;   // 5~10

// 용암 웅덩이 - 큰
var lavaLargeX = parseInt(Math.random() * 250);
var lavaLargeY = parseInt(Math.random() * 20) + 90;
var lavaLargeWidth = parseInt(Math.random() * 12) + 9;    // 9~21
var lavaLargeHeight = parseInt(Math.random() * 7) + 6;    // 6~12



// 작은 뭉치
var oreIronSmallX = parseInt(Math.random() * 250);
var oreIronSmallY = parseInt(Math.random() * 15) + 60; // 얕은 지하
var oreIronSmallW = parseInt(Math.random() * 4) + 4;   // 4~7
var oreIronSmallH = parseInt(Math.random() * 3) + 3;   // 3~5

// 중간 뭉치
var oreIronMedX = parseInt(Math.random() * 250);
var oreIronMedY = parseInt(Math.random() * 15) + 65;
var oreIronMedW = parseInt(Math.random() * 6) + 5;      // 5~10
var oreIronMedH = parseInt(Math.random() * 4) + 4;      // 4~7

// 큰 뭉치
var oreIronLargeX = parseInt(Math.random() * 250);
var oreIronLargeY = parseInt(Math.random() * 15) + 70;
var oreIronLargeW = parseInt(Math.random() * 8) + 7;    // 7~14
var oreIronLargeH = parseInt(Math.random() * 5) + 5;    // 5~9


// 작은
var oreRubySmallX = parseInt(Math.random() * 250);
var oreRubySmallY = parseInt(Math.random() * 15) + 75;
var oreRubySmallW = parseInt(Math.random() * 3) + 3;
var oreRubySmallH = parseInt(Math.random() * 3) + 3;

// 중간
var oreRubyMedX = parseInt(Math.random() * 250);
var oreRubyMedY = parseInt(Math.random() * 15) + 80;
var oreRubyMedW = parseInt(Math.random() * 4) + 4;
var oreRubyMedH = parseInt(Math.random() * 3) + 3;

// 큰
var oreRubyLargeX = parseInt(Math.random() * 250);
var oreRubyLargeY = parseInt(Math.random() * 15) + 85;
var oreRubyLargeW = parseInt(Math.random() * 5) + 5;
var oreRubyLargeH = parseInt(Math.random() * 4) + 4;


// 작은
var oreEmeraldSmallX = parseInt(Math.random() * 250);
var oreEmeraldSmallY = parseInt(Math.random() * 15) + 85;
var oreEmeraldSmallW = parseInt(Math.random() * 2) + 2;
var oreEmeraldSmallH = parseInt(Math.random() * 2) + 2;

// 중간
var oreEmeraldMedX = parseInt(Math.random() * 250);
var oreEmeraldMedY = parseInt(Math.random() * 10) + 90;
var oreEmeraldMedW = parseInt(Math.random() * 3) + 3;
var oreEmeraldMedH = parseInt(Math.random() * 2) + 2;

// 큰
var oreEmeraldLargeX = parseInt(Math.random() * 250);
var oreEmeraldLargeY = parseInt(Math.random() * 10) + 95;
var oreEmeraldLargeW = parseInt(Math.random() * 3) + 4;
var oreEmeraldLargeH = parseInt(Math.random() * 2) + 3;


// 작은
var oreDiamondSmallX = parseInt(Math.random() * 250);
var oreDiamondSmallY = parseInt(Math.random() * 10) + 95;
var oreDiamondSmallW = parseInt(Math.random() * 1) + 2;  // 2~2
var oreDiamondSmallH = parseInt(Math.random() * 1) + 2;

// 중간
var oreDiamondMedX = parseInt(Math.random() * 250);
var oreDiamondMedY = parseInt(Math.random() * 10) + 100;
var oreDiamondMedW = parseInt(Math.random() * 2) + 2;  // 2~3
var oreDiamondMedH = parseInt(Math.random() * 2) + 2;

// 큰
var oreDiamondLargeX = parseInt(Math.random() * 250);
var oreDiamondLargeY = parseInt(Math.random() * 10) + 105;
var oreDiamondLargeW = parseInt(Math.random() * 2) + 3;  // 3~4
var oreDiamondLargeH = parseInt(Math.random() * 2) + 2;




// 5~20개 사이 랜덤하게 자연동굴 생성 파라미터 설정
var emptyCaves = [];
var caveCount = Math.floor(Math.random() * 13) + 13; // 5~20개 사이 랜덤하게 생성

for(var i=0; i<caveCount; i++) {
    emptyCaves.push({
        x: Math.floor(Math.random() * 400),  // X 시작 위치 (0~300)
        y: Math.floor(Math.random() * (160-60-20)) + 60, // Y 시작 위치 (60~130)
        width: Math.floor(Math.random() * 50) + 1,  // 가로 크기 (20~70)
        height: Math.floor(Math.random() * 45) + 1, // 세로 크기 (10~50)
        torchChance: 0.05, // 횃불 생성 확률 5%
        chestChance: 0.018, // 상자 생성 확률 2%
        goldenChestChance: 0.009, // 황금상자 생성 확률 1%
        distortion: 0.5 + Math.random() * 0.5, // 왜곡 강도 (0.5~1.0)
        noiseScale: 0.1 + Math.random() * 0.2 // 노이즈 스케일 (0.1~0.3)
    });
}

// 언더월드 동굴 생성 개선
var emptyCaves2 = [];
var caveCount2 = Math.floor(Math.random() * 20) + 30; // 30-50개의 동굴

for(var i=0; i<caveCount2; i++) {
    // 동굴 크기 다양화
    var caveType = Math.random();
    var caveWidth, caveHeight, caveDistortion, caveNoiseScale;
    
    if(caveType < 0.2) { // 20% 확률로 매우 큰 동굴 (언더월드 특징적 큰 공간)
        caveWidth = Math.floor(Math.random() * 35) + 25; // 60-140 범위
        caveHeight = Math.floor(Math.random() * 15) + 15; // 25-55 범위
        caveDistortion = 0.3 + Math.random() * 0.2; // 적은 왜곡으로 더 넓은 공간
        caveNoiseScale = 0.02 + Math.random() * 0.05; // 매끄러운 동굴
    } 
    else if(caveType < 0.5) { // 30% 확률로 중간 크기 동굴
        caveWidth = Math.floor(Math.random() * 30) + 10; // 30-80 범위
        caveHeight = Math.floor(Math.random() * 10) + 5; // 15-35 범위
        caveDistortion = 0.4 + Math.random() * 0.3; // 중간 정도의 왜곡
        caveNoiseScale = 0.05 + Math.random() * 0.1; // 중간 노이즈
    }
    else { // 50% 확률로 작은 동굴과 통로
        caveWidth = Math.floor(Math.random() * 15) + 5; // 10-40 범위
        caveHeight = Math.floor(Math.random() * 8) + 1; // 5-20 범위
        caveDistortion = 0.5 + Math.random() * 0.4; // 높은 왜곡으로 불규칙한 형태
        caveNoiseScale = 0.1 + Math.random() * 0.15; // 거친 노이즈
    }
    
    // y 위치 - 지옥 전 영역에 분포하되 상부와 중부에 더 집중
    var caveY;
    if(Math.random() < 0.7) { // 70% 확률로 상-중부에 집중
        caveY = Math.floor(Math.random() * 25) + 150; // 150-175 범위
    } else { // 30% 확률로 하부에 배치
        caveY = Math.floor(Math.random() * 25) + 175; // 175-200 범위
    }
    
    // x 위치 - 특정 구역에 동굴이 더 많이 모이도록 하기
    var caveX;
    if(Math.random() < 0.4) { // 40% 확률로 특정 구역에 집중
        caveX = Math.floor(Math.random() * 100) + 100; // 100-200 범위에 집중
    } else { // 60% 확률로 전체 영역에 분산
        caveX = Math.floor(Math.random() * 400);
    }
    
    emptyCaves2.push({
        x: caveX,
        y: caveY,
        width: caveWidth,
        height: caveHeight,
        torchChance: caveType < 0.2 ? 0.25 : (caveType < 0.5 ? 0.15 : 0.05), // 크기에 따라 횃불 확률 조정
        darkChestChance: caveType < 0.2 ? 0.04 : (caveType < 0.5 ? 0.02 : 0.005), // 크기에 따라 상자 확률 조정
        distortion: caveDistortion,
        noiseScale: caveNoiseScale
    });
}


var oceanRan=parseInt((Math.random()*2)+1);//1~2

var skyHeightPlus=20;


    var bLoc;
var bData1;
var bData2;
var bLocateData=[];

var bLocateDataCounter=0;

var timer;
var timer2;
var timer3;
    let lastTimeUpTime = 0;
        let lastDayTimeUpTime = 0;

var time=0;
var dayTime=0;
var dayTimeMin=0;
var dayTimeHour=parseInt(Math.random()*24);
var usedBlockPosition=0;
 var dayMusicType=parseInt((Math.random()*2)+1);
var userName=((Math.random()*999)+1);


const musicA = new Audio("music/overworld_day.mp3"); // 기본 초원 배경음
musicA.loop = true;
musicA.playbackRate = 1.0;

const musicA2 = new Audio("music/overworld_day2.mp3"); // 기본 초원 배경음
musicA2.loop = true;
musicA2.playbackRate = 1.0;

const musicB = new Audio("music/overworld_night.mp3"); // 기본 초원 배경음
musicB.loop = true;
musicB.playbackRate = 1.0;

const musicB2 = new Audio("music/underground_1.mp3"); // 지하1
musicB2.loop = true;
musicB2.playbackRate = 1.0;

const musicB3 = new Audio("music/underground_2.mp3"); // 지하2
musicB3.loop = true;
musicB3.playbackRate = 1.0;

const musicB4 = new Audio("music/space_1.mp3"); // 우주
musicB4.loop = true;
musicB4.playbackRate = 1.0;

const musicB5 = new Audio("music/underworld_1.mp3"); // 언더월드1
musicB5.loop = true;
musicB5.playbackRate = 1.0;

const musicB6 = new Audio("music/underworld_1.mp3"); // 언더월드2 (파일명이 같으니 확인 필요)
musicB6.loop = true;
musicB6.playbackRate = 1.0;

const musicB7 = new Audio("music/screen_ost.mp3"); // 메인화면
musicB7.loop = true;
musicB7.playbackRate = 1.0;

 const musicDe_surface = new Audio("music/desert_surface.mp3");
musicDe_surface.loop = true;
musicDe_surface.playbackRate = 1.0;

const musicDe_underground = new Audio("music/desert_underground.mp3");
musicDe_underground.loop = true;
musicDe_underground.playbackRate = 1.0;

// Jungle
const musicJu_day = new Audio("music/jungle_day.mp3");
musicJu_day.loop = true;
musicJu_day.playbackRate = 1.0;

const musicJu_night = new Audio("music/jungle_night.mp3");
musicJu_night.loop = true;
musicJu_night.playbackRate = 1.0;

const musicJu_underground = new Audio("music/jungle_underground.mp3");
musicJu_underground.loop = true;
musicJu_underground.playbackRate = 1.0;

// Ocean
const musicOc_day = new Audio("music/ocean_day.mp3");
musicOc_day.loop = true;
musicOc_day.playbackRate = 1.0;

const musicOc_night = new Audio("music/ocean_night.mp3");
musicOc_night.loop = true;
musicOc_night.playbackRate = 1.0;

// Ice
const musicIc_surface = new Audio("music/ice_surface.mp3");
musicIc_surface.loop = true;
musicIc_surface.playbackRate = 1.0;

const musicIc_underground = new Audio("music/ice_underground.mp3");
musicIc_underground.loop = true;
musicIc_underground.playbackRate = 1.0;

// Space (예시, 파일명에 맞게 수정)
const musicSp_day = new Audio("music/space_day.mp3");
musicSp_day.loop = true;
musicSp_day.playbackRate = 1.0;

// Space (예시, 파일명에 맞게 수정)
const musicSlime_king = new Audio("music/SlimeKing.mp3");
musicSlime_king.loop = true;
musicSlime_king.playbackRate = 1.0;

// Space (예시, 파일명에 맞게 수정)
const musicSlime_king2 = new Audio("music/SlimeKing2.mp3");
musicSlime_king2.loop = true;
musicSlime_king2.playbackRate = 1.0;





const beforeBoss = new Audio("music/beforeBoss.mp3");
beforeBoss.loop = true;
beforeBoss.playbackRate = 1.0;
// bossBefore (예시, 파일명에 맞게 수정)
const musicCute = new Audio("music/cute.mp3");
musicCute.loop = true;
musicCute.playbackRate = 1.0;


 //타운나이트 https://www.youtube.com/watch?v=ehMCqtBBUXU&list=PLbJE2f8Bl_gRq7g69Z4xfHV7Je-WWvpdJ&index=17

//윈디 데이 https://www.youtube.com/watch?v=Ecqe_U_IDCo&list=PLbJE2f8Bl_gRq7g69Z4xfHV7Je-WWvpdJ&index=6
//레인 https://www.youtube.com/watch?v=0dmzWlm4_V0&list=PLbJE2f8Bl_gRq7g69Z4xfHV7Je-WWvpdJ&index=7
//폭풍우 https://www.youtube.com/watch?v=2cNbAmSTvT0&list=PLbJE2f8Bl_gRq7g69Z4xfHV7Je-WWvpdJ&index=8
//모닝 레인 https://www.youtube.com/watch?v=CFr5rYfzgaI&list=PLbJE2f8Bl_gRq7g69Z4xfHV7Je-WWvpdJ&index=9

//물https://www.youtube.com/watch?v=fdi06Y6oFDo&list=PLbJE2f8Bl_gRq7g69Z4xfHV7Je-WWvpdJ&index=21
//던전 https://www.youtube.com/watch?v=cxRovfKFoI4&list=PLbJE2f8Bl_gRq7g69Z4xfHV7Je-WWvpdJ&index=32

//https://terraria.wiki.gg/wiki/Category:Biome_backgrounds 바이옴 



    var timeStatus=null;
var dayBgm=parseInt((Math.random()*2)+1);
var undergroundBgm=parseInt((Math.random()*2)+1);
var underworldBgm=parseInt((Math.random()*2)+1);
var firstGoHomeBgm=false;


const typing = new Audio("music/typing.mp3");
typing.loop = true;   // 반복 재생
typing.playbackRate = 1.0;

let isFirstClick = true;
let isFirstMainMusic=true;


function scrollToNote() {
    const button = document.getElementById("updateNote");





if (isFirstMainMusic) {
    const rand = Math.random();
    if (rand < 0.2) {
        randomMusic = musicMain1;
        musicTitle = "musicMain1";
    } else if (rand < 0.4) {
        randomMusic = musicMain2;
        musicTitle = "musicMain2";
    } else if (rand < 0.6) {
        randomMusic = musicMain3;
        musicTitle = "musicMain3";
    } else if (rand < 0.8) {
        randomMusic = musicMain4;
        musicTitle = "musicMain4";
    } else {
        randomMusic = musicMain5;
        musicTitle = "musicMain5";
    }

    // 모든 음악 멈춤
    musicMain1.pause();
    musicMain2.pause();
    musicMain3.pause();
    musicMain4.pause();
    musicMain5.pause();

    randomMusic.play();
    isFirstMainMusic = false;
}

    if (isFirstClick) {
        // 첫 번째 클릭에서 타이핑 소리 재생 시작
        typing.play(); // 메인화면에서 타이핑 소리 시작

        // 텍스트 변경 및 화면 스크롤
        button.innerHTML = `${"goTopScreen"}<br>(${musicTitle})`;
        document.getElementById("developer-note").scrollIntoView({ behavior: "smooth" });
        effectSound("coin");
        // 타이핑 효과 초기화
        const textElement = document.getElementById('typing-text');
        const textContent = textElement.innerHTML;  // 기존 텍스트 저장
        textElement.innerHTML = '';  // 초기화하여 텍스트가 비어있도록 설정

        let i = 0;
        const speed = 100;  // 타이핑 속도 (밀리초 단위)

        // 이전 타이핑 효과가 있으면 clearInterval로 멈추고 새로 시작하도록 함
        if (window.typeWriterInterval) {
            clearInterval(window.typeWriterInterval); // 기존 interval을 초기화
        }

        // 타이핑 효과 함수
        function typeWriter() {
            if (i < textContent.length) {
                textElement.innerHTML += textContent.charAt(i);  // 하나씩 추가
                i++;
            } else {
                clearInterval(window.typeWriterInterval);  // 타이핑 완료되면 interval을 멈춤
                typing.pause();  // 타이핑 효과가 끝나면 소리 멈춤
            }
        }

        // interval로 타이핑 효과 실행
        window.typeWriterInterval = setInterval(typeWriter, speed);

        // 상태를 변경하여 두 번째 클릭부터는 다른 동작을 하도록 설정
        isFirstClick = false;
    } else {
        button.innerHTML = `updateNote<br>(${musicTitle})`;
        document.getElementById("main-note").scrollIntoView({ behavior: "smooth" });
        isFirstClick = true;
           isFirstMainMusic=true;
   
    }
}


 let userjoinName="noName";

// 함수 정의: .startBeforeScreen 요소를 숨깁니다.
function removeStartBeforePage() {

removeStartBeforePageVar=true;
 
         effectSound("coin");
    const startBeforeScreen = document.querySelector('.startBeforeScreen');
    startBeforeScreen.style.display = 'none'; // 요소를 숨깁니다.
      musicB7.play();//메인화면
         // 모든 음악 멈춤
    musicMain1.pause();
    musicMain2.pause();
    musicMain3.pause();
    musicMain4.pause();
    musicMain5.pause();
  musicCute.pause();
}

  
    startBeforeInformation();
function startBeforeInformation(){
    let messageIndex2 = 0;
    const loadingMessages1=["webCraft 3.0"]
const loadingMessages2 = [
  "Try interacting with interactive blocks!",
  "Light bonuses differ between day and night.",
  "Map downloads are available.",
  "Log in or sign up!",
  "Play maps created by other users!",
  "Click 'Game Blog' to visit our blog.",
  "You can watch the ending credits.",
  "Light bonuses differ between day and night.",
  "TNT......!",
  "Face off against the boss!",
  "Crafting tables are useful.",
  "Signpost feature is now available!"
];
loadingInterval2 = setInterval(() => {
        messageIndex2 = (messageIndex2 + Math.floor(Math.random()*(loadingMessages2.length-1))) % loadingMessages2.length;
        document.querySelector(".startText").innerText = loadingMessages1[0]+"\n\n"+loadingMessages2[messageIndex2];
        loadingMessages2.push(loadingMessages2.splice(messageIndex2, 1)[0]);
    }, 900);

}
    var randomLoadingTime = Math.floor(Math.random() * (8000 - 5000 + 1)) + 5000;
   var loadingDuration = Math.floor(Math.random() * (500 - 100 + 1)) + 150;


function removeStartPage() {
    effectSound("click");
   fullScreen();
    goHomeScreen();
const loadingMessages = [
  "Generating biomes...",
  "Creating caves...",
  "Shaping terrain...",
  "Applying time settings...",
  "Generating dungeons...",
  "Placing trees...",
  "Creating water...",
  "Spawning ores...",
  "Selecting sound effects...",
  "Applying lighting...",
  "Applying shadows...",
  "Adding randomness...",
  "Loading blocks...",
  "Checking entities...",
  "Optimizing motion...",
  "Optimizing visibility...",
  "Changing images...",
  "Differentiating ecosystem...",
  "Adjusting fonts...",
  "Generating random events...",
  "Creating underworld...",
  "Generating natural caves...",
  "Placing sky islands...",
  "Placing chests...",
  "Adjusting probabilities...",
  "Adding more biomes...",
  "Final optimization..."
];


let messageIndex = 0;

// 로딩 시간 동안 퍼센트 진행 상황 표시
const randomLoadingTime = Math.floor(Math.random() * (8000 - 5000 + 1)) + 6000;  // 로딩 시간 설정
const startTime = Date.now();  // 시작 시간 기록
const loadingInterval = setInterval(() => {
    const elapsedTime = Date.now() - startTime; // 경과된 시간
    let percentage = (elapsedTime / randomLoadingTime) * 100;  // 퍼센트 계산
    if (percentage > 100) percentage = 100;  // 100%가 되면 100으로 설정

    // 퍼센트는 소수점 두 자리로 표시
    percentage = percentage.toFixed(2);

    // 메시지 업데이트
    messageIndex = (messageIndex + Math.floor(Math.random() * (loadingMessages.length - 1))) % loadingMessages.length;
    document.querySelector(".startBtn").innerText = `${loadingMessages[messageIndex]} (${percentage}%)`;       

    // 메시지 순서 변경
    loadingMessages.push(loadingMessages.splice(messageIndex, 1)[0]);

    // 로딩이 완료되기 직전 (99% 이상) 상태에서 "로딩 완료" 메시지로 변경
    if (percentage >= 99) {
document.querySelector(".startBtn").innerText = "Loading Complete";  // 로딩 완료 메시지
    }

    // 로딩이 완료되면 interval을 종료하고 게임 초기화
    if (percentage == 100) {
        clearInterval(loadingInterval);  // 로딩 메시지 종료

        // 1초 후에 initializeGame 실행
        setTimeout(() => {
            initializeGame();
        }, 1000);  // 1000ms (1초) 지연 후 게임 초기화
    }

    // 메시지 변경 주기
    loadingDuration = Math.floor(Math.random() * (500 - 100 + 1)) + 150;
}, loadingDuration);  // 100ms마다 메시지를 갱신하고 퍼센트를 계산


       


            function generateRandomUserId(prefix = 'User') {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < 3; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return prefix + result;
        }

        // 기본값: 랜덤 유저
         userjoinName = generateRandomUserId();

        try {
        // localStorage 접근 시도
        const storedId = localStorage.getItem("userId");
        if (storedId && typeof storedId === "string") {
            userjoinName = storedId;
            console.log("Loaded userId from localStorage:", storedId);
        } else {
            console.warn("userId not found in localStorage, using random ID");
        }
        } catch (err) {
        // localStorage 자체가 차단되거나 에러난 경우
        console.error("Failed to access localStorage:", err);
        // fallback: userjoinName은 이미 랜덤값
        }

        // 최종 출력
        sendChat(true, `${userjoinName} join the game`, "Server");



 
    // 초기화 작업을 한 번에 처리
    const initializeGame = () => {
        // 1. 필수 초기화 작업
        makeWorld();
        updateItemOpacity();
        changeSkyPlus();
        
        
       
        document.body.focus();
        document.body.setAttribute('tabindex', '-1');

        
    

        function timeUpLoop(timestamp) {
            const delta = timestamp - lastTimeUpTime;
            
            // 50ms(초당 20회) 주기 실행
            if (delta >= 50) {
                timeUp();
                lastTimeUpTime = timestamp - (delta % 50); // 주기 정확성 유지
            }
            requestAnimationFrame(timeUpLoop);
        }

        function dayTimeUpLoop(timestamp) {
            const delta = timestamp - lastDayTimeUpTime;
            
            // 200ms(초당 5회) 주기 실행
            if (delta >= 200) {
                dayTimeUp();
                lastDayTimeUpTime = timestamp - (delta % 200);
            }
            requestAnimationFrame(dayTimeUpLoop);
        }

        // 타이머 시작
        requestAnimationFrame(timeUpLoop);
        requestAnimationFrame(dayTimeUpLoop);

        // 3. 바이옴 시스템 시작
        updateBiomeBackground();
        updateBiomeOpacity();
        biomeCheckLoop();
        requestAnimationFrame(updateBiomeBackground);
    };

    setTimeout(() => {
        // 1. 로딩 요소 제거
        clearInterval(loadingInterval);
        document.querySelector(".startScreen").style.display = "none";
      

        document.querySelector(".startBtn").style.display = "none";
        document.querySelector(".startText").style.display = "none";

        // 2. 포커스 강제 설정
        document.body.focus();
        document.body.setAttribute('tabindex', '-1');

        // 3. 게임 초기화 바로 실행 (추가 클릭 없음)
        initializeGame();
        goHomeScreen();
        //initMapSaveLoad();

   
    setTimeout(() => {
        firstGoHomeBgm=true;
    }, 1000); 

 // 로딩 시간을 5초에서 8초 사이로 랜덤하게 설정
 
 // 안내 메시지
if (isMobileDevice()) {
    sendChat(true, "PC에서는 키보드 방향키로 이동이 가능합니다", "System");
    effectSound("bitWin");
    sendChat(true, "현재 접속 환경: 모바일", "System");
} else {
      effectSound("quest");
    sendChat(true, "현재 접속 환경: PC/데스크탑", "System");
}




    }, randomLoadingTime); // 로딩 시간 6.5초 유지
}








function goHomeScreen(){
   itemBagGet("64", 100);
     // 새 중앙 좌표 계산 (x:150, y:30.5)
     const blockSize = 30;
    const houseCenterX = 149 * blockSize; // 150 * 30 = 4500px
    const houseCenterY = 52* blockSize; // 915px
    window.scrollTo(
        houseCenterX - window.innerWidth/2, 
        houseCenterY - window.innerHeight/2
    );
    if(playerHp<=30){
        playerHp+=10;
    }
    var goHomeSoundRan=Math.floor(Math.random() * 3) + 1;
    if(firstGoHomeBgm==true){
    sendChat(true,`스폰으로 이동되었습니다. (안될시 여러번 클릭)`,"Server");
    if(goHomeSoundRan==1)effectSound("Beacon_power1");
    if(goHomeSoundRan==2)effectSound("Beacon_power2");
    if(goHomeSoundRan==3)effectSound("Beacon_power3");
    }

}

function fullScreen() {
    effectSound("click");
  const elem = document.documentElement;
  if (!document.fullscreenElement) {
    (elem.requestFullscreen || 
     elem.webkitRequestFullscreen || 
     elem.mozRequestFullScreen || 
     elem.msRequestFullscreen).call(elem);
  } else {
    (document.exitFullscreen || 
     document.webkitExitFullscreen || 
     document.mozCancelFullScreen || 
     document.msExitFullscreen).call(document);
  }
}




///////////////////////////////////////////////////////////
/* ▼▼▼ 표지판 시스템 전역 변수 ▼▼▼ */
const SIGN_ARRAY_WIDTH = 400;  // X축 최대 값 (월드 가로 크기)
const SIGN_ARRAY_HEIGHT = 200; // Y축 최대 값 (월드 세로 크기)
const signArray = Array.from({length: SIGN_ARRAY_WIDTH}, () => 
    Array(SIGN_ARRAY_HEIGHT).fill(null)
);

// 사용자 입력 관련 변수
let signTitle = null;          // 현재 입력 중인 표지판 제목
let signContent = null;        // 현재 입력 중인 표지판 내용

///////////////////////


function makeWorld() {
//////////
const table = document.createElement('table');
    table.className = 'tableBox';
    table.border = '1';
    
    const tbody = document.createDocumentFragment();
    
    for(let i = 0; i < 200; i++) {
        const tr = document.createElement('tr');
        bLocateData[i] = new Array(300);
        
        for(let j = 0; j < 300; j++) {
            const td = document.createElement('td');
            const numZ = `xy${j},${i}`;
            const brightness = calculateDark(i);
            
            // CSS 클래스를 이용한 스타일 적용
            td.className = `titlePad ${bLoc}`;
            td.id = numZ;
            td.dataset.bid = bData1;
            td.dataset.stiffness = bData2;
            td.dataset.empty = bLoc ? 'false' : 'true';
            td.style.cssText = `filter:brightness(${brightness});opacity:1`;
            
            // 이벤트 리스너 직접 등록
            td.addEventListener('click', function() {
                clickBlock(bData1, bData2, bLoc, this, numZ);
            });
            
            randomBlock(j, i);
            bLocateData[i][j] = `${numZ}id:${bLoc}`;
            tr.appendChild(td);
        }
        
        tbody.appendChild(tr);
    }
    
    table.appendChild(tbody);
    document.querySelector(".mainBox").replaceChildren(table);
    /////////
    // ▼▼▼ 표지판 초기화 로직 ▼▼▼
    if(loadedGame==false){
   setTimeout(() => {
        ['xy148,52', 'xy150,52'].forEach(blockId => {
            const [x, y] = blockId.replace('xy', '').split(',').map(Number);
            const targetBlock = document.getElementById(blockId);
            
            if(targetBlock) {
                // 제목/내용 조건부 설정
                const isSpawnArea = x === 148;
                const signData = {
                    title: isSpawnArea ? "구역정보" : "스폰포인트",
                    content: isSpawnArea 
                        ? "스폰 지역입니다.\n위험!: 낙사에 주의하세요." 
                        : "좌측 상단 버튼으로\n언제든지 돌아올 수 있습니다."
                };

                // 블록 속성 설정
                targetBlock.className = "titlePad b63b";
                targetBlock.dataset.bid = "63";
                targetBlock.dataset.stiffness = "2";
                targetBlock.dataset.empty = "false";
                targetBlock.title = signData.title;

                // 2차원 배열에 저장 [x][y]
                if(x >= 0 && x < SIGN_ARRAY_WIDTH && y >= 0 && y < SIGN_ARRAY_HEIGHT) {
                    signArray[x][y] = {
                        ...signData,
                        timestamp: new Date().toISOString()
                    };
                }

                // UI에 표시
                const display = document.createElement('div');
                display.className = 'sign-display';
                display.innerHTML = `<strong>${signData.title}</strong><br>${signData.content}`;
                targetBlock.appendChild(display);
            }
        });
    }, 100);
    }
    if(loadedGame==true){

        for(let xLoc = 0; xLoc < 200; xLoc++) {
        for(let yLoc = 0; yLoc < 300; yLoc++) {


            const signInfo = getSignInfo(xLoc, yLoc);
    //console.log(getSignInfo(xLoc, yLoc));
    //console.log("제목:", signInfo.title);
    //console.log("내용:", signInfo.content);
    if(signInfo){

        const blockId = `xy${xLoc+1},${yLoc}`;
        const targetBlock = document.getElementById(blockId);

        if(targetBlock) {
            // ▼▼▼ blockCodeInput 호출 없이 직접 속성 설정 ▼▼▼
            targetBlock.className = "titlePad b63b";
            targetBlock.dataset.bid = "63";
            targetBlock.dataset.stiffness = "2";
            targetBlock.dataset.empty = "false";

            // 좌표 파싱 및 유효성 검사
            const [x, y] = blockId.replace('xy', '').split(',').map(Number);
            if(x < 0 || x >= SIGN_ARRAY_WIDTH || y < 0 || y >= SIGN_ARRAY_HEIGHT) {
                console.error(`Invalid coordinates: ${x},${y}`);
                return;
            }

            // 로드된 표지판 정보를 사용하여 데이터 설정
            signArray[x][y] = {
                title: signInfo.title,
                content: signInfo.content,
                timestamp: signInfo.timestamp || new Date().toISOString()
            };
            targetBlock.title = signInfo.title;

            // UI 표시 요소 생성
            const display = document.createElement('div');
            display.className = 'sign-display';
            display.innerHTML = `<strong>${signInfo.title}</strong><br>${signInfo.content}`;
            targetBlock.appendChild(display);
        }
    } else {
      //  sendChat(true,`저장된 맵의 표지판 정보가 잘못되었습니다`,"표지판");
        }
        }
        }

        //alert(getGameModeState());
        if(getGameModeState()=="true"){
        creativeMode=true;
    sendChat(true,`크리에이티브 모드가 선택되었습니다.`,"게임모드 로드");
    sendChat(true,`명령어 : gamemode0,1`,"게임모드 로드");

    gameModeChange(1);
    }else{
        creativeMode=false;
        sendChat(true,`서바이벌 모드가 선택되었습니다.`,"게임모드 로드");
    gameModeChange(0);

    }
    }

}

/*


*/
//////////////////////
function calculateDark(y) {
    // 우주 영역 (0~19): 점점 어두워짐
    if (y <= 2) return 0.2;
    else if (y <= 4) return 0.4;
    else if (y <= 6) return 0.6;
    else if (y <= 8) return 0.8;
    else if (y <= 10) return 0.9;
    else if (y <= 12) return 0.95;
 

    // 밝은 하늘 영역 (20~53): 완전히 밝음
    else if (y <= 53) return 1.0;

    // 지하 영역 (54~150): 급격히 어두워짐 (세분화)
    /*
        else if (y <= 57) return 0.2;
    else if (y <= 62) return 0.35;
    else if (y <= 67) return 0.3;
    else if (y <= 72) return 0.25;
    else if (y <= 77) return 0.2;
    else if (y <= 82) return 0.18;
    else if (y <= 87) return 0.16;
    else if (y <= 94) return 0.14;
    else if (y <= 104) return 0.12;
    else if (y <= 114) return 0.10;
    else if (y <= 124) return 0.09;
    else if (y <= 134) return 0.08;
    else if (y <= 144) return 0.07;
    else return 0.06; // 145~150
    */
    else if (y <= 57) return 0.15;
    else if (y <= 62) return 0.075;
    else if (y <= 67) return 0.037;
    else if (y <= 72) return 0.018;
    else if (y <= 77) return 0.01;
    else if (y <= 82) return 0.01;
    else if (y <= 87) return 0.01;
    else if (y <= 94) return 0.01;
    else if (y <= 104) return 0.01;
    else if (y <= 114) return 0.01;
    else if (y <= 124) return 0.01;
    else if (y <= 134) return 0.01;
    else if (y <= 144) return 0.01;
    else return 0.01; // 145~150
}
//opacity투명도 설정
function calculateDark2(y) {
    // 우주 영역 (0~19): 점점 어두워짐
    if (y <= 2) return 0.025;
    if (y <= 4) return 0.05;
    if (y <= 6) return 0.1;
    if (y <= 8) return 0.15;
    else if (y <= 10) return 0.2;
    else if (y <= 12) return 0.3;
    else if (y <= 14) return 0.4;
    else if (y <= 16) return 0.5;


    else return 1;
}


//아이템생성2
function blockCodeInput(blockName){

    // ▼▼▼ undefined/null 처리 강화 ▼▼▼
    if (typeof blockName === 'undefined' || blockName === null) {
        console.error('Undefined block name:', blockName);
        blockName = "잔디";
    }

    // ▼▼▼ 문자열 변환 보완 ▼▼▼
    blockName = String(blockName).trim();

    // ▼▼▼ switch 전 기본값 설정 ▼▼▼
    let defaultUsed = false;

  switch (blockName){
  
    case "잔디":   bLoc = "b1b";  bData1 = "1";  bData2 = "2";     break;
    case "점토":     bLoc = "b2b";  bData1 = "2";  bData2 = "3";     break;
    case "진흙":   bLoc = "b3b";  bData1 = "3";  bData2 = "3";     break;
    case "나무":   bLoc = "b4b";  bData1 = "4";  bData2 = "4";     break;
    case "페이퍼나뭇잎": bLoc = "b5b";  bData1 = "5";  bData2 = "1";     break;
    
    // 자연 계열 블록
    case "흙":         bLoc = "b6b";  bData1 = "6";  bData2 = "3";    break;
    case "구름":       bLoc = "b7b";  bData1 = "7";  bData2 = "2";     break;
    case "먹구름": bLoc = "b8b";  bData1 = "8";  bData2 = "2";   break;
    case "흐린구름": bLoc = "b9b";  bData1 = "9";  bData2 = "2";   break;

    case "조약돌":     bLoc = "b10b"; bData1 = "10"; bData2 = "4";    break;
     
    // 광물 계열 블록
    case "철광석":     bLoc = "b11b"; bData1 = "11"; bData2 = "10";    break;
    case "루비":       bLoc = "b12b"; bData1 = "12"; bData2 = "30";    break;
    case "에메랄드":   bLoc = "b13b"; bData1 = "13"; bData2 = "50";    break;
    case "다이아":     bLoc = "b14b"; bData1 = "14"; bData2 = "150";   break;
    
    // 하늘 계열 블록 (15~28)
    case "하늘":       bLoc = "b15b"; bData1 = "15"; bData2 = "9999";   break;
    case "우주하늘":   bLoc = "b46b"; bData1 = "46"; bData2 = "9999";   break;
    
    // 특수 블록
    case "베드락":     bLoc = "b47b"; bData1 = "47"; bData2 = "9999999"; break;
    case "나뭇잎":     bLoc = "b48b"; bData1 = "48"; bData2 = "1";      break;
    case "제작나무":   bLoc = "b49b"; bData1 = "49"; bData2 = "4";      break;
    case "벌통":       bLoc = "b50b"; bData1 = "50"; bData2 = "5";     break;
    case "꿀블럭":     bLoc = "b51b"; bData1 = "51"; bData2 = "4";      break;
    case "흑요석":     bLoc = "b52b"; bData1 = "52"; bData2 = "13";    break;

    case "신비한블럭":   bLoc = "b54b"; bData1 = "54"; bData2 = "5";     break;
    case "뉴구름":     bLoc = "b56b"; bData1 = "56"; bData2 = "1";     break;
    //던전블록
    case "던전블록1":     bLoc = "b57b"; bData1 = "57"; bData2 = "45";     break;
    case "던전블록2":   bLoc = "b58b"; bData1 = "58"; bData2 = "60";     break;
    case "던전블록3":     bLoc = "b59b"; bData1 = "59"; bData2 = "75";     break;
    case "던전블록4":     bLoc = "b60b"; bData1 = "60"; bData2 = "90";     break;
    case "던전가시":     bLoc = "b61b"; bData1 = "61"; bData2 = "50";     break;




    case "횃불":     bLoc = "b62b"; bData1 = "62"; bData2 = "2";     break;
    case "표지판":     bLoc = "b63b"; bData1 = "63"; bData2 = "2";     break;
    case "상호작용":     bLoc = "b64b"; bData1 = "64"; bData2 = "2";     break;
    case "TNT":     bLoc = "b65b"; bData1 = "65"; bData2 = "50";     break;
    case "쥬크박스":     bLoc = "b66b"; bData1 = "66"; bData2 = "2";     break;
    case "상자":     bLoc = "b67b"; bData1 = "67"; bData2 = "30";     break;
    case "정글상자":     bLoc = "b68b"; bData1 = "68"; bData2 = "35";     break;
    case "황금상자":     bLoc = "b69b"; bData1 = "69"; bData2 = "40";     break;
    case "스타트패키지":     bLoc = "b70b"; bData1 = "70"; bData2 = "45";     break;
    case "흑요석상자":     bLoc = "b71b"; bData1 = "71"; bData2 = "50";     break;
    case "하늘상자":     bLoc = "b72b"; bData1 = "72"; bData2 = "60";     break;
    case "TNT_VER2":     bLoc = "b73b"; bData1 = "73"; bData2 = "100";     break;
    case "열린문상단":     bLoc = "b74b"; bData1 = "74"; bData2 = "5";     break;
    case "열린문하단":     bLoc = "b75b"; bData1 = "75"; bData2 = "5";     break;
    case "닫힌문상단":     bLoc = "b76b"; bData1 = "76"; bData2 = "5";     break;
    case "닫힌문하단":     bLoc = "b77b"; bData1 = "77"; bData2 = "5";     break;
    //
// 신규 추가 블록
case "유리":     bLoc = "b78b"; bData1 = "78"; bData2 = "5";     break;
    case "트리":     bLoc = "b79b";  bData1 = "79";  bData2 = "3";     break;
    case "재블럭":   bLoc = "b80b";  bData1 = "80";  bData2 = "100";     break;
    case "지옥석":   bLoc = "b81b";  bData1 = "81";  bData2 = "150";    break;
    case "단단한지옥석": bLoc = "b82b";  bData1 = "82";  bData2 = "200";  break;
    case "불타는화염": bLoc = "b83b";  bData1 = "83";  bData2 = "300";   break;
    case "핏빛돌":   bLoc = "b84b";  bData1 = "84";  bData2 = "75";    break;
    case "무지개블럭": bLoc = "b85b";  bData1 = "85";  bData2 = "10";   break;
    case "물":   bLoc = "b55b";  bData1 = "55";  bData2 = "30";    break;
    case "용암": bLoc = "b86b";  bData1 = "86";  bData2 = "500";   break;

    //2차 업데이트 추가블럭
    case "폭탄": bLoc = "b95b";  bData1 = "95";  bData2 = "10";   break;
    case "조합대": bLoc = "b96b";  bData1 = "96";  bData2 = "10";   break;

//3차 업데이트 추가블럭
case "모루": bLoc = "b97b"; bData1 = "97"; bData2 = "5"; break;
case "화로": bLoc = "b98b"; bData1 = "98"; bData2 = "5"; break;
case "모닥불": bLoc = "b99b"; bData1 = "99"; bData2 = "5"; break;
case "거미줄": bLoc = "b100b"; bData1 = "100"; bData2 = "5"; break;
case "얼음": bLoc = "b101b"; bData1 = "101"; bData2 = "5"; break;
case "단단한얼음": bLoc = "b102b"; bData1 = "102"; bData2 = "5"; break;
case "눈": bLoc = "b103b"; bData1 = "103"; bData2 = "5"; break;
case "눈블럭": bLoc = "b104b"; bData1 = "104"; bData2 = "5"; break;
case "크리스탈블럭": bLoc = "b105b"; bData1 = "105"; bData2 = "5"; break;
case "모래": bLoc = "b106b"; bData1 = "106"; bData2 = "3"; break;
case "모래벽돌": bLoc = "b107b"; bData1 = "107"; bData2 = "12"; break;
case "사암": bLoc = "b108b"; bData1 = "108"; bData2 = "10"; break;
case "선인장": bLoc = "b109b"; bData1 = "109"; bData2 = "2"; break;
case "광산수레": bLoc = "b110b"; bData1 = "110"; bData2 = "10"; break;
case "철로": bLoc = "b111b"; bData1 = "111"; bData2 = "3"; break;
case "핵폭탄": bLoc = "b112b"; bData1 = "112"; bData2 = "999"; break;
case "밧줄": bLoc = "b113b"; bData1 = "113"; bData2 = "1"; break;
case "연기": bLoc = "b114b"; bData1 = "114"; bData2 = "1"; break;


case "선인장곡괭이": bLoc = "b115b"; bData1 = "115"; bData2 = "30"; break;
case "철곡괭이": bLoc = "b116b"; bData1 = "116"; bData2 = "40"; break;
case "다이아곡괭이": bLoc = "b117b"; bData1 = "117"; bData2 = "50"; break;
case "철검":     bLoc = "b118b"; bData1 = "118"; bData2 = "5"; break;
case "철활":     bLoc = "b119b"; bData1 = "119"; bData2 = "5"; break;
case "화살":     bLoc = "b120b"; bData1 = "120"; bData2 = "5"; break;
case "포션":     bLoc = "b121b"; bData1 = "121"; bData2 = "50"; break;
case "동트로피": bLoc = "b122b"; bData1 = "122"; bData2 = "15"; break;
case "은트로피": bLoc = "b123b"; bData1 = "123"; bData2 = "30"; break;
case "금트로피": bLoc = "b124b"; bData1 = "124"; bData2 = "60"; break;
case "플랫폼": bLoc = "b125b"; bData1 = "125"; bData2 = "1"; break;
case "고대의상자": bLoc = "b126b"; bData1 = "126"; bData2 = "100"; break;



case "화강암": bLoc = "b53b"; bData1 = "53"; bData2 = "60"; break;


case "액자": bLoc = "b149b"; bData1 = "149"; bData2 = "2"; break;


case "알 수 없음": // ▼▼▼ 추가: 알 수 없음 처리 ▼▼▼
            bLoc = "b15b";
            bData1 = "15";
            bData2 = "9999";
            console.warn('알 수 없는 블록을 하늘로 처리');
            break;

default:
            console.error('Unknown block:', blockName);
            // ▼▼▼ 강제 기본값 설정 ▼▼▼
            bLoc = "b5b";
            bData1 = "15";
            bData2 = "9999";
            defaultUsed = true;
            
    }


    // ▼▼▼ 문제 발생 시 상세 로그 ▼▼▼
    if(defaultUsed) {
        console.warn('Used default block for:', blockName, 
                    'at', new Error().stack.split('\n')[2]);
    }

window.bData1 = bData1.toString(); // 숫자 ID 문자열로 변환
window.bData2 = bData2.toString(); // 내구도 문자열로 변환
  }


//아이탬생성3
//b16b가 아닌 16상태로 오면 블럭 이름 반환
function blockCodeInput2(blockId) {

        // ▼▼▼ 숫자 추출 로직 강화 ▼▼▼
    const idStr = String(blockId).replace(/[^0-9]/g, '');
    if(idStr === '') return "알 수 없음";
    
    const idNum = parseInt(String(blockId).replace(/[^0-9]/g, ""));
    if(isNaN(idNum)) return "알 수 없음";

    
    switch (idNum) {
    
   
        case 1: return "잔디";
        case 2: return "점토";
        case 3: return "진흙";
        case 4: return "나무";
        case 5: return "페이퍼나뭇잎"; // 추가
        case 6: return "흙"; // 추가
        case 7: return "구름";
        case 8: return "먹구름";
        case 9: return "흐린구름"; // 추가
        case 10: return "조약돌";
        case 11: return "철광석";
        case 12: return "루비";
        case 13: return "에메랄드";
        case 14: return "다이아";
        case 15: return "하늘";
        case 46: return "우주하늘";
        case 47: return "베드락"; // 추가
        case 48: return "나뭇잎";
        case 49: return "제작나무";
        case 50: return "벌통";
        case 51: return "꿀블럭";
        case 52: return "흑요석";
        case 53: return "화강암";
        case 54: return "신비한블럭";
        case 55: return "물";
        case 56: return "뉴구름"; // 추가
        case 57: return "던전블록1";
        case 58: return "던전블록2";
        case 59: return "던전블록3";
        case 60: return "던전블록4";
        case 61: return "던전가시";
        case 62: return "횃불";
        case 63: return "표지판";
        case 64: return "상호작용";
        case 65: return "TNT";
        case 66: return "쥬크박스";
        case 67: return "상자";
        case 68: return "정글상자";
        case 69: return "황금상자";
        case 70: return "스타트패키지";
        case 71: return "흑요석상자";
        case 72: return "하늘상자";
        case 73: return "TNT_VER2";
        case 74: return "열린문상단";
        case 75: return "열린문하단";
        case 76: return "닫힌문상단";
        case 77: return "닫힌문하단";
        case 78: return "유리";
        case 79: return "트리";
        case 80: return "재블럭";
        case 81: return "지옥석";
        case 82: return "단단한지옥석";
        case 83: return "불타는화염";
        case 84: return "핏빛돌";
        case 85: return "무지개블럭";
        case 86: return "용암";
        case 95: return "폭탄";
        case 96: return "조합대";
        case 97: return "모루";
        case 98: return "화로";
        case 99: return "모닥불";
        case 100: return "거미줄";
        case 101: return "얼음";
        case 102: return "단단한얼음";
        case 103: return "눈";
        case 104: return "눈블럭";
        case 105: return "크리스탈블럭";
        case 106: return "모래";
        case 107: return "모래벽돌";
        case 108: return "사암";
        case 109: return "선인장";
        case 110: return "광산수레";
        case 111: return "철로";
        case 112: return "핵폭탄";
        case 113: return "밧줄";
        case 114: return "연기";
        case 115: return "선인장곡괭이";
        case 116: return "철곡괭이";
        case 117: return "다이아곡괭이";
        case 118: return "철검";
        case 119: return "철활";
        case 120: return "화살";
        case 121: return "포션";
        case 122: return "동트로피";
        case 123: return "은트로피";
        case 124: return "금트로피";
        case 125: return "플랫폼";
        case 126: return "고대의상자";
        case 149: return "액자"; // 추가



default: return "알 수 없음";
  }


}

let cloudPositions = [];
let lastCloudX = -Infinity; // 마지막 구름 생성 X좌표


/////////////////////////////

// ▼▼▼ 퍼린 노이즈 생성기 (외부 함수로 분리) ▼▼▼
function createPerlinNoise(seed) {
    class SimplePerlin {
        constructor(seed) {
            this.gradients = new Array(256);
            this.perm = new Array(256);
            
            // 초기화
            for(let i = 0; i < 256; i++) {
                this.gradients[i] = Math.random() * 2 - 1;
                this.perm[i] = i;
            }
            
            // 시드 기반 셔플링
            for(let i = 0; i < 256; i++) {
                const j = (seed + i * 31) % 256;
                [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
            }
        }

        noise(x) {
            const x0 = Math.floor(x);
            const x1 = x0 + 1;
            const t = x - x0;
            const n0 = this.gradients[this.perm[x0 % 256]] * (x - x0);
            const n1 = this.gradients[this.perm[x1 % 256]] * (x - x1);
            return this.lerp(n0, n1, t);
        }

        lerp(a, b, t) {
            return a + t * (b - a);
        }
    }
    return new SimplePerlin(seed);
}

// ▼▼▼ 전역 노이즈 인스턴스 생성 ▼▼▼
const terrainNoise = (() => {
    const seed = Math.floor(Math.random() * 1000000);
    return createPerlinNoise(seed);
})();


//인공 건축물
function getRandomX(min, max, excludeStart, excludeEnd) {
  let x;
  do {
    x = Math.floor(Math.random() * (max - min + 1)) + min;
  } while (x >= excludeStart && x <= excludeEnd);
  return x;
}

function getRandomY(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

const structureOrigins = {
  goldenAltar:     { x: getRandomX(10, 290, 144, 152), y: getRandomY(80, 110) },
  skyTower:        { x: getRandomX(10, 290, 144, 152), y: getRandomY(5, 20) },
  hellShrine:      { x: getRandomX(10, 290, 144, 152), y: getRandomY(100, 130) },
  rainbowGarden:   { x: getRandomX(10, 290, 144, 152), y: getRandomY(80, 100) },
  iceCastle:       { x: getRandomX(10, 290, 144, 152), y: getRandomY(85, 105) },
  desertTemple:    { x: getRandomX(10, 290, 144, 152), y: getRandomY(60, 70) },
  jungleTotem:     { x: getRandomX(10, 290, 144, 152), y: getRandomY(90, 110) },
  obsidianGate:    { x: getRandomX(10, 290, 144, 152), y: getRandomY(95, 120) },
  floatingRing:    { x: getRandomX(10, 290, 144, 152), y: getRandomY(5, 20) },
  dungeonCore:     { x: getRandomX(10, 290, 144, 152), y: getRandomY(110, 135) },
  woodenHouse:     { x: getRandomX(90, 210, 140, 155), y: getRandomY(52, 53) },
  rockTower:       { x: getRandomX(30, 270, 70, 230), y: getRandomY(53,54) }
};



function randomBlock(xLoc,yLoc){
    var ran=((Math.random()*100));//1~9

    var ranUp=parseInt((Math.random()*9));
       var ranDown=parseInt((Math.random()*9));

    var ranTree=parseInt((Math.random()*3)+48);//17~19
    var ranTree2=parseInt((Math.random()*4));///나무높이//1~9

    var ranTree3=parseInt((Math.random()*3)+44);//17~19
    var ranTree4=parseInt((Math.random()*2));///나무높이//1~9

    var ranTree5=parseInt((Math.random()*3)+46);//17~19
    var ranTree6=parseInt((Math.random()*3));///나무높이//1~9
      //var ranCave1X=parseInt((Math.random()*0));//10~19
    //var ranCave1Y=parseInt((Math.random()*30)+30);//10~19

    // ▼▼▼ 블록 속성 직접 설정 ▼▼▼
    let localBLoc = "b15b";
    let localBData1 = "15";
    let localBData2 = "9999";
    let localEmpty = "true";
    let localText = "9999,1.000";
    let localBackground = "none";
    let localOpacity = 1;
    let localColor = "transparent";
    let signXLoc=xLoc-1;
//alert("로드된 맵을 생성합니다.");
if(loadedGame==true){
    if(blockCodeInput2(getBidByCoordinate(xLoc, yLoc))!="표지판"){
    blockCodeInput(blockCodeInput2(getBidByCoordinate(xLoc, yLoc)));
    }

    if(blockCodeInput2(getBidByCoordinate(xLoc, yLoc))=="표지판"){
        blockCodeInput("표지판");//오른쪽으로 밀리니 사전 설치
    }
    if(blockCodeInput2(getBidByCoordinate(xLoc, yLoc))=="표지판"){

    const signInfo = getSignInfo(xLoc, yLoc);
    //console.log(getSignInfo(xLoc, yLoc));
    //console.log("제목:", signInfo.title);
    //console.log("내용:", signInfo.content);
    if(signInfo){
        sendChat(true,`[${signInfo.title}] : ${signInfo.content}`,"로드된 표지판 정보");

        

        const blockId = `xy${xLoc},${yLoc}`;
        const targetBlock = document.getElementById(blockId);

        if(targetBlock) {
            // ▼▼▼ blockCodeInput 호출 없이 직접 속성 설정 ▼▼▼
            targetBlock.className = "titlePad b63b";
            targetBlock.dataset.bid = "63";
            targetBlock.dataset.stiffness = "2";
            targetBlock.dataset.empty = "false";

            // 좌표 파싱 및 유효성 검사
            const [x, y] = blockId.replace('xy', '').split(',').map(Number);
            if(x < 0 || x >= SIGN_ARRAY_WIDTH || y < 0 || y >= SIGN_ARRAY_HEIGHT) {
                console.error(`Invalid coordinates: ${x},${y}`);
                return;
            }

            // 로드된 표지판 정보를 사용하여 데이터 설정
            signArray[x][y] = {
                title: signInfo.title,
                content: signInfo.content,
                timestamp: signInfo.timestamp || new Date().toISOString()
            };
            targetBlock.title = signInfo.title;

            // UI 표시 요소 생성
            const display = document.createElement('div');
            display.className = 'sign-display';
            display.innerHTML = `<strong>${signInfo.title}</strong><br>${signInfo.content}`;
            targetBlock.appendChild(display);
        }
    } else {
        sendChat(true,`저장된 맵의 표지판 정보가 잘못되었습니다`,"표지판 정보 로드 실패");
    }
   
}
}

    else if(loadedGame==false){
////////////////////////
//alert("로드데이터 없음");
if(yLoc<=52&&yLoc>=0){
         blockCodeInput("하늘");
   }

    
    // 구름 생성 로직 개선 ▼▼▼
    if(yLoc <= 11 && yLoc >= 1) {
        // 1. 인접 구름 존재 여부 확인
        const isNearCloud = cloudPositions.some(pos => 
            Math.abs(pos.x - xLoc) <= 1 && 
            Math.abs(pos.y - yLoc) <= 1
        );

        // 2. 구름 생성 확률 계산
        let cloudChance = isNearCloud ? 0.9 : 0.02;
        
        // 3. 최소 간격 유지 (5~30 블록)
        const distanceFromLast = xLoc - lastCloudX;
        if(distanceFromLast > 0 && distanceFromLast < 30) {
            cloudChance *= 0.7; // 간격 미달 시 확률 80% 감소
        }

        if(Math.random() < cloudChance) {
            blockCodeInput("구름");
            cloudPositions.push({x: xLoc, y: yLoc});
            lastCloudX = xLoc;
            
            // 4. 하늘상자 생성 (0.9% 확률)
            if(Math.random() < 0.0175) {
                blockCodeInput("하늘상자");
            }
            if(Math.random() < 0.3) {
                blockCodeInput("물");
            }
            if(Math.random() < 0.03) {
                blockCodeInput("횃불");
            }
            if(Math.random() < 0.16) {
                blockCodeInput("먹구름");
            }
            if(Math.random() < 0.12) {
                blockCodeInput("흐린구름");
            }
            // 5. 다음 구름까지 최소 간격 설정
            xLoc += Math.floor(Math.random() * 30)+7; // 5~30 블록 건너뛰기
        }
    }


//나무 나뭇잎 생성
if((yLoc==(ranTree-(ranTree2))&&(xLoc>=125&&xLoc<=185))&&(xLoc<140||xLoc>151)){
       if(ran>=0&&ran<25){
          blockCodeInput("나뭇잎");
             //console.log("나뭇잎 배치 위치x,y"+xLoc+','+yLoc);
       }

    }
    //나무
if((yLoc>=ranTree&&yLoc<=52)){
randomBlockLoopY((ranTree-1),130,"b48b","b4b",xLoc,yLoc);//y좌표 1칸 위에 나뭇잎 있는지 확인
//console.log(bLocateData[19][0]);
}  



//나무 나뭇잎 생성
if((yLoc==(ranTree3-(ranTree4))&&(xLoc>=125&&xLoc<=185))&&(xLoc<140||xLoc>151)){
       if(ran>=25&&ran<45){
          blockCodeInput("나뭇잎");
             //console.log("나뭇잎 배치 위치x,y"+xLoc+','+yLoc);
       }

    }
    //나무
if((yLoc>=ranTree3&&yLoc<=52)){
randomBlockLoopY((ranTree3-1),130,"b48b","b4b",xLoc,yLoc);//y좌표 1칸 위에 나뭇잎 있는지 확인
//console.log(bLocateData[19][0]);
}  




//나무 나뭇잎 생성
if((yLoc==(ranTree5-(ranTree6))&&(xLoc>=125&&xLoc<=185))&&(xLoc<140||xLoc>151)){
       if(ran>=45&&ran<65){
          blockCodeInput("나뭇잎");
             //console.log("나뭇잎 배치 위치x,y"+xLoc+','+yLoc);
       }

    }
    //나무
if((yLoc>=ranTree5&&yLoc<=52)){
randomBlockLoopY((ranTree5-1),130,"b48b","b4b",xLoc,yLoc);//y좌표 1칸 위에 나뭇잎 있는지 확인
//console.log(bLocateData[19][0]);
}  


   


///////////////

////////
if(yLoc==53&&((xLoc>=144&&xLoc<=141))){
    blockCodeInput("잔디");
}

    //스폰포인트
if(yLoc==52&&((xLoc==144||xLoc==152))){
           blockCodeInput("횃불");
    }

    if(yLoc==52&&(xLoc==145)){
           blockCodeInput("스타트패키지");
    }

    if(yLoc==52&&(xLoc==148)){
           blockCodeInput("조합대");
    }

    if(yLoc==52 && (xLoc==151)) {
        blockCodeInput("스타트패키지");
     
    }
if(yLoc==52 &&((xLoc==146||xLoc==150))) {
        blockCodeInput("모닥불");
     
    }
if(yLoc==52 && (xLoc==147||xLoc==149)) {//전부 오른쪽으로 1칸씩 밀리니 여기파트만 1씩 줄이기

    blockCodeInput("표지판");

    const blockId = `xy${xLoc},${yLoc}`;
    const targetBlock = document.getElementById(blockId);
    
 
    if(targetBlock) {
    // ▼▼▼ blockCodeInput 호출 없이 직접 속성 설정 ▼▼▼
    targetBlock.className = "titlePad b63b";
    targetBlock.dataset.bid = "63";
    targetBlock.dataset.stiffness = "2";
    targetBlock.dataset.empty = "false";
    
    // 좌표 파싱 및 유효성 검사
    const [x, y] = blockId.replace('xy', '').split(',').map(Number);
    if(x < 0 || x >= SIGN_ARRAY_WIDTH || y < 0 || y >= SIGN_ARRAY_HEIGHT) {
        console.error(`Invalid coordinates: ${x},${y}`);
        return;
    }

    // 표지판 데이터 설정
    const isSpawnArea = x === 149;
    const signData = {
        title: isSpawnArea ? "구역정보" : "스폰포인트",
        content: isSpawnArea 
            ? "스폰 지역입니다.\n주의: 낙사에 주의하세요." 
            : "좌측 상단 버튼으로\n언제든지 돌아올 수 있습니다.",
        timestamp: new Date().toISOString()
    };

    // 2D 배열에 저장
    signArray[x][y] = signData;
    targetBlock.title = signData.title;

    // UI 표시 요소 생성
    const display = document.createElement('div');
    display.className = 'sign-display';
    display.innerHTML = `<strong>${signData.title}</strong><br>${signData.content}`;
    targetBlock.appendChild(display);
    }

}





if(yLoc>=54&&yLoc<59){
        if(ran>=0&&ran<50){
           blockCodeInput("점토");
        }
        if(ran>=50&&ran<70){
           blockCodeInput("진흙");
        }
        if(ran>=65&&ran<80){
           blockCodeInput("조약돌");
        }
        else{
            if(yLoc==58){

           blockCodeInput("조약돌");
          
        }
    }
}
if(yLoc==53&&(xLoc>=140&&xLoc<=151))  blockCodeInput("잔디");
// 상단 영역 - 조약돌 (지옥 위 일반 동굴 영역)
if(yLoc>=54&&yLoc<=150){
    blockCodeInput("조약돌");
}



generateTerrain(xLoc, yLoc); //최종바이옴





const MAP_WIDTH = 300; // 상단에 선언
const OCEAN_WIDTH = 20;
const WATER_LEVEL = 53;
const SHORE_WIDTH = 20;


if(oceanRan==1){
// 왼쪽 물

if(xLoc <= OCEAN_WIDTH + SHORE_WIDTH && yLoc >= WATER_LEVEL){
    const depth = yLoc - WATER_LEVEL;
    const shoreX = Math.max(0, OCEAN_WIDTH + SHORE_WIDTH - Math.floor(depth * 0.9));
    
    if(xLoc <= shoreX &&xLoc>=0){
        if(yLoc === WATER_LEVEL && Math.random() < 0.3){;
            blockCodeInput("물"); //모래
        } else {
            blockCodeInput("물");
        }
        return;
    }
}



}else if(oceanRan==2){
// 오른쪽 물
if(xLoc >= MAP_WIDTH - OCEAN_WIDTH - SHORE_WIDTH && yLoc >= WATER_LEVEL){
    const depth = yLoc - WATER_LEVEL;
    const shoreX = MAP_WIDTH - OCEAN_WIDTH - SHORE_WIDTH + Math.floor(depth * 0.7);
    
    if(xLoc >= shoreX&&xLoc<=300){
        if(yLoc === WATER_LEVEL && Math.random() < 0.3){
            blockCodeInput("물");//모래
        } else {
            blockCodeInput("물");
        }
        return;
    }
}
}
// 테라리아 스타일 던전 생성 코드
const DUNGEON_START_X = oceanRan === 10 ? 270 : (oceanRan === 2 ? 10 : 270); // 조건 수정
const DUNGEON_WIDTH = 20; // 던전 가로 크기

// 던전 영역 체크
if(xLoc >= DUNGEON_START_X && xLoc <= DUNGEON_START_X + DUNGEON_WIDTH 
   && yLoc >= 33 && yLoc <= 150) {
    
    // ==================== 지상 던전 구조물 (y=33~52) ====================
    if(yLoc >= 33 && yLoc < 53) {
        // 1. 지붕 생성 (y=33)
        if(yLoc === 33) {
            // 톱니 모양 지붕 (3칸마다 돌출)
            if(xLoc % 3 === 0) {
                blockCodeInput("던전블록1");
                return;
            }
            // 기본 지붕
            if(xLoc >= DUNGEON_START_X && xLoc <= DUNGEON_START_X + DUNGEON_WIDTH) {
                blockCodeInput("던전블록3");
                return;
            }
        }
        
        // 2. 바닥 생성 (y=52)
        if(yLoc === 52) {
            // 입구는 비워둠 (중앙 3칸)
            if(xLoc >= DUNGEON_START_X + Math.floor(DUNGEON_WIDTH/2) - 1 && 
               xLoc <= DUNGEON_START_X + Math.floor(DUNGEON_WIDTH/2) + 1) {
                return;
            }
            blockCodeInput("던전블록3");
            return;
        }
        
        // 3. 외벽 생성
        if(xLoc === DUNGEON_START_X || xLoc === DUNGEON_START_X + DUNGEON_WIDTH) {
            blockCodeInput("던전블록1");
            return;
        }
        
        // 4. 기둥만 생성 (격자무늬 제거)
        if((xLoc - DUNGEON_START_X) % 10 === 0) {
            blockCodeInput("던전블록2");
            return;
        }
        
        // 지상 내부는 비워둠 (격자무늬 없음)
        return;
    }
    
    // ==================== 지하 던전 구조 (y=53~150) ====================
    
    // 외벽 생성f
    if(xLoc === DUNGEON_START_X || xLoc === DUNGEON_START_X + DUNGEON_WIDTH) {
        blockCodeInput("던전블록1");
        return;
    }

    // 층 구분 (20블록 간격)
    if((yLoc - 53) % 20 === 0) {
        blockCodeInput("던전블록3");
        return;
    }

    // 방 생성
    if((xLoc - DUNGEON_START_X) % 10 === 0 && (yLoc - 53) % 20 === 5) {
        // 방 크기 5x5
        for(let dy=0; dy<5; dy++) {
            for(let dx=0; dx<5; dx++) {
                if(dx === 0 || dx === 4 || dy === 0 || dy === 4) {
                    blockCodeInput("던전블록2", xLoc + dx, yLoc + dy);
                }
            }
        }
        
        // 보물상자를 꿀블럭으로 대체 (30% 확률)
        if(Math.random() < 0.3) {
            blockCodeInput("신비한블럭", xLoc + 2, yLoc + 3);
        }
        return;
    }

    // 기둥/복도 생성
    if((xLoc - DUNGEON_START_X) % 8 === 0) {
        blockCodeInput("던전블록4");
        return;
    }

    // 함정 생성 (5% 확률)
    if(Math.random() < 0.05) {
        blockCodeInput("던전가시");
        return;
    }

    if(Math.random() < 0.03) {
        blockCodeInput("횃불");
        return;
    }

    if(Math.random() < 0.025) {
        blockCodeInput("폭탄");
        return;
    }
    if(Math.random() < 0.018) {
        blockCodeInput("황금상자");
        return;
    }
    // 기본 바닥 처리 - 던전 깊이에 따라 다른 패턴 사용
    const depth = yLoc - 53;
    if(depth < 40) {
        blockCodeInput("던전블록" + (Math.random() < 0.7 ? "1" : "2"));
    } else if(depth < 80) {
        blockCodeInput("던전블록" + (Math.random() < 0.7 ? "2" : "3"));
    } else {
        blockCodeInput("던전블록" + (Math.random() < 0.7 ? "3" : "4"));
    }
    return;
}




// 전환 영역 - 지옥으로 들어가는 입구 부분
if(yLoc>140&&yLoc<=150){
    if(ran>=0&&ran<40){ // 40% 확률로 조약돌
        blockCodeInput("조약돌");
    }
    else if(ran>=40&&ran<75){ // 35% 확률로 재블럭
        blockCodeInput("재블럭");
    }
    else if(ran>=75&&ran<93){ // 15% 확률로 핏빛돌
        blockCodeInput("핏빛돌");
    }
    else if(ran>=93&&ran<96){ // 20% 확률로 재블럭
        blockCodeInput("횃불");
    }
    else { // 10% 확률로 용암
        blockCodeInput("용암");
    }
}

// 지옥 상부 - 재블럭과 지옥석 중심
if(yLoc>150&&yLoc<=165){
    if(ran>=0&&ran<50){ // 50% 확률로 재블럭
        blockCodeInput("재블럭");
    }
    else if(ran>=50&&ran<75){ // 25% 확률로 지옥석
        blockCodeInput("지옥석");
    }
    else if(ran>=75&&ran<94){ // 15% 확률로 단단한지옥석
        blockCodeInput("단단한지옥석");
    }
    else if(ran>=94&&ran<95){ // 20% 확률로 재블럭
        blockCodeInput("불타는화염");
    }
    else if(ran>=95&&ran<96){ // 20% 확률로 재블럭
        blockCodeInput("횃불");
    }
    else { // 10% 확률로 용암
        blockCodeInput("용암");
    }
}

// 지옥 중부 - 지옥석과 재블럭, 용암이 섞인 핵심 지역
if(yLoc>165&&yLoc<=180){
    if(ran>=0&&ran<35){ // 35% 확률로 지옥석
        blockCodeInput("지옥석");
    }
    else if(ran>=35&&ran<55){ // 20% 확률로 단단한지옥석
        blockCodeInput("단단한지옥석");
    }
    else if(ran>=55&&ran<95){ // 20% 확률로 재블럭
        blockCodeInput("재블럭");
    }
    else if(ran>=95&&ran<96){ // 20% 확률로 재블럭
        blockCodeInput("불타는화염");
    }
    else if(ran>=96&&ran<97){ // 20% 확률로 재블럭
        blockCodeInput("횃불");
    }
    else { // 25% 확률로 용암
        blockCodeInput("용암");
    }
}

// 지옥 하부 - 용암이 많아지는 영역
if(yLoc>180&&yLoc<=190){
    if(ran>=0&&ran<50){ // 50% 확률로 용암
        blockCodeInput("용암");
    }
    else if(ran>=50&&ran<80){ // 20% 확률로 지옥석
        blockCodeInput("지옥석");
    }
    else if(ran>=80&&ran<95){ // 15% 확률로 단단한지옥석
        blockCodeInput("단단한지옥석");
    }
    else if(ran>=95&&ran<96){ // 20% 확률로 재블럭
        blockCodeInput("불타는화염");
    }
    else if(ran>=96&&ran<97){ // 20% 확률로 재블럭
        blockCodeInput("횃불");
    }
    else { // 15% 확률로 재블럭
        blockCodeInput("재블럭");
    }
}

// 지옥 최하부 - 대부분 용암으로 구성된 바닥
if(yLoc>190&&yLoc<=200){
    if(ran>=60&&ran<90){ // 90% 확률로 용암
        blockCodeInput("용암");
    }
    else if(ran>=90&&ran<95){ // 5% 확률로 지옥석
        blockCodeInput("지옥석");
    }
    else { // 5% 확률로 단단한지옥석
        blockCodeInput("단단한지옥석");
    }
}


//동굴생성
// 첫 번째 동굴: 흑요석과 루비 위주
if((yLoc>=ranCave1Y&&(yLoc<ranCave1Y+ranCave1YC)&&(xLoc>=ranCave1X&&(xLoc<=ranCave1X+ranCave1XC)))){
    const centerX = ranCave1X + ranCave1XC/2;
    const centerY = ranCave1Y + ranCave1YC/2;
    const dx = (xLoc - centerX) / (ranCave1XC/2);
    const dy = (yLoc - centerY) / (ranCave1YC/2);
    const distance = Math.sqrt(dx*dx + dy*dy);
    const distortionFactor = 0.2;
    const randomOffset = Math.sin(xLoc * 0.3) * Math.cos(yLoc * 0.3) * distortionFactor;
    
    if(distance + randomOffset <= 1.0) {
        if(ran>=0&&ran<90) blockCodeInput("흑요석");
        else blockCodeInput("루비");
    }
}

// 두 번째 동굴: 화강암과 흑요석 위주
if((yLoc>=ranCave2Y&&(yLoc<ranCave2Y+ranCave2YC)&&(xLoc>=ranCave2X&&(xLoc<=ranCave2X+ranCave2XC)))){
    const centerX = ranCave2X + ranCave2XC/2;
    const centerY = ranCave2Y + ranCave2YC/2;
    const dx = (xLoc - centerX) / (ranCave2XC/2);
    const dy = (yLoc - centerY) / (ranCave2YC/2);
    const distance = Math.sqrt(dx*dx + dy*dy);
    const distortionFactor = 0.2;
    const randomOffset = Math.sin(xLoc * 0.3) * Math.cos(yLoc * 0.3) * distortionFactor;
    
    if(distance + randomOffset <= 1.0) {
        if(ran>=0&&ran<90) blockCodeInput("화강암");
        else blockCodeInput("흑요석");
    }
}

// 세 번째 동굴: 벌통과 꿀블럭 위주
if((yLoc>=ranCave3Y&&(yLoc<ranCave3Y+ranCave3YC)&&(xLoc>=ranCave3X&&(xLoc<=ranCave3X+ranCave3XC)))){
    const centerX = ranCave3X + ranCave3XC/2;
    const centerY = ranCave3Y + ranCave3YC/2;
    const dx = (xLoc - centerX) / (ranCave3XC/2);
    const dy = (yLoc - centerY) / (ranCave3YC/2);
    const distance = Math.sqrt(dx*dx + dy*dy);
    const distortionFactor = 0.2;
    const randomOffset = Math.sin(xLoc * 0.3) * Math.cos(yLoc * 0.3) * distortionFactor;
    
    if(distance + randomOffset <= 1.0) {
        if(ran>=0&&ran<90) blockCodeInput("벌통");
        else blockCodeInput("꿀블럭");
    }
}

// 모든 동굴 처리
emptyCaves.forEach(function(cave) {
    if((yLoc >= cave.y && yLoc < cave.y + cave.height) && 
       (xLoc >= cave.x && xLoc <= cave.x + cave.width)) {
        
        const centerX = cave.x + cave.width/2;
        const centerY = cave.y + cave.height/2;
        
        // 타원 계산 (더 자연스러운 형태)
        const dx = (xLoc - centerX) / (cave.width/2);
        const dy = (yLoc - centerY) / (cave.height/2);
        
        // 기본 거리 계산
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        // 더 복잡한 왜곡 패턴
        const noiseValue = 
            Math.sin(xLoc * cave.noiseScale) * 
            Math.cos(yLoc * cave.noiseScale) * cave.distortion;
        
        // 가장자리 확인 (자연스러운 경계)
        const isEdge = Math.abs(1.0 - distance) < 0.05;
        
        // 동굴 영역 판정
        if(distance + noiseValue <= 1.0) {
            // 동굴 가장자리 (부드러운 전환)
            if(isEdge || 
               Math.abs(xLoc - cave.x) < 2 || 
               Math.abs(xLoc - (cave.x + cave.width)) < 2 || 
               Math.abs(yLoc - cave.y) < 2 || 
               Math.abs(yLoc - (cave.y + cave.height)) < 2) {
                
                const rand = Math.random();
                
                if(rand < cave.goldenChestChance) {
                    blockCodeInput("황금상자");
                }
                else if(rand < cave.goldenChestChance + cave.chestChance) {
                    blockCodeInput("상자");
                }
                else if(rand < cave.goldenChestChance + cave.chestChance + cave.torchChance) {
                    blockCodeInput("횃불");
                }
                else if(rand < 0.25) {
                    blockCodeInput("물");
                }
                else if(rand < 0.1) {
                    blockCodeInput("용암");
                }

            } 
            else {
                // 동굴 내부는 빈 공간
                blockCodeInput("하늘");
            }
        }
    }
});

//////////////
// 모든 동굴 처리
emptyCaves2.forEach(function(cave) {
    if((yLoc >= cave.y && yLoc < cave.y + cave.height) && 
       (xLoc >= cave.x && xLoc <= cave.x + cave.width)) {
        
        const centerX = cave.x + cave.width/2;
        const centerY = cave.y + cave.height/2;
        
        // 타원 계산 (더 자연스러운 형태)
        const dx = (xLoc - centerX) / (cave.width/2);
        const dy = (yLoc - centerY) / (cave.height/2);
        
        // 기본 거리 계산
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        // 더 복잡한 왜곡 패턴
        const noiseValue = 
            Math.sin(xLoc * cave.noiseScale) * 
            Math.cos(yLoc * cave.noiseScale) * cave.distortion;
        
        // 가장자리 확인 (자연스러운 경계)
        const isEdge = Math.abs(1.0 - distance) < 0.05;
        
        // 동굴 영역 판정
        if(distance + noiseValue <= 1.0) {
            // 동굴 가장자리 (부드러운 전환)
            if(isEdge || 
               Math.abs(xLoc - cave.x) < 2 || 
               Math.abs(xLoc - (cave.x + cave.width)) < 2 || 
               Math.abs(yLoc - cave.y) < 2 || 
               Math.abs(yLoc - (cave.y + cave.height)) < 2) {
                
                const rand = Math.random();
                
                if(rand < cave.darkChestChance) {
                    blockCodeInput("흑요석상자");
                }
 
                else if(rand < cave.goldenChestChance + cave.chestChance + cave.torchChance) {
                    blockCodeInput("횃불");
                }
                else if(rand < 0.95) {
                    blockCodeInput("하늘");
                }
                else if(rand < 0.4) {
                    blockCodeInput("용암");
                }
                else if(rand < 0.5) {
                    blockCodeInput("지옥석");
                }
                else if(rand < 0.5) {
                    blockCodeInput("단단한지옥석");
                }
                else if(rand < 0.2) {
                    blockCodeInput("불타는화염");
                }
            } 
            else {
                // 동굴 내부는 빈 공간
                blockCodeInput("하늘");
            }
        }
    }
});
//웅덩이
// 물 웅덩이들
const waterPonds = [
  { x: waterSmallX, y: waterSmallY, w: waterSmallWidth, h: waterSmallHeight },
  { x: waterMediumX, y: waterMediumY, w: waterMediumWidth, h: waterMediumHeight },
  { x: waterLargeX, y: waterLargeY, w: waterLargeWidth, h: waterLargeHeight }
];

for (const pond of waterPonds) {
  if (yLoc >= pond.y && yLoc < pond.y + pond.h && xLoc >= pond.x && xLoc < pond.x + pond.w) {
    const centerX = pond.x + pond.w / 2;
    const centerY = pond.y + pond.h / 2;
    const dx = (xLoc - centerX) / (pond.w / 2);
    const dy = (yLoc - centerY) / (pond.h / 2);
    const noise = (Math.sin(xLoc * 2.1) + Math.cos(yLoc * 1.8)) * 0.3;
    if (dx * dx + dy * dy + noise < 1) {
      blockCodeInput("물");
      return;
    }
  }
}

// 용암 웅덩이들
const lavaPonds = [
  { x: lavaSmallX, y: lavaSmallY, w: lavaSmallWidth, h: lavaSmallHeight },
  { x: lavaMediumX, y: lavaMediumY, w: lavaMediumWidth, h: lavaMediumHeight },
  { x: lavaLargeX, y: lavaLargeY, w: lavaLargeWidth, h: lavaLargeHeight }
];

for (const pond of lavaPonds) {
  if (yLoc >= pond.y && yLoc < pond.y + pond.h && xLoc >= pond.x && xLoc < pond.x + pond.w) {
    const centerX = pond.x + pond.w / 2;
    const centerY = pond.y + pond.h / 2;
    const dx = (xLoc - centerX) / (pond.w / 2);
    const dy = (yLoc - centerY) / (pond.h / 2);
    const noise = (Math.sin(xLoc * 2.1) + Math.cos(yLoc * 1.8)) * 0.3;
    if (dx * dx + dy * dy + noise < 1) {
      blockCodeInput("용암");
      return;
    }
  }
}

const oreClusters = [
  // 철광석
  { x: oreIronLargeX,  y: oreIronLargeY,  w: oreIronLargeW,  h: oreIronLargeH,  block: "철광석" },
  { x: oreIronMedX,    y: oreIronMedY,    w: oreIronMedW,    h: oreIronMedH,    block: "철광석" },
  { x: oreIronSmallX,  y: oreIronSmallY,  w: oreIronSmallW,  h: oreIronSmallH,  block: "철광석" },

  // 루비
  { x: oreRubyLargeX,  y: oreRubyLargeY,  w: oreRubyLargeW,  h: oreRubyLargeH,  block: "루비" },
  { x: oreRubyMedX,    y: oreRubyMedY,    w: oreRubyMedW,    h: oreRubyMedH,    block: "루비" },
  { x: oreRubySmallX,  y: oreRubySmallY,  w: oreRubySmallW,  h: oreRubySmallH,  block: "루비" },

  // 에메랄드
  { x: oreEmeraldLargeX,  y: oreEmeraldLargeY,  w: oreEmeraldLargeW,  h: oreEmeraldLargeH,  block: "에메랄드" },
  { x: oreEmeraldMedX,    y: oreEmeraldMedY,    w: oreEmeraldMedW,    h: oreEmeraldMedH,    block: "에메랄드" },
  { x: oreEmeraldSmallX,  y: oreEmeraldSmallY,  w: oreEmeraldSmallW,  h: oreEmeraldSmallH,  block: "에메랄드" },

  // 다이아몬드
  { x: oreDiamondLargeX,  y: oreDiamondLargeY,  w: oreDiamondLargeW,  h: oreDiamondLargeH,  block: "다이아" },
  { x: oreDiamondMedX,    y: oreDiamondMedY,    w: oreDiamondMedW,    h: oreDiamondMedH,    block: "다이아" },
  { x: oreDiamondSmallX,  y: oreDiamondSmallY,  w: oreDiamondSmallW,  h: oreDiamondSmallH,  block: "다이아" }
];

for (const cluster of oreClusters) {
  if (
    yLoc >= cluster.y && yLoc < cluster.y + cluster.h &&
    xLoc >= cluster.x && xLoc < cluster.x + cluster.w
  ) {
    const centerX = cluster.x + cluster.w / 2;
    const centerY = cluster.y + cluster.h / 2;
    const dx = (xLoc - centerX) / (cluster.w / 2);
    const dy = (yLoc - centerY) / (cluster.h / 2);
    const noise = (Math.sin(xLoc * 1.3) + Math.cos(yLoc * 1.3)) * 0.3;

    if (dx * dx + dy * dy + noise < 1) {
      blockCodeInput(cluster.block);
      return;
    }
  }
}

/////////////////
if(yLoc>=(60+ranUp/2)&&yLoc<=150){

        if(ran>3.85&&ran<5.8){
           blockCodeInput("철광석");
        }
        if(ran>3.3&&ran<3.45){
           blockCodeInput("상자");
        }
        if(ran>3.25&&ran<3.3){
           blockCodeInput("폭탄");
        }
    if(yLoc>=(100-ranDown)&&yLoc<(100+ranUp)){
    if(ran>=2.63&&ran<3.2){
           blockCodeInput("에메랄드");
    }
    if(ran>2.56&&ran<2.63){
           blockCodeInput("정글상자");
        }
    }

    }
    if(yLoc>(110-ranDown)&&yLoc<150){
        if(ran>=1.5&&ran<2){
            blockCodeInput("다이아");
        }
        if(ran>1.45&&ran<1.5){
            blockCodeInput("황금상자");
            }
        }

        if(yLoc>=150&&yLoc<200){
        if(ran>1.37&&ran<1.4){
           blockCodeInput("흑요석상자");
        }
        if(ran>1.35&&ran<1.37){
           blockCodeInput("TNT_VER2");
        }
        if(ran>1.30&&ran<1.32){
           blockCodeInput("TNT");
        }
        }











        const validBlocks = [
  "던전블록1", "던전블록2", "던전블록3", "던전블록4",
  "밧줄", "하늘", "플랫폼", "상자", "정글상자", "황금상자",
  "흑요석상자", "고대의상자", "하늘상자", "스타트패키지",
  "철광석", "루비", "에메랄드", "다이아", "던전가시", "거미줄",
  "연기", "조약돌", "횃불", "크리스탈블럭"
];

const boxTypes = ["상자", "정글상자", "황금상자", "흑요석상자", "고대의상자", "하늘상자", "스타트패키지"];
const wallBlocks = ["던전블록1", "던전블록2", "던전블록3", "던전블록4"];


const structures = {
goldenAltar: {
  origin: structureOrigins.goldenAltar,
  blocks: [
    // 0층: 기단 (11블록 폭)
    { dx: -5, dy: 0, block: "화강암" }, { dx: -4, dy: 0, block: "화강암" }, { dx: -3, dy: 0, block: "화강암" },
    { dx: -2, dy: 0, block: "화강암" }, { dx: -1, dy: 0, block: "화강암" }, { dx: 0, dy: 0, block: "화강암" },
    { dx: 1, dy: 0, block: "화강암" }, { dx: 2, dy: 0, block: "화강암" }, { dx: 3, dy: 0, block: "화강암" },
    { dx: 4, dy: 0, block: "화강암" }, { dx: 5, dy: 0, block: "화강암" },

    // 1층: 계단식 장식 (9블록 폭)
    { dx: -4, dy: 1, block: "조약돌" }, { dx: -3, dy: 1, block: "다이아" }, { dx: -2, dy: 1, block: "에메랄드" },
    { dx: -1, dy: 1, block: "루비" }, { dx: 0, dy: 1, block: "상자" }, { dx: 1, dy: 1, block: "루비" },
    { dx: 2, dy: 1, block: "에메랄드" }, { dx: 3, dy: 1, block: "다이아" }, { dx: 4, dy: 1, block: "조약돌" },

    // 2층: 보석 장식 (7블록 폭)
    { dx: -3, dy: 2, block: "에메랄드" }, { dx: -2, dy: 2, block: "루비" }, { dx: -1, dy: 2, block: "정글상자" },
    { dx: 0, dy: 2, block: "에메랄드" }, { dx: 1, dy: 2, block: "정글상자" }, { dx: 2, dy: 2, block: "루비" }, { dx: 3, dy: 2, block: "에메랄드" },

    // 3층: 중앙부 (5블록 폭)
    { dx: -2, dy: 3, block: "조약돌" }, { dx: -1, dy: 3, block: "에메랄드" }, { dx: 0, dy: 3, block: "황금상자" },
    { dx: 1, dy: 3, block: "에메랄드" }, { dx: 2, dy: 3, block: "조약돌" },

    // 4층: 화염 장식
    { dx: -1, dy: 4, block: "불타는화염" }, { dx: 0, dy: 4, block: "불타는화염" }, { dx: 1, dy: 4, block: "불타는화염" },

    // 5층: 상단 장식
    { dx: 0, dy: 5, block: "베드락" },
    { dx: -1, dy: 6, block: "크리스탈블럭" }, { dx: 0, dy: 6, block: "무지개블럭" }, { dx: 1, dy: 6, block: "크리스탈블럭" },

    // 6~7층: 첨탑(뾰족하게)
    { dx: 0, dy: 7, block: "크리스탈블럭" },
    { dx: 0, dy: 8, block: "불타는화염" },

    // 좌우 기둥
    { dx: -5, dy: 1, block: "화강암" }, { dx: -5, dy: 2, block: "화강암" }, { dx: -5, dy: 3, block: "화강암" }, { dx: -5, dy: 4, block: "화강암" },
    { dx: 5, dy: 1, block: "화강암" }, { dx: 5, dy: 2, block: "화강암" }, { dx: 5, dy: 3, block: "화강암" }, { dx: 5, dy: 4, block: "화강암" },

    // 꼭대기 좌우 횃불
    { dx: -5, dy: 5, block: "횃불" }, { dx: 5, dy: 5, block: "횃불" }
  ]
},
  

  skyTower: {
  origin: structureOrigins.skyTower,
  blocks: [
    // 확장된 기초부 (7블록 폭)
    { dx: -3, dy: 0, block: "구름" }, { dx: -2, dy: 0, block: "흐린구름" },
    { dx: -1, dy: 0, block: "유리" }, { dx: 0, dy: 0, block: "크리스탈블럭" },
    { dx: 1, dy: 0, block: "유리" }, { dx: 2, dy: 0, block: "흐린구름" }, { dx: 3, dy: 0, block: "구름" },

    // 1층 주탑 (5블록 폭)
    { dx: -2, dy: 1, block: "유리" }, { dx: -1, dy: 1, block: "에메랄드" },
    { dx: 0, dy: 1, block: "크리스탈블럭" }, { dx: 1, dy: 1, block: "에메랄드" }, { dx: 2, dy: 1, block: "유리" },

    // 2층 보조 구조물
    { dx: -2, dy: 2, block: "구름" }, { dx: -1, dy: 2, block: "유리" },
    { dx: 0, dy: 2, block: "크리스탈블럭" }, { dx: 1, dy: 2, block: "유리" }, { dx: 2, dy: 2, block: "구름" },

    // 3층 확장 플랫폼
    { dx: -3, dy: 3, block: "다이아" }, { dx: -2, dy: 3, block: "에메랄드" }, 
    { dx: -1, dy: 3, block: "유리" }, { dx: 0, dy: 3, block: "크리스탈블럭" },
    { dx: 1, dy: 3, block: "유리" }, { dx: 2, dy: 3, block: "에메랄드" }, { dx: 3, dy: 3, block: "다이아" },

    // 4층 회전 장식
    { dx: -1, dy: 4, block: "루비" }, { dx: 0, dy: 4, block: "플랫폼" }, { dx: 1, dy: 4, block: "루비" },
    { dx: -2, dy: 5, block: "유리" }, { dx: 0, dy: 5, block: "크리스탈블럭" }, { dx: 2, dy: 5, block: "유리" },

    // 5~7층 주탑
    { dx: -1, dy: 6, block: "유리" }, { dx: 0, dy: 6, block: "크리스탈블럭" }, { dx: 1, dy: 6, block: "유리" },
    { dx: 0, dy: 7, block: "크리스탈블럭" }, 
    { dx: 0, dy: 8, block: "크리스탈블럭" },

    // 측면 횃불 장식
    { dx: -3, dy: 3, block: "횃불" }, { dx: 3, dy: 3, block: "횃불" },
    { dx: -4, dy: 4, block: "횃불" }, { dx: 4, dy: 4, block: "횃불" },
    { dx: -3, dy: 7, block: "횃불" }, { dx: 3, dy: 7, block: "횃불" },

    // 8~12층 첨탑 기단
    { dx: -2, dy: 9, block: "유리" }, { dx: -1, dy: 9, block: "크리스탈블럭" },
    { dx: 0, dy: 9, block: "플랫폼" }, { dx: 1, dy: 9, block: "크리스탈블럭" }, { dx: 2, dy: 9, block: "유리" },

    // 13~17층 세부 첨탑
    { dx: -1, dy:10, block: "크리스탈블럭" }, { dx: 0, dy:10, block: "유리" }, { dx: 1, dy:10, block: "크리스탈블럭" },
    { dx: 0, dy:11, block: "크리스탈블럭" }, 
    { dx: 0, dy:12, block: "유리" },
    { dx: -1, dy:13, block: "무지개블럭" }, { dx: 0, dy:13, block: "크리스탈블럭" }, { dx: 1, dy:13, block: "무지개블럭" },

    // 18~20층 최상단
    { dx: 0, dy:14, block: "단단한얼음" }, { dx: 0, dy:15, block: "신비한블럭" }, 
    { dx: 0, dy:16, block: "크리스탈블럭" },

    // 공중 부유 장식
    { dx: -5, dy: 5, block: "구름" }, { dx: 5, dy: 5, block: "구름" },
    { dx: -4, dy: 8, block: "흐린구름" }, { dx: 4, dy: 8, block: "흐린구름" },
    { dx: 0, dy:17, block: "플랫폼" }
  ]
},

hellShrine: {
  origin: structureOrigins.hellShrine,
  blocks: [
    // 0층: 지옥석 기단 (7블록 폭)
    { dx: -3, dy: 0, block: "지옥석" }, { dx: -2, dy: 0, block: "지옥석" }, { dx: -1, dy: 0, block: "지옥석" },
    { dx: 0, dy: 0, block: "지옥석" }, { dx: 1, dy: 0, block: "지옥석" }, { dx: 2, dy: 0, block: "지옥석" }, { dx: 3, dy: 0, block: "지옥석" },

    // 1층: 흑요석 벽과 화염, 밧줄 횃불
    { dx: -3, dy: 1, block: "흑요석" }, { dx: -2, dy: 1, block: "흑요석" }, { dx: -1, dy: 1, block: "흑요석" },
    { dx: 0, dy: 1, block: "불타는화염" }, { dx: 1, dy: 1, block: "흑요석" }, { dx: 2, dy: 1, block: "흑요석" }, { dx: 3, dy: 1, block: "흑요석" },
    // 좌우 밧줄+횃불
    { dx: -4, dy: 1, block: "밧줄" }, { dx: -4, dy: 2, block: "횃불" },
    { dx: 4, dy: 1, block: "밧줄" }, { dx: 4, dy: 2, block: "횃불" },

    // 2층: 지옥석/화염/베드락, 밧줄 횃불
    { dx: -2, dy: 2, block: "지옥석" }, { dx: 0, dy: 2, block: "베드락" }, { dx: 2, dy: 2, block: "지옥석" },
    // 좌우 밧줄+횃불
    { dx: -3, dy: 2, block: "밧줄" }, { dx: -3, dy: 3, block: "횃불" },
    { dx: 3, dy: 2, block: "밧줄" }, { dx: 3, dy: 3, block: "횃불" },

    // 3층: 신전 중앙부, 핏빛돌, 신비한블럭
    { dx: -1, dy: 3, block: "핏빛돌" }, { dx: 0, dy: 3, block: "신비한블럭" }, { dx: 1, dy: 3, block: "핏빛돌" },
    // 측면 첨탑
    { dx: -2, dy: 3, block: "흑요석" }, { dx: 2, dy: 3, block: "흑요석" },

    // 4층: 베드락 첨탑, 밧줄 횃불
    { dx: 0, dy: 4, block: "베드락" },
    { dx: -2, dy: 4, block: "밧줄" }, { dx: -2, dy: 5, block: "횃불" },
    { dx: 2, dy: 4, block: "밧줄" }, { dx: 2, dy: 5, block: "횃불" },

    // 5층: 플랫폼, 신비한 블럭 장식
    { dx: 0, dy: 5, block: "플랫폼" },
    { dx: -1, dy: 5, block: "신비한블럭" }, { dx: 1, dy: 5, block: "신비한블럭" },

    // 6~8층: 첨탑(점점 뾰족하게)
    { dx: 0, dy: 6, block: "핏빛돌" },
    { dx: 0, dy: 7, block: "불타는화염" },
    { dx: 0, dy: 8, block: "크리스탈블럭" },


    // -1층: 용암 못과 장식
    { dx: -2, dy: -1, block: "용암" }, { dx: -1, dy: -1, block: "용암" }, { dx: 0, dy: -1, block: "용암" },
    { dx: 1, dy: -1, block: "용암" }, { dx: 2, dy: -1, block: "용암" },
    // -2층: 용암 확장
    { dx: -1, dy: -2, block: "용암" }, { dx: 0, dy: -2, block: "용암" }, { dx: 1, dy: -2, block: "용암" },

    // 하단 장식: 핏빛돌, 밧줄 횃불
    { dx: -3, dy: -1, block: "핏빛돌" }, { dx: 3, dy: -1, block: "핏빛돌" },
    { dx: -2, dy: -2, block: "밧줄" }, { dx: -2, dy: -3, block: "횃불" },
    { dx: 2, dy: -2, block: "밧줄" }, { dx: 2, dy: -3, block: "횃불" }
  ]
},


 rainbowGarden: {
  origin: structureOrigins.rainbowGarden,
  blocks: [
    // 0층: 무지개 기단 (9블록 폭, 좌우 대칭)
    { dx: -4, dy: 0, block: "무지개블럭" }, { dx: -3, dy: 0, block: "루비" }, { dx: -2, dy: 0, block: "에메랄드" },
    { dx: -1, dy: 0, block: "다이아" }, { dx: 0, dy: 0, block: "크리스탈블럭" }, { dx: 1, dy: 0, block: "다이아" },
    { dx: 2, dy: 0, block: "에메랄드" }, { dx: 3, dy: 0, block: "루비" }, { dx: 4, dy: 0, block: "무지개블럭" },

    // 1층: 벌통과 꿀블럭, 플랫폼
    { dx: -3, dy: 1, block: "벌통" }, { dx: -2, dy: 1, block: "꿀블럭" }, { dx: -1, dy: 1, block: "벌통" },
    { dx: 0, dy: 1, block: "플랫폼" }, { dx: 1, dy: 1, block: "벌통" }, { dx: 2, dy: 1, block: "꿀블럭" }, { dx: 3, dy: 1, block: "벌통" },

    // 2층: 나무와 제작나무, 조약돌로 화단 느낌
    { dx: -4, dy: 2, block: "나무" }, { dx: -2, dy: 2, block: "제작나무" }, { dx: 0, dy: 2, block: "나무" },
    { dx: 2, dy: 2, block: "제작나무" }, { dx: 4, dy: 2, block: "나무" },
    { dx: -3, dy: 2, block: "조약돌" }, { dx: 3, dy: 2, block: "조약돌" },

    // 3층: 나뭇잎, 페이퍼나뭇잎, 조약돌로 캐노피
    { dx: -4, dy: 3, block: "페이퍼나뭇잎" }, { dx: -3, dy: 3, block: "나뭇잎" }, { dx: -2, dy: 3, block: "페이퍼나뭇잎" },
    { dx: -1, dy: 3, block: "나뭇잎" }, { dx: 0, dy: 3, block: "조약돌" }, { dx: 1, dy: 3, block: "나뭇잎" },
    { dx: 2, dy: 3, block: "페이퍼나뭇잎" }, { dx: 3, dy: 3, block: "나뭇잎" }, { dx: 4, dy: 3, block: "페이퍼나뭇잎" },

    // 4층: 상층 나뭇잎과 보석 장식
    { dx: -3, dy: 4, block: "페이퍼나뭇잎" }, { dx: -1, dy: 4, block: "에메랄드" }, { dx: 0, dy: 4, block: "루비" },
    { dx: 1, dy: 4, block: "에메랄드" }, { dx: 3, dy: 4, block: "페이퍼나뭇잎" },

    // 5층: 중앙 분수(물, 크리스탈블럭)와 횃불
    { dx: 0, dy: 5, block: "물" },
    { dx: -1, dy: 5, block: "크리스탈블럭" }, { dx: 1, dy: 5, block: "크리스탈블럭" },
    { dx: -2, dy: 5, block: "횃불" }, { dx: 2, dy: 5, block: "횃불" },

    // 6층: 무지개 첨탑과 플랫폼, 좌우 횃불
    { dx: 0, dy: 6, block: "무지개블럭" },
    { dx: 0, dy: 7, block: "플랫폼" },
    { dx: -1, dy: 7, block: "횃불" }, { dx: 1, dy: 7, block: "횃불" },

    // 7층: 꼭대기 크리스탈 장식
    { dx: 0, dy: 8, block: "크리스탈블럭" },

    // 바깥 꽃밭(잔디, 흙)
    { dx: -5, dy: 1, block: "잔디" }, { dx: 5, dy: 1, block: "잔디" },
    { dx: -5, dy: 0, block: "흙" }, { dx: 5, dy: 0, block: "흙" }
  ]
},


  
iceCastle: {
  origin: structureOrigins.iceCastle,
  blocks: [
    // 0층: 성 기단 (넓은 기초)
    { dx: -4, dy: 0, block: "눈" }, { dx: -3, dy: 0, block: "얼음" }, { dx: -2, dy: 0, block: "단단한얼음" },
    { dx: -1, dy: 0, block: "눈블럭" }, { dx: 0, dy: 0, block: "크리스탈블럭" }, { dx: 1, dy: 0, block: "눈블럭" },
    { dx: 2, dy: 0, block: "단단한얼음" }, { dx: 3, dy: 0, block: "얼음" }, { dx: 4, dy: 0, block: "눈" },

    // 1층: 성벽과 문, 횃불
    { dx: -4, dy: 1, block: "얼음" }, { dx: -3, dy: 1, block: "유리" }, { dx: -2, dy: 1, block: "얼음" },
    { dx: -1, dy: 1, block: "눈블럭" }, { dx: 0, dy: 1, block: "우주하늘" }, { dx: 1, dy: 1, block: "눈블럭" },
    { dx: 2, dy: 1, block: "얼음" }, { dx: 3, dy: 1, block: "유리" }, { dx: 4, dy: 1, block: "얼음" },
    // 문 위 상단
    { dx: 0, dy: 2, block: "열린문상단" },
    // 입구 양옆 횃불
    { dx: -1, dy: 1, block: "횃불" }, { dx: 1, dy: 1, block: "횃불" },

    // 2층: 성벽과 창문, 횃불
    { dx: -3, dy: 2, block: "유리" }, { dx: -2, dy: 2, block: "단단한얼음" }, { dx: -1, dy: 2, block: "유리" },
    { dx: 0, dy: 2, block: "크리스탈블럭" }, { dx: 1, dy: 2, block: "유리" }, { dx: 2, dy: 2, block: "단단한얼음" }, { dx: 3, dy: 2, block: "유리" },
    // 2층 외벽 횃불
    { dx: -3, dy: 2, block: "횃불" }, { dx: 3, dy: 2, block: "횃불" },

    // 3층: 탑 구조와 창문
    { dx: -2, dy: 3, block: "유리" }, { dx: -1, dy: 3, block: "크리스탈블럭" }, { dx: 0, dy: 3, block: "단단한얼음" },
    { dx: 1, dy: 3, block: "크리스탈블럭" }, { dx: 2, dy: 3, block: "유리" },

    // 4층: 첨탑
    { dx: -1, dy: 4, block: "크리스탈블럭" }, { dx: 0, dy: 4, block: "눈블럭" }, { dx: 1, dy: 4, block: "크리스탈블럭" },

    // 5층: 첨탑 꼭대기
    { dx: 0, dy: 5, block: "크리스탈블럭" },
    { dx: 0, dy: 6, block: "플랫폼" },
    { dx: 0, dy: 7, block: "무지개블럭" },

    // 좌우 망루(외벽 돌출)
    { dx: -5, dy: 1, block: "눈" }, { dx: -5, dy: 2, block: "유리" }, { dx: -5, dy: 3, block: "크리스탈블럭" },
    { dx: 5, dy: 1, block: "눈" }, { dx: 5, dy: 2, block: "유리" }, { dx: 5, dy: 3, block: "크리스탈블럭" },
    // 망루 위 횃불
    { dx: -5, dy: 4, block: "횃불" }, { dx: 5, dy: 4, block: "횃불" },

    // 빙하 장식(외곽)
    { dx: -6, dy: 0, block: "눈" }, { dx: -6, dy: 1, block: "눈" },
    { dx: 6, dy: 0, block: "눈" }, { dx: 6, dy: 1, block: "눈" },

    // 하단 얼음 정원
    { dx: -3, dy: -1, block: "눈" }, { dx: -1, dy: -1, block: "얼음" }, { dx: 1, dy: -1, block: "얼음" }, { dx: 3, dy: -1, block: "눈" },
    { dx: -2, dy: -2, block: "눈" }, { dx: 2, dy: -2, block: "눈" },

    // 성문 앞 계단(조약돌)
    { dx: 0, dy: -2, block: "조약돌" },
    { dx: 0, dy: -3, block: "조약돌" }
  ]
},

desertTemple: {
  origin: structureOrigins.desertTemple,
  blocks: [
    // 0층: 피라미드 기단 (9블록 폭)
    { dx: -4, dy: 0, block: "모래벽돌" }, { dx: -3, dy: 0, block: "사암" }, 
    { dx: -2, dy: 0, block: "모래" }, { dx: -1, dy: 0, block: "사암" }, 
    { dx: 0, dy: 0, block: "모래벽돌" }, { dx: 1, dy: 0, block: "사암" }, 
    { dx: 2, dy: 0, block: "모래" }, { dx: 3, dy: 0, block: "사암" }, 
    { dx: 4, dy: 0, block: "모래벽돌" },

    // 1층: 신전 본관
    { dx: -3, dy: 1, block: "모래벽돌" }, { dx: -2, dy: 1, block: "선인장" }, 
    { dx: -1, dy: 1, block: "선인장곡괭이" }, { dx: 0, dy: 1, block: "황금상자" }, 
    { dx: 1, dy: 1, block: "포션" }, { dx: 2, dy: 1, block: "선인장" }, 
    { dx: 3, dy: 1, block: "모래벽돌" },

    // 2층: 계단식 구조
    { dx: -2, dy: 2, block: "사암" }, { dx: -1, dy: 2, block: "모래벽돌" }, 
    { dx: 0, dy: 2, block: "조약돌" }, { dx: 1, dy: 2, block: "모래벽돌" }, 
    { dx: 2, dy: 2, block: "사암" },

    // 3층: 보물 방
    { dx: -1, dy: 3, block: "황금상자" }, { dx: 0, dy: 3, block: "동트로피" }, 
    { dx: 1, dy: 3, block: "황금상자" },

    // 4층: 첨탑 기단
    { dx: 0, dy: 4, block: "플랫폼" },
    { dx: -1, dy: 5, block: "액자" }, { dx: 1, dy: 5, block: "액자" },

    // 좌우 오벨리스크 (동트로피 장식)
    { dx: -5, dy: 1, block: "사암" }, { dx: -5, dy: 2, block: "사암" }, 
    { dx: -5, dy: 3, block: "모래벽돌" }, { dx: -5, dy: 4, block: "동트로피" },
    { dx: 5, dy: 1, block: "사암" }, { dx: 5, dy: 2, block: "사암" }, 
    { dx: 5, dy: 3, block: "모래벽돌" }, { dx: 5, dy: 4, block: "동트로피" },

    // 스핑크스 구조 (황금상자 추가)
    { dx: -6, dy: 0, block: "모래" }, { dx: -6, dy: 1, block: "모래벽돌" }, 
    { dx: -6, dy: 2, block: "황금상자" },
    { dx: 6, dy: 0, block: "모래" }, { dx: 6, dy: 1, block: "모래벽돌" }, 
    { dx: 6, dy: 2, block: "황금상자" },

    // 내부 장식
    { dx: -4, dy: 2, block: "횃불" }, { dx: 4, dy: 2, block: "횃불" },
    { dx: -3, dy: 3, block: "동트로피" }, { dx: 3, dy: 3, block: "동트로피" },

    // 최상층 신비 구슬
    { dx: 0, dy: 6, block: "신비한블럭" },
    { dx: -1, dy: 7, block: "횃불" }, { dx: 1, dy: 7, block: "횃불" }
  ]
},

jungleTotem: {
  origin: structureOrigins.jungleTotem,
  blocks: [
    // 0층: 기단(플랫폼, 잔디, 나무)
    { dx: -2, dy: 0, block: "잔디" }, { dx: -1, dy: 0, block: "나무" }, { dx: 0, dy: 0, block: "플랫폼" }, { dx: 1, dy: 0, block: "나무" }, { dx: 2, dy: 0, block: "잔디" },

    // 1층: 토템 기둥, 밧줄, 상자
    { dx: 0, dy: 1, block: "제작나무" },
    { dx: -1, dy: 1, block: "밧줄" }, { dx: 1, dy: 1, block: "밧줄" },
    { dx: -2, dy: 1, block: "상자" }, { dx: 2, dy: 1, block: "정글상자" },

    // 2층: 토템 기둥, 벌통, 꿀블럭, 거미줄, 나뭇잎
    { dx: 0, dy: 2, block: "벌통" },
    { dx: -1, dy: 2, block: "꿀블럭" }, { dx: 1, dy: 2, block: "꿀블럭" },
    { dx: -2, dy: 2, block: "거미줄" }, { dx: 2, dy: 2, block: "거미줄" },
    { dx: -3, dy: 2, block: "나뭇잎" }, { dx: 3, dy: 2, block: "나뭇잎" },

    // 3층: 토템 기둥, 제작나무, 나뭇잎, 페이퍼나뭇잎, 횃불
    { dx: 0, dy: 3, block: "제작나무" },
    { dx: -1, dy: 3, block: "나뭇잎" }, { dx: 1, dy: 3, block: "나뭇잎" },
    { dx: -2, dy: 3, block: "페이퍼나뭇잎" }, { dx: 2, dy: 3, block: "페이퍼나뭇잎" },
    { dx: -1, dy: 4, block: "철검" }, { dx: 1, dy: 4, block: "철활" },

    // 4층: 토템 기둥, 나무, 나뭇잎, 거미줄
    { dx: 0, dy: 4, block: "나무" },
    { dx: -1, dy: 5, block: "나뭇잎" }, { dx: 1, dy: 5, block: "나뭇잎" },
    { dx: -2, dy: 5, block: "거미줄" }, { dx: 2, dy: 5, block: "거미줄" },

    // 5층: 크리스탈블럭, 플랫폼, 밧줄, 횃불
    { dx: 0, dy: 6, block: "조약돌" },
    { dx: 0, dy: 7, block: "플랫폼" },
    { dx: -1, dy: 7, block: "밧줄" }, { dx: 1, dy: 7, block: "밧줄" },
    { dx: -2, dy: 7, block: "횃불" }, { dx: 2, dy: 7, block: "횃불" },

    // 6층: 토템 머리(무지개블럭), 양옆 크리스탈, 신성한 불꽃
    { dx: -1, dy: 8, block: "나무" }, { dx: 0, dy: 8, block: "나무" }, { dx: 1, dy: 8, block: "나무" },
    { dx: 0, dy: 9, block: "고대의상자" }
  ]
},

  
  obsidianGate: {
    origin: structureOrigins.obsidianGate,
    blocks: [
      // 흑요석 기단 (넓은 문)
      { dx: -4, dy: 0, block: "흑요석" }, { dx: -3, dy: 0, block: "흑요석" }, { dx: -2, dy: 0, block: "흑요석" },
      { dx: -1, dy: 0, block: "흑요석" }, { dx: 0, dy: 0, block: "흑요석" }, { dx: 1, dy: 0, block: "흑요석" },
      { dx: 2, dy: 0, block: "흑요석" }, { dx: 3, dy: 0, block: "흑요석" }, { dx: 4, dy: 0, block: "흑요석" },
      
      // 문기둥 (좌측)
      { dx: -4, dy: 1, block: "흑요석" }, { dx: -4, dy: 2, block: "흑요석" }, { dx: -4, dy: 3, block: "흑요석" },
      { dx: -4, dy: 4, block: "흑요석" }, { dx: -4, dy: 5, block: "흑요석" },
      
      // 문기둥 (우측)
      { dx: 4, dy: 1, block: "흑요석" }, { dx: 4, dy: 2, block: "흑요석" }, { dx: 4, dy: 3, block: "흑요석" },
      { dx: 4, dy: 4, block: "흑요석" }, { dx: 4, dy: 5, block: "흑요석" },
      
      // 문 상단 아치
      { dx: -3, dy: 5, block: "흑요석" }, { dx: -2, dy: 6, block: "흑요석" }, { dx: -1, dy: 6, block: "흑요석" },
      { dx: 0, dy: 6, block: "흑요석" }, { dx: 1, dy: 6, block: "흑요석" }, { dx: 2, dy: 6, block: "흑요석" }, { dx: 3, dy: 5, block: "흑요석" },
      
      // 화염 장식 (기둥 상단)
      { dx: -4, dy: 6, block: "불타는화염" }, { dx: 4, dy: 6, block: "불타는화염" },
      
      
      // 신비한 블록 장식
      { dx: -2, dy: 1, block: "신비한블럭" }, { dx: 2, dy: 1, block: "신비한블럭" },
      { dx: -1, dy: 2, block: "신비한블럭" }, { dx: 1, dy: 2, block: "신비한블럭" },
      { dx: 0, dy: 3, block: "크리스탈블럭" },
      
      // 포털 중앙부
      { dx: -1, dy: 1, block: "베드락" }, { dx: 0, dy: 1, block: "베드락" }, { dx: 1, dy: 1, block: "베드락" },
      { dx: 0, dy: 2, block: "베드락" },
      
      // 지옥문 효과
      { dx: -2, dy: 2, block: "용암" }, { dx: 2, dy: 2, block: "용암" },
      { dx: -1, dy: 4, block: "용암" }, { dx: 1, dy: 4, block: "용암" },
      
      // 꼭대기 플랫폼
      { dx: 0, dy: 7, block: "플랫폼" },
      
      // 최상단 장식
      { dx: -1, dy: 8, block: "핏빛돌" }, { dx: 0, dy: 8, block: "불타는화염" }, { dx: 1, dy: 8, block: "핏빛돌" }
    ]
  },
  
  floatingRing: {
    origin: structureOrigins.floatingRing,
    blocks: [
      // 대형 원형 링 구조 (외곽)
      { dx: -5, dy: 0, block: "크리스탈블럭" }, { dx: -4, dy: -1, block: "에메랄드" }, { dx: -3, dy: -2, block: "무지개블럭" },
      { dx: -2, dy: -2, block: "다이아" }, { dx: -1, dy: -2, block: "플랫폼" }, { dx: 0, dy: -2, block: "크리스탈블럭" },
      { dx: 1, dy: -2, block: "플랫폼" }, { dx: 2, dy: -2, block: "다이아" }, { dx: 3, dy: -2, block: "무지개블럭" },
      { dx: 4, dy: -1, block: "에메랄드" }, { dx: 5, dy: 0, block: "크리스탈블럭" },
      
      // 원형 링 (중간층)
      { dx: -4, dy: 0, block: "에메랄드" }, { dx: -3, dy: -1, block: "무지개블럭" }, { dx: -2, dy: -1, block: "다이아" },
      { dx: -1, dy: -1, block: "무지개블럭" }, { dx: 0, dy: -1, block: "플랫폼" }, { dx: 1, dy: -1, block: "무지개블럭" },
      { dx: 2, dy: -1, block: "다이아" }, { dx: 3, dy: -1, block: "무지개블럭" }, { dx: 4, dy: 0, block: "에메랄드" },
      
      // 원형 링 (내부)
      { dx: -3, dy: 0, block: "무지개블럭" }, { dx: -2, dy: 0, block: "에메랄드" }, { dx: -1, dy: 0, block: "다이아" },
      { dx: 0, dy: 0, block: "플랫폼" }, { dx: 1, dy: 0, block: "다이아" }, { dx: 2, dy: 0, block: "에메랄드" }, { dx: 3, dy: 0, block: "무지개블럭" },
      
      // 수직 링 구조
      { dx: 0, dy: -3, block: "크리스탈블럭" }, { dx: 0, dy: -4, block: "무지개블럭" },
      { dx: 0, dy: 1, block: "다이아" }, { dx: 0, dy: 2, block: "에메랄드" }, { dx: 0, dy: 3, block: "크리스탈블럭" },
      
      // 대각선 지지대
      { dx: -2, dy: 1, block: "다이아" }, { dx: 2, dy: 1, block: "다이아" },
      { dx: -1, dy: 2, block: "에메랄드" }, { dx: 1, dy: 2, block: "에메랄드" },
      
      // 측면 부유 블록들
      { dx: -6, dy: 0, block: "구름" }, { dx: 6, dy: 0, block: "구름" },
      { dx: -5, dy: -1, block: "흐린구름" }, { dx: 5, dy: -1, block: "흐린구름" },
      { dx: -5, dy: 1, block: "포션" }, { dx: 5, dy: 1, block: "포션" },
      
      // 중앙 에너지 코어
      { dx: 0, dy: 4, block: "신비한블럭" },
      { dx: 0, dy: 5, block: "불타는화염" },
      
      // 하단 앵커 포인트
      { dx: 0, dy: -5, block: "베드락" },
      
      // 외부 궤도 링
      { dx: -7, dy: 0, block: "크리스탈블럭" }, { dx: 7, dy: 0, block: "크리스탈블럭" },
      { dx: 0, dy: -7, block: "크리스탈블럭" }, { dx: 0, dy: 7, block: "크리스탈블럭" }
    ]
  },
  
dungeonCore: {
  origin: structureOrigins.dungeonCore,
  blocks: [
    // 0층: 확장된 기단 (13블록 폭)
    { dx: -6, dy: 0, block: "던전블록1" }, { dx: -5, dy: 0, block: "던전블록2" }, 
    { dx: -4, dy: 0, block: "던전블록3" }, { dx: -3, dy: 0, block: "던전블록4" },
    { dx: -2, dy: 0, block: "던전블록3" }, { dx: -1, dy: 0, block: "던전블록4" },
    { dx: 0, dy: 0, block: "던전블록3" }, { dx: 1, dy: 0, block: "던전블록4" }, 
    { dx: 2, dy: 0, block: "던전블록3" }, { dx: 3, dy: 0, block: "던전블록4" }, 
    { dx: 4, dy: 0, block: "던전블록3" }, { dx: 5, dy: 0, block: "던전블록2" }, 
    { dx: 6, dy: 0, block: "던전블록1" },
    
    // 1층: 입구 횃불 강화
    { dx: -5, dy: 1, block: "던전블록2" }, { dx: -4, dy: 1, block: "던전가시" }, 
    { dx: -3, dy: 1, block: "흑요석" }, { dx: -2, dy: 1, block: "열린문하단" },
    { dx: -1, dy: 1, block: "불타는화염" }, { dx: 0, dy: 1, block: "던전가시" },
    { dx: 1, dy: 1, block: "불타는화염" }, { dx: 2, dy: 1, block: "열린문하단" }, 
    { dx: 3, dy: 1, block: "흑요석" }, { dx: 4, dy: 1, block: "던전가시" }, 
    { dx: 5, dy: 1, block: "던전블록2" },
    // 추가 횃불
    { dx: -6, dy: 1, block: "횃불" }, { dx: 6, dy: 1, block: "횃불" },
    
    // 2층: 복도 조명 강화
    { dx: -3, dy: 2, block: "던전블록3" }, { dx: -2, dy: 2, block: "플랫폼" }, 
    { dx: -1, dy: 2, block: "던전블록4" }, { dx: 0, dy: 2, block: "밧줄" },
    { dx: 1, dy: 2, block: "던전블록4" }, { dx: 2, dy: 2, block: "플랫폼" }, 
    { dx: 3, dy: 2, block: "던전블록3" },
    // 측면 횃불
    { dx: -4, dy: 2, block: "횃불" }, { dx: 4, dy: 2, block: "횃불" },
    
    // 3층: 보물방 장식
    { dx: -4, dy: 3, block: "상자" }, { dx: -3, dy: 3, block: "흑요석상자" }, 
    { dx: -2, dy: 3, block: "플랫폼" }, { dx: -1, dy: 3, block: "금트로피" },
    { dx: 0, dy: 3, block: "신비한블럭" }, { dx: 1, dy: 3, block: "금트로피" }, 
    { dx: 2, dy: 3, block: "플랫폼" }, { dx: 3, dy: 3, block: "흑요석상자" }, 
    { dx: 4, dy: 3, block: "상자" },
    // 천장 횃불
    { dx: -3, dy: 4, block: "횃불" }, { dx: 3, dy: 4, block: "횃불" },
    
    // 4층: 코어 접근로 조명
    { dx: -2, dy: 4, block: "던전블록4" }, { dx: -1, dy: 4, block: "흑요석" }, 
    { dx: 0, dy: 4, block: "베드락" }, { dx: 1, dy: 4, block: "흑요석" }, 
    { dx: 2, dy: 4, block: "던전블록4" },
    // 계단 횃불
    { dx: -4, dy: 4, block: "횃불" }, { dx: 4, dy: 4, block: "횃불" },
    
    // 5층: 코어 장식
    { dx: -1, dy: 5, block: "핏빛돌" }, { dx: 0, dy: 5, block: "불타는화염" }, 
    { dx: 1, dy: 5, block: "핏빛돌" }, { dx: 0, dy: 6, block: "TNT_VER2" },
    // 좌우 경계 횃불
    { dx: -4, dy: 5, block: "횃불" }, { dx: 4, dy: 5, block: "횃불" },
    
    // 지하 1층: 용암 지대 안전 조명
    { dx: -4, dy: -1, block: "용암" }, { dx: -3, dy: -1, block: "용암" }, 
    { dx: -2, dy: -1, block: "용암" }, { dx: -1, dy: -1, block: "용암" }, 
    { dx: 0, dy: -1, block: "플랫폼" }, { dx: 1, dy: -1, block: "용암" }, 
    { dx: 2, dy: -1, block: "용암" }, { dx: 3, dy: -1, block: "용암" }, 
    { dx: 4, dy: -1, block: "용암" },
    // 다리 조명
    { dx: 0, dy: -2, block: "횃불" }, { dx: 0, dy: -3, block: "횃불" },
    
    // 외벽 구조물
    { dx: -7, dy: 1, block: "던전블록1" }, { dx: -7, dy: 2, block: "던전블록1" }, 
    { dx: -7, dy: 3, block: "던전가시" }, { dx: 7, dy: 1, block: "던전블록1" }, 
    { dx: 7, dy: 2, block: "던전블록1" }, { dx: 7, dy: 3, block: "던전가시" },
    // 외벽 횃불
    { dx: -8, dy: 2, block: "횃불" }, { dx: 8, dy: 2, block: "횃불" }
  ]
},

woodenHouse: {
  origin: structureOrigins.woodenHouse, // origin이 Y=53(바닥)이라고 가정
  blocks: [
    // 바닥 (제작나무, 10x10 전체)
    { dx: -5, dy: 0, block: "제작나무" }, { dx: -4, dy: 0, block: "제작나무" }, { dx: -3, dy: 0, block: "제작나무" },
    { dx: -2, dy: 0, block: "제작나무" }, { dx: -1, dy: 0, block: "제작나무" }, { dx: 0, dy: 0, block: "제작나무" },
    { dx: 1, dy: 0, block: "제작나무" }, { dx: 2, dy: 0, block: "제작나무" }, { dx: 3, dy: 0, block: "제작나무" }, { dx: 4, dy: 0, block: "제작나무" },

    // 좌측 벽 (제작나무)
    { dx: -5, dy: -1, block: "제작나무" }, { dx: -5, dy: -2, block: "제작나무" }, { dx: -5, dy: -3, block: "제작나무" },
    { dx: -5, dy: -4, block: "제작나무" }, { dx: -5, dy: -5, block: "제작나무" }, { dx: -5, dy: -6, block: "제작나무" },

    // 우측 벽 (제작나무)
    { dx: 4, dy: -1, block: "제작나무" }, { dx: 4, dy: -2, block: "제작나무" }, { dx: 4, dy: -3, block: "제작나무" },
    { dx: 4, dy: -4, block: "제작나무" }, { dx: 4, dy: -5, block: "제작나무" }, { dx: 4, dy: -6, block: "제작나무" },

    // 앞벽 (제작나무)
    { dx: -4, dy: -6, block: "제작나무" }, { dx: -3, dy: -6, block: "제작나무" }, { dx: -2, dy: -6, block: "제작나무" },
    { dx: -1, dy: -6, block: "제작나무" }, { dx: 0, dy: -6, block: "제작나무" }, { dx: 1, dy: -6, block: "제작나무" },
    { dx: 2, dy: -6, block: "제작나무" }, { dx: 3, dy: -6, block: "제작나무" },

    // 뒷벽 (제작나무)
    { dx: -4, dy: 0, block: "제작나무" }, { dx: -3, dy: 0, block: "제작나무" }, { dx: -2, dy: 0, block: "제작나무" },
    { dx: -1, dy: 0, block: "제작나무" }, { dx: 0, dy: 0, block: "제작나무" }, { dx: 1, dy: 0, block: "제작나무" },
    { dx: 2, dy: 0, block: "제작나무" }, { dx: 3, dy: 0, block: "제작나무" },

    // 내부 공간 비우기 (하늘)
    { dx: -4, dy: -1, block: "하늘" }, { dx: -3, dy: -1, block: "하늘" }, { dx: -2, dy: -1, block: "하늘" }, { dx: -1, dy: -1, block: "하늘" },
    { dx: 0, dy: -1, block: "하늘" }, { dx: 1, dy: -1, block: "하늘" }, { dx: 2, dy: -1, block: "하늘" }, { dx: 3, dy: -1, block: "하늘" },
    { dx: -4, dy: -2, block: "하늘" }, { dx: -3, dy: -2, block: "하늘" }, { dx: -2, dy: -2, block: "하늘" }, { dx: -1, dy: -2, block: "하늘" },
    { dx: 0, dy: -2, block: "하늘" }, { dx: 1, dy: -2, block: "하늘" }, { dx: 2, dy: -2, block: "하늘" }, { dx: 3, dy: -2, block: "하늘" },
    { dx: -4, dy: -3, block: "하늘" }, { dx: -3, dy: -3, block: "하늘" }, { dx: -2, dy: -3, block: "하늘" }, { dx: -1, dy: -3, block: "하늘" },
    { dx: 0, dy: -3, block: "하늘" }, { dx: 1, dy: -3, block: "하늘" }, { dx: 2, dy: -3, block: "하늘" }, { dx: 3, dy: -3, block: "하늘" },
    { dx: -4, dy: -4, block: "하늘" }, { dx: -3, dy: -4, block: "하늘" }, { dx: -2, dy: -4, block: "하늘" }, { dx: -1, dy: -4, block: "하늘" },
    { dx: 0, dy: -4, block: "하늘" }, { dx: 1, dy: -4, block: "하늘" }, { dx: 2, dy: -4, block: "하늘" }, { dx: 3, dy: -4, block: "하늘" },
    { dx: -4, dy: -5, block: "하늘" }, { dx: -3, dy: -5, block: "하늘" }, { dx: -2, dy: -5, block: "하늘" }, { dx: -1, dy: -5, block: "하늘" },
    { dx: 0, dy: -5, block: "하늘" }, { dx: 1, dy: -5, block: "하늘" }, { dx: 2, dy: -5, block: "하늘" }, { dx: 3, dy: -5, block: "하늘" },

    // 문 (좌우 외벽)
    { dx: -5, dy: -1, block: "열린문하단" }, { dx: -5, dy: -2, block: "열린문상단" },
    { dx: 4, dy: -1, block: "열린문하단" }, { dx: 4, dy: -2, block: "열린문상단" },

    // 가구 (바닥 위 1칸, Y=52)
    { dx: -3, dy: -1, block: "조합대" }, 
    { dx: -2, dy: -1, block: "모루" }, 
    { dx: -1, dy: -1, block: "화로" },
    { dx: 1, dy: -1, block: "모닥불" },
    { dx: 2, dy: -1, block: "상자" },
    { dx: 3, dy: -1, block: "상자" },

    // 횃불 (내부 조명)
    { dx: -4, dy: -1, block: "횃불" }, 
    { dx: 0, dy: -1, block: "횃불" },
    { dx: 3, dy: -1, block: "횃불" },

    // 창문 (유리)
    { dx: -5, dy: -3, block: "유리" }, 
    { dx: 4, dy: -3, block: "유리" },

    // 굴뚝 (지붕 위)
    { dx: 0, dy: -7, block: "흑요석" }, 
    { dx: 0, dy: -8, block: "불타는화염" }
  ]
},

rockTower : {
  origin: structureOrigins.rockTower,

 blocks: [
    // 0층 기단
    ...Array.from({ length: 10 }, (_, i) => ({ dx: -5 + i, dy: 0, block: "화강암" })),

    // 1~50층
    ...Array.from({ length: 50 }, (_, layerIndex) => {
      const y = -1 - layerIndex;
      const wallBlock = wallBlocks[Math.floor(layerIndex / 13)];
      
    const boxChance = Math.max(0.08 - layerIndex * 0.003, 0.01);
      const layer = [];

      // 외벽
      layer.push({ dx: -5, dy: y, block: wallBlock });
      layer.push({ dx: 4, dy: y, block: wallBlock });

      // 중앙 밧줄
      layer.push({ dx: 0, dy: y, block: "밧줄" });

      // 내부 배치
      for (let dx = -4; dx <= 3; dx++) {
        if (dx === 0) continue;

        let block = "하늘";
        const rand = Math.random();

        if (rand < 0.3) {
          block = "하늘";
        } else if (rand < 0.5) {
          block = "플랫폼";
        } else if (rand < 0.5 + boxChance) {
          block = boxTypes[Math.min(Math.floor(layerIndex / 7), boxTypes.length - 1)];
        } else if (rand < 0.7) {
          const ores = ["철광석", "루비", "에메랄드", "다이아"];
          block = ores[Math.floor(layerIndex / 12)];
        } else if (rand < 0.85) {
          block = ["던전가시", "거미줄", "연기"][Math.floor(Math.random() * 3)];
        } else {
          block = "조약돌";
        }

        if (!validBlocks.includes(block)) block = "하늘";
        layer.push({ dx, dy: y, block });
      }

      // 맨 아래층 (입구부근)에만 횃불 배치
      if (layerIndex === 0) {
        [-4, -2, 2, 3].forEach(dx => {
          layer.push({ dx, dy: y - 1, block: "횃불" });
        });
      }

      return layer;
    }).flat(),

    // 최상층: 상자 장식
    { dx: -4, dy: -50, block: "스타트패키지" }, { dx: -3, dy: -50, block: "하늘" },
    { dx: -2, dy: -50, block: "고대의상자" }, { dx: -1, dy: -50, block: "하늘" },
    { dx: 0, dy: -50, block: "크리스탈블럭" }, { dx: 1, dy: -50, block: "하늘" },
    { dx: 2, dy: -50, block: "고대의상자" }, { dx: 3, dy: -50, block: "하늘" },
    { dx: 4, dy: -50, block: "스타트패키지" },

    // 최상층 천장 (ㅠ자)
    ...Array.from({ length: 5 }, (_, i) => ({ dx: -2 - i, dy: -51, block: "던전블록4" })),
    ...Array.from({ length: 5 }, (_, i) => ({ dx: 2 + i, dy: -51, block: "던전블록4" })),
    { dx: 0, dy: -51, block: "던전블록4" }
  ]

}


};





if (!loadedGame) {
  Object.entries(structures).forEach(([key, structure]) => {
    const origin = structure.origin;
    structure.blocks.forEach(pos => {
      const absX = origin.x + pos.dx;
      const absY = origin.y + pos.dy;

      if (xLoc === absX && yLoc === absY) {
        blockCodeInput(pos.block);
      }
    });
  });
}


////////////////////////
    }





}

///////////////////////

// ▼▼▼ 생물군계 파라미터 정의 ▼▼▼
const BIOME_DEFS = [
    { // 습지
        id: '습지',
        baseHeight: (t, noise) => 54 + t*2 + noise*2,
        depthFactor: t => 1.2 + t*1.2,
        blocks: [
            {name: "진흙", chance: 0.4},
            {name: "점토", chance: 0.4},
            {name: "물", chance: 0.6},

        ]
    },
    { // 숲
        id: '숲',

        baseHeight: (t, noise) => 55 + t*2 + noise*3,
        depthFactor: t => 1.8 + t*1.2,
        blocks: [
            {name: "나무", chance: 0.4},
            {name: "잔디", chance: 0.3},
            {name: "나뭇잎", chance: 0.3}
        ]
    },
    { // 평원
        id: '평원',
        baseHeight: (t, noise) => 55- t*1 + noise*4,
        depthFactor: t => 1.6 - t*0.3,
        blocks: [
            {name: "잔디", chance: 0.8},
            {name: "점토", chance: 0.15},
            {name: "흙", chance: 0.02}
        ]
    },
    { // 사막
        id: '사막',

        baseHeight: (t, noise) => 55 + t*2 + noise*7,
        depthFactor: t => 1.4 + t*0.8,
        blocks: [
            {name: "모래", chance: 0.6},
            {name: "사암", chance: 0.3},
            {name: "선인장", chance: 0.1}
        ]
    },

    { // 산악
        id: '산악',

        baseHeight: (t, noise) => 58+ t*3 + noise*6,
        depthFactor: t => 3.2 + t*1.8,
        blocks: [
            {name: "화강암", chance: 0.6},
            {name: "조약돌", chance: 0.25},
            {name: "철광석", chance: 0.15}
        ]
    },
    { // 황무지
        id: '황무지',

        baseHeight: (t, noise) => 56 - t*3 + noise*4,
        depthFactor: t => 2.0 - t*0.4,
        blocks: [
            {name: "재블럭", chance: 0.5},
            {name: "진흙", chance: 0.3},
            {name: "점토", chance: 0.2}
        ]
    },
    { // 설원
        id: '설원',
        baseHeight: (t, noise) => 57 - t*2 + noise*5,
        depthFactor: t =>2.4 - t*0.5,
        blocks: [
            {name: "눈", chance: 0.7},
            {name: "얼음", chance: 0.2},
            {name: "단단한얼음", chance: 0.1}
        ]
    },
    { // 화산
        id: '화산',
        baseHeight: (t, noise) => 55 + t*4 + noise*6,
        depthFactor: t => 2.5 + t*0.5,
        blocks: [
            {name: "조약돌", chance: 0.6},
            {name: "용암", chance: 0.1},
            {name: "연기", chance: 0.15},
            {name: "흑요석", chance: 0.15}
        ]
    }
];

// ▼▼▼ 생물군계 순서 셔플 ▼▼▼
function shuffleBiomes() {
    for(let i = BIOME_DEFS.length-1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i+1));
        [BIOME_DEFS[i], BIOME_DEFS[j]] = [BIOME_DEFS[j], BIOME_DEFS[i]];
    }
}
shuffleBiomes();

//https://terraria.fandom.com/wiki/Biome_backgrounds 바이옴백그라운드

// ▼▼▼ x좌표 범위 정의 ▼▼▼
const X_RANGES = [
    [30, 60],    // 구간1
    [60, 90],  // 구간2
    [90, 120], // 구간3
    [120, 143], // 구간4
    [157, 180], // 구간5
    [180, 210], // 구간6
    [210, 240], // 구간7
    [240, 270]  // 구간8
];



function checkCurrentTerrain(){
  // console.log("현재 생태계 :"+getCurrentTerrain());
   //스폰 포인트는 해당없음
}

function getCurrentTerrain() {
    const {x, y} = getCurrentCenterBlock();
    
    // X좌표 범위 검사
    const currentRange = X_RANGES.find(([min, max]) => x >= min && x <= max);
    if(!currentRange) return "스폰";
    
    // 바이옴 인덱스 매핑
    const biomeIndex = X_RANGES.indexOf(currentRange);
    const biome = BIOME_DEFS[biomeIndex];
    
    // Y좌표 기반 하위 생물군계 분류 (선택적)
    //if(biome.id === "산악" && y > 170) return "고산지대";
    //if(biome.id === "사막" && y > 150) return "사막 지하";
    //설원 습지 사막 스폰 숲 평원 황무
    return biome.id;
}


function generateTerrain(xLoc, yLoc) {
    // 현재 구간 찾기
    const range = X_RANGES.find(([min, max]) => xLoc >= min && xLoc <= max);
    if(!range) return;
    
    // 해당 구간의 생물군계 인덱스
    const biomeIndex = X_RANGES.indexOf(range);
    const biome = BIOME_DEFS[biomeIndex];
    
    // 노이즈 값 계산
    const noiseValue = terrainNoise.noise(xLoc * 0.2) * 1 - 1;
    
    // 보간 비율 계산
    const t = (xLoc - range[0]) / (range[1] - range[0]);
    
    // 고도 계산
    const baseHeight = Math.round(biome.baseHeight(t, noiseValue));
    
    // 지표면 처리
    if(yLoc === baseHeight) {
        let accum = 0;
        const rand = Math.random();
        for(const {name, chance} of biome.blocks) {
            accum += chance;
            if(rand < accum) {
                blockCodeInput(name);
                break;
            }
        }
        return;
    }
    
    // 지하층 처리
    if(yLoc > baseHeight && yLoc <= baseHeight + 150) {
        const depth = yLoc - baseHeight;
        const depthFactor = biome.depthFactor(t);
        const randVal = parseFloat((Math.random()));
        //console.log(biome.id+""+randVal);
       // console.log("biomeid"+biome.id);
        if(biome.id == "습지"){//1
        if(randVal < 0.3) blockCodeInput("점토");
        else if(randVal < 0.4) blockCodeInput("진흙");
        else if(randVal < 0.5) blockCodeInput("흙");
        else blockCodeInput("물");
        }

        else if(biome.id == "숲"){//2 
            if(randVal < 0.4) blockCodeInput("나뭇잎");
        else if(randVal < 0.7) blockCodeInput("나무");
        else if(randVal < 0.72) blockCodeInput("물");
        else if(randVal < 0.74) blockCodeInput("진흙");
        else if(randVal < 0.78) blockCodeInput("점토");
        else if(randVal < 0.785) blockCodeInput("잔디");
        else if(randVal < 0.79) blockCodeInput("밧줄");
        else blockCodeInput("흙");
        }

        else if(biome.id == "평원"){//3
            if(randVal < 0.4) blockCodeInput("잔디");
        else if(randVal < 0.45) blockCodeInput("물");
        else if(randVal < 0.6) blockCodeInput("진흙");
        else if(randVal < 0.95) blockCodeInput("점토");
        else blockCodeInput("흙");
    
        }

        else if(biome.id == "사막"){//4
            if(randVal < 0.3) blockCodeInput("모래");
            else if(randVal < 0.4) blockCodeInput("선인장");
        else if(randVal < 0.7) blockCodeInput("사암");
        else if(randVal < 0.72) blockCodeInput("조약돌");
        else if(randVal < 0.74) blockCodeInput("진흙");
        else if(randVal < 0.78) blockCodeInput("점토");
        else if(randVal < 0.79) blockCodeInput("유리");
        else blockCodeInput("모래벽돌");  
        }

        else if(biome.id == "산악"){//5
            if(randVal < 0.4) blockCodeInput("조약돌");
        else if(randVal < 0.7) blockCodeInput("철광석");
        else if(randVal < 0.74) blockCodeInput("진흙");
        else if(randVal < 0.76) blockCodeInput("흙");
        else if(randVal < 0.78) blockCodeInput("점토");
        else if(randVal < 0.8) blockCodeInput("철광석");
        else if(randVal < 0.82) blockCodeInput("거미줄");
        else blockCodeInput("철광석");
        }

        else if(biome.id == "황무지"){//6
            if(randVal < 0.4) blockCodeInput("재블럭");
        else if(randVal < 0.7) blockCodeInput("진흙");
        else if(randVal < 0.72) blockCodeInput("조약돌");
        else if(randVal < 0.74) blockCodeInput("진흙");
        else if(randVal < 0.76) blockCodeInput("흙");
        else if(randVal < 0.78) blockCodeInput("점토");
        else if(randVal < 0.8) blockCodeInput("철광석");
        else blockCodeInput("점토");  
        }

        else if(biome.id == "설원"){//7
            if(randVal < 0.3) blockCodeInput("눈");
        else if(randVal < 0.5) blockCodeInput("눈블럭");
        else if(randVal < 0.7) blockCodeInput("얼음");
        else if(randVal < 0.72) blockCodeInput("조약돌");
        else if(randVal < 0.75) blockCodeInput("물");
        else if(randVal < 0.76) blockCodeInput("에메랄드");
        else if(randVal < 0.765) blockCodeInput("다이아");
        else blockCodeInput("단단한얼음");  
        }

        else if(biome.id == "화산"){//8
            if(randVal < 0.03) blockCodeInput("용암");
        else if(randVal < 0.3) blockCodeInput("재블럭");
         else if(randVal < 0.45) blockCodeInput("화강암");
        else if(randVal < 0.55) blockCodeInput("철광석");
        else if(randVal < 0.7) blockCodeInput("조약돌");
        else if(randVal < 0.75) blockCodeInput("진흙");
        else if(randVal < 0.8) blockCodeInput("루비");
        else blockCodeInput("흑요석");
        }
        else{
//console.log("biome id예외 : "+biome.id);
        }
        /*
        else{
            if(randVal < 0.4) blockCodeInput("점토");
        else if(randVal < 0.7) blockCodeInput("진흙");
        else blockCodeInput("조약돌");
        }
      */
    }
}

////////////////////////
//해당Y좌표에 있는 모든X축 블럭 검색

function randomBlockLoopY(arrY,arrX,blockCode,blockCode2,xLoc,yLoc){
    
      
        //onsole.log(bLocateData[arrY][i].includes(blockCode));
        if(bLocateData[arrY][xLoc].includes(blockCode)==true){
                blockCodeInput("나무");
        //console.log(arrY,arrX,blockCode,blockCode2,yLoc,bLocateData[arrY][xLoc],bLocateData[arrY][xLoc].includes(blockCode));

        }else if(bLocateData[arrY][xLoc].includes(blockCode)==false){
        //console.log(arrY,arrX,blockCode,xLoc,bLocateData[arrY][xLoc],bLocateData[arrY][xLoc].includes(blockCode));

        }
           if(bLocateData[arrY][xLoc].includes(blockCode2)==true){
                blockCodeInput("나무");
        //console.log(arrY,arrX,blockCode,blockCode2,yLoc,bLocateData[arrY][xLoc],bLocateData[arrY][xLoc].includes(blockCode2));

        }else if(bLocateData[arrY][xLoc].includes(blockCode2)==false){
        //console.log(arrY,arrX,blockCode,xLoc,bLocateData[arrY][xLoc],bLocateData[arrY][xLoc].includes(blockCode));

        }
        
    

}

//블럭 캐기/ 사용 파트
let chestInputElement=null;//상자 전역변수 위치

function clickBlock(blockId, stiffness, element, inputElement, blockLocationId){

//블록 선택된 상테에서 상자를 클릭한게 아니라면  블럭이 부셔지지 않음 종료됨
if (blockSelected) {//아이탬 가방에서 블럭선택
    chestInputElement=inputElement;//상호작용버튼으로 터치 전역 변수로 위치지정 (상자용)
    useBlock2(blockLocationId); 
    return;
}

  // 신규 코드: 단일 클릭 시 한 번만 실행
  if (inputElement.innerText !== "0,0") {
    effectSound("stone");//부수는 블럭 효과음
    breakBlock(inputElement);
}

if (element.innerText === "0,0") {
    console.log("이미 파괴된 블럭입니다.");
    sounds["stone"].pause();
    return;
}


globalBlockId = "";
globalBlockPower = 0;
globalInputElement = null;

globalBlockId = inputElement.dataset.bid || blockId;
globalBlockPower = parseInt(inputElement.dataset.stiffness) || 1; //데이터셋에서 불러옴
globalInputElement = inputElement;

console.log("클릭 시 경도:", globalBlockPower);
console.log("데이터 속성 값:", inputElement.dataset.stiffness);

//console.log(inputElement.id);
var newBlockIdX=blockLocationId.slice(0,blockLocationId.indexOf(','));
var newBlockIdY=blockLocationId.slice(blockLocationId.indexOf(',')+1);


console.log("inputElement.innerText"+inputElement.innerText);//->40,1
console.log("globalBlockPower: "+globalBlockPower);//block power ->40,1 ->40
console.log("newBLockX,Y"+newBlockIdX+" "+newBlockIdY);//xy33,35중 33
console.log("blockId:"+blockId);
console.log("blockStiffness:"+stiffness);
console.log("blockLocationId:"+blockLocationId);
useBlock2(blockId,stiffness,inputElement,blockLocationId)
  timeUpStart=true;
}



var it1;
var it2;
// 블럭 파괴 함수 수정
function breakBlock(inputElement) {
   
        // 1. 원본 내구도와 현재 내구도 가져오기 (data-initial-stiffness 신규 추가)
    const initialStiffness = parseFloat(inputElement.dataset.initialStiffness) || parseFloat(inputElement.dataset.stiffness) || 1;
    let currentStiffness = parseFloat(inputElement.dataset.stiffness) || initialStiffness;
    
    // 최초 초기화 시 원본 내구도 저장
    if(!inputElement.dataset.initialStiffness) {
        inputElement.dataset.initialStiffness = initialStiffness.toString();
    }

    createBlockParticles(inputElement);

       // ▼▼▼ 표지판 제거 로직 추가 ▼▼▼
   if(inputElement.dataset.bid === "63") { // 표지판 블록인 경우
            try {
                const [x, y] = inputElement.id.replace('xy', '').split(',').map(Number);
                
                // 1. 2D 배열 데이터 삭제
                if(x >= 0 && x < SIGN_ARRAY_WIDTH && 
                   y >= 0 && y < SIGN_ARRAY_HEIGHT) {
                    signArray[x][y] = null;
                }
                
                // 2. UI 요소 제거
                const display = inputElement.querySelector('.sign-display');
                if(display) display.remove();
                
            } catch (error) {
                console.error("표지판 제거 오류:", error);
            }
        }


   // 2. 블럭 파괴 여부 체크 (0,0 대신 내구도로 판단)
    if (currentStiffness <= 0) {
        console.log("이미 파괴된 블럭입니다.");
        sounds["stone"].pause();
        return;
    }

    // 3. 내구도 감소 계산
    currentStiffness = Math.max(0, currentStiffness - power);
    
    // 4. 밝기 계산 (원본 대비 현재 비율)
    const ratio = currentStiffness / initialStiffness;
    const yPos = parseFloat(inputElement.id.split(',')[1]);

    // 5. 블럭 상태 업데이트 (항상 실행)
    inputElement.dataset.stiffness = currentStiffness;
    inputElement.innerText = `${currentStiffness},${ratio.toFixed(2)}`;

    // 6. 밝기 적용 (내구도 0 초과 시 항상 갱신)
    if(yPos > 53) {
        inputElement.style.opacity = ratio;
    } 
  else {
     inputElement.style.opacity = ratio;
  }
   

    // 7. 블럭 완전 파괴 처리 (내구도 0일 때만 실행)
    if (currentStiffness <= 0) {
        // ▼▼▼ 파괴 처리 로직을 여기로 이동 ▼▼▼
        let originalBlockId = 
            inputElement.dataset.originalBid || 
            inputElement.dataset.bid || 
            globalBlockId;

        if (originalBlockId && typeof originalBlockId === 'string' && originalBlockId.startsWith('b') && originalBlockId.endsWith('b')) {
            originalBlockId = originalBlockId.substring(1, originalBlockId.length - 1);
        }

        inputElement.className = "titlePad b15b";
        inputElement.dataset.bid = "15";
        inputElement.dataset.stiffness = "9999";
        inputElement.dataset.empty = "true";
        inputElement.innerText = "9999,1.000";
        inputElement.style.backgroundImage = "none";
        inputElement.style.opacity = 1;
        inputElement.style.backgroundColor = "transparent";
        sounds["stone"].pause();

        inputElement.onclick = function() {
            clickBlock(
                this.dataset.bid,
                parseInt(this.dataset.stiffness),
                this.className.split(' ')[1],
                this,
                this.id
            );
        };

        itemBagGet(originalBlockId, 1);
        timeUpStart = false;
    }

    // 8. 상단 표시창 업데이트
    document.querySelector(".mainBoxTop").innerText = 
        `${currentStiffness.toFixed(1)}|${ratio.toFixed(1)}`;
}

function timeUp(){
    if(timeUpStart==true){
        breakBlock(globalInputElement);
    }
}

function createBlockParticles(blockElement) {
  const rect = blockElement.getBoundingClientRect();
  const centerX = rect.left + rect.width/2;
  const centerY = rect.top + rect.height/2;
  
  // 6개 파티클로 감소 (8방향 → 4방향 기반)
  for(let i = 0; i < 6; i++) {
    const particle = document.createElement('div');
    particle.className = 'block-particle';
    
    // 각도 간격 확대 (60도 간격 + 랜덤 변동)
    const angle = (Math.PI * 2 * i) / 6 + (Math.random()-0.5)*0.7;
    const distance = 60 + Math.random() * 40; // 이동 거리 증가
    
    particle.style.setProperty('--tx', 
      Math.cos(angle) * distance);
    particle.style.setProperty('--ty', 
      Math.sin(angle) * distance);
    
    particle.style.left = centerX + 'px';
    particle.style.top = centerY + 'px';
    
    // 크기 약간 증가 (3~5px)
    particle.style.width = (3 + Math.random()*2) + 'px';
    particle.style.height = particle.style.width;
    particle.style.background = `hsl(0, 0%, ${Math.random()*30}%)`;
    
    particle.addEventListener('animationend', () => {
      particle.remove();
    });
    
    document.body.appendChild(particle);
  }
}

//아이탬생성4
function itemBagGet(getItemId, count) {
    let elementId = null;
    
    switch(getItemId.toString()) { // 문자열 비교를 위해 명시적 형변환


        case "1": elementId = "i00"; break;
    case "2": elementId = "i01"; break;
    case "3": elementId = "i02"; break;
    case "4": elementId = "i03"; break;
    case "48": elementId = "i04"; break;
    case "61": elementId = "i05"; break;
    case "10": elementId = "i06"; break;
    case "11": elementId = "i07"; break;
    case "12": elementId = "i08"; break;
    case "63": elementId = "i09"; break;
    case "64": elementId = "i092"; break;  // [JSON 64→i092]
    case "13": elementId = "i10"; break;
    case "14": elementId = "i11"; break;
    case "46": elementId = "i12"; break;
    case "54": elementId = "i13"; break;
    case "52": elementId = "i14"; break;
    case "49": elementId = "i090"; break;  // [JSON 49→i090]
    case "50": elementId = "i16"; break;
    case "51": elementId = "i17"; break;
    case "62": elementId = "i15"; break;   // [JSON 62→i15]
    case "65": elementId = "i19"; break;
    case "66": elementId = "i190"; break;
    case "57": elementId = "i191"; break;
    case "53": elementId = "i192"; break;

    case "73": elementId = "i20"; break;
    case "7": elementId = "i21"; break;
    case "8": elementId = "i22"; break;

    case "79": elementId = "i23"; break;

    case "76": elementId = "i24"; break;
    case "77": elementId = "i25"; break;
    case "80": elementId = "i26"; break;
    case "81": elementId = "i27"; break;
    case "82": elementId = "i28"; break;
    case "83": elementId = "i29"; break;
    case "84": elementId = "i290"; break;
    case "85": elementId = "i30"; break;
    case "67": elementId = "i31"; break;
    case "68": elementId = "i32"; break;
    case "69": elementId = "i33"; break;
    case "70": elementId = "i34"; break;

    case "72": elementId = "i35"; break;
    case "71": elementId = "i36"; break;
    case "55": elementId = "i37"; break;
    case "86": elementId = "i38"; break;
    case "78": elementId = "i39"; break;
    case "95": elementId = "i390"; break;
    case "97": elementId = "i40"; break;
    case "98": elementId = "i41"; break;
    case "99": elementId = "i42"; break;
    case "100": elementId = "i292"; break;  // [JSON 100→i292]
    case "101": elementId = "i44"; break;
    case "102": elementId = "i45"; break;
    case "103": elementId = "i46"; break;
    case "104": elementId = "i47"; break;
    case "105": elementId = "i48"; break;
    case "106": elementId = "i49"; break;
    case "107": elementId = "i490"; break;
    case "108": elementId = "i392"; break;  // [JSON 108→i392]
    case "109": elementId = "i391"; break;  // [JSON 109→i391]
    case "110": elementId = "i491"; break;  // [JSON 110→i491]
    case "111": elementId = "i492"; break;  // [JSON 111→i492]
    case "112": elementId = "i54"; break;
    case "113": elementId = "i18"; break;   // [JSON 113→i18]
    case "114": elementId = "i091"; break;  // [JSON 114→i091]
    case "115": elementId = "i590"; break;
    case "116": elementId = "i591"; break;
    case "117": elementId = "i592"; break;
    case "118": elementId = "i593"; break;  // 철검
    case "119": elementId = "i594"; break;  // 철활
    case "120": elementId = "i595"; break;  // 화살
    case "121": elementId = "i596"; break;  // 포션
    case "122": elementId = "i597"; break;  // 
    case "123": elementId = "i598"; break;  //
    case "124": elementId = "i599"; break;  // 
    case "125": elementId = "i60"; break;  //플랫폼
    case "126": elementId = "i61"; break;  //고대의상자


    case "149": elementId = "i291"; break;  // [JSON 149→i291]


        default:
            console.log("획득할 수 없는 블럭입니다.");
            return; // 함수 종료
    }

    const element = document.getElementById(elementId);
    if (!element) {
        console.error(`요소 ID '${elementId}'를 찾을 수 없습니다.`);
        return;
    }
    
    // 숫자 연산을 위해 현재 값 파싱
    const currentValue = parseInt(element.innerText) || 0;
    element.innerText = currentValue + parseInt(count);
    updateItemOpacity();
}

// Function to update item opacity based on count
function updateItemOpacity() {
    // Get all inventory items
    const inventoryItems = document.querySelectorAll('.itemPadIn');
    
    // Check each item's count and update opacity
    inventoryItems.forEach(item => {
        const count = parseInt(item.innerText) || 0;
        // Set opacity to 0.5 if count is 0, otherwise 1
        item.style.opacity = count <= 0 ? '0.3' : '1';
    });
}

//가방 창 열고 닫기
var itemBagSizeFull = true;
function itemBagResize() {
    const itemBag = document.querySelector(".itemBag");
    const itemPad = document.querySelector(".itemPad");
    effectSound("click");
    
    if(itemBagSizeFull) {
        // 한 줄 높이로 변경
        itemBag.style.height = "33px";
        itemPad.style.height = "33px";
        document.querySelector(".itemBagBtn").innerText = "off";
        itemBagSizeFull = false;
    } else {
        // 원래 높이로 복구 (CSS의 205px 정확히 반영)
        itemBag.style.height = "207px";
        itemPad.style.height = "100%"; 
        document.querySelector(".itemBagBtn").innerText = "on";
        itemBagSizeFull = true;
    }
}

//가방 창 줄 단위 조절
var currentLines = 1; // 1~6줄 상태 추적
const LINE_HEIGHT = 33; // 줄당 높이
const MAX_LINES = 6.5; // 205px / 33px ≈ 6.21, 최대 6줄로 설정

function itemBagResize2() {
    const itemBag = document.querySelector(".itemBag");
    const itemPad = document.querySelector(".itemPad");
    effectSound("click");

    // 줄 수 순환 (1 → 2 → 3 → 4 → 5 → 6 → 1...)
    currentLines = currentLines % MAX_LINES + 1;
    
    // 높이 계산
    const newHeight = LINE_HEIGHT * currentLines;
    
    // 요소 높이 조정
    itemBag.style.height = `${newHeight}px`;
    itemPad.style.height = `${newHeight}px`;
    
    // 버튼 텍스트 업데이트
    document.querySelector(".itemBagBtn2").innerText = 
        currentLines === MAX_LINES ? "full" : currentLines.toString();
}

//////////////////

var blockSelected = false;
var globalUseBlockId2;


// 전역 상태 관리 객체 수정
let currentBlock = {
    element: null,      // 현재 선택된 인벤토리 요소
    originalCount: 0,   // 원본 블럭 개수
    id: null,           // 블럭 ID
    count: 0,           // 현재 선택 수량
    image: null,        // 블럭 이미지 URL
    stiffness: 1        // 블럭 경도
};



async function useBlock(bagPosition, blockId, blockId2, stiffness = 1) {
    const bagElement = document.getElementById(bagPosition);
    const selectedDisplay = document.querySelector(".selectedBlockDisplay");

    effectSound("click");
    sounds["stone"].pause();

    //블럭 수량 부족
    if (!bagElement || parseInt(bagElement.innerText) <= 0) {
        console.error("수량이 부족합니다");
        return;
    }

    // 1. 동일 블록 재선택 여부 확인
    if (currentBlock.id === blockId) {
        if (currentBlock.element.innerText <= 0) return;
        
        currentBlock.count++;
        currentBlock.element.innerText = currentBlock.originalCount - currentBlock.count;
        selectedDisplay.innerText = currentBlock.count.toString();
        return;
    }

    // 2. 이전 블록 상태 복원
    if (currentBlock.element) {
        currentBlock.element.innerText = currentBlock.originalCount;
    }

    // 3. 새 블록 선택 처리
    if (!bagElement || parseInt(bagElement.innerText) <= 0) return;

    const originalCount = parseInt(bagElement.innerText);
    currentBlock = {
        element: bagElement,
        originalCount: originalCount, // 변경된 부분
        id: blockId,
        count: 1,
        stiffness: stiffness,
        image: null
    };
    console.log("현재 선택된 블럭객체정보"+currentBlock)
    try {
        const imageUrl = await findImageUrl('img', blockId2, ['png', 'gif', 'bmp']);
        selectedDisplay.style.backgroundImage = imageUrl ? `url(${imageUrl})` : "";
        currentBlock.image = imageUrl;
    } catch (error) {
        console.error("이미지 로드 실패:", error);
    }

    bagElement.innerText = currentBlock.originalCount - 1;
    selectedDisplay.innerText = "1";
    selectedDisplay.dataset.blockId = blockId;
    blockSelected = true;
}
////////////////////////////

//표지판 저장배열


var useBlock2BlockLocationId;


function useBlock2(blockLocationId) {


    var targetBlock = document.getElementById(blockLocationId);
    useBlock2BlockLocationId=blockLocationId;
    

    const selectedDisplay = document.querySelector(".selectedBlockDisplay");
    // 1. 상태 유효성 검사
    if (!blockSelected || !currentBlock.element) {
        console.error("블록이 선택되지 않았거나 유효하지 않은 상태입니다.");
        return;
    }

    // 2. DOM 요소 존재 확인
    if (!targetBlock || !selectedDisplay) {
        console.error("요소를 찾을 수 없습니다.");
        return;
    }

    //상태 체크 파트
    const y = parseInt(targetBlock.id.split(',')[1]);
    if (((y > 53 && targetBlock.dataset.empty !== "true")&&(currentBlock.id !="b64b")&&!(targetBlock.classList.contains('b15b')))) {
    console.error("빈 공간에만 설치할 수 있습니다.");
    return;
    }//53이하 여부 판단 
    if(targetBlock.dataset.empty === "false" && !(targetBlock.classList.contains('b15b')||currentBlock.id =="b64b")){
    console.error("이미 블록이 설치되어 있습니다.");
    return;
    }


    console.log("currentblock_ID",currentBlock.id);
    console.log("targetblock_ID",targetBlock.id);
    console.log("blockLocatipn_ID",blockLocationId.id);
    const [x1, y1] = blockLocationId.replace('xy', '').split(','); 

    


    if(currentBlock.id == "b63b") {   //표지판 자체 설치 -> 상호작용버튼 x

    if(signTitle==null||signContent==null){
    sendChat(true,"표지판 제목,내용 각각 입력후 title,content 버튼 클릭","표지판 사용법:");
    }
    sendChat(true,`${signTitle}`,"표지판 제목:");
    sendChat(true,`${signContent}`,"표지판 내용:");

   // ▼▼▼ 수정 후 ▼▼▼
        if(signTitle && signContent) {
            const [x, y] = blockLocationId.replace('xy', '').split(',').map(Number);
            if(x >= 0 && x < SIGN_ARRAY_WIDTH && y >= 0 && y < SIGN_ARRAY_HEIGHT) {
                createSignDisplay(blockLocationId, signTitle, signContent);
            }
        }else{
            sendChat(true,`빈 표지판입니다. 디스플레이가 열리지 않습니다.`,"Server");
        }
    }

  
        
      


    

    // 상호작용 블럭(id=64) 특별 처리 - 설치 안되고 정보 확인
    if (currentBlock.id =="b64b") {
        // 설치 시도 좌표 파싱
        useBlock2BlockLocationId=blockLocationId;

        // 대상 블럭 정보 수집
        const targetInfo = {
            id: targetBlock.id,
            currentBlockId: targetBlock.dataset.bid || '없음',
            isEmpty: targetBlock.dataset.empty === "true"
        };
        getXY(x1,y1);

        // 확인 대화상자 표시
        /*
                const userConfirm = 
            `[action]\n` +
            `loc1: ${x1},${y1}\n` +
            `loc2: ${getXY(x1,0)+"px"},${getXY(0,y1)+"px"}\n` +
            `ID:${targetInfo.currentBlockId}\n` +
            `Name: ${blockCodeInput2(targetInfo.currentBlockId)}\n` +//표지판은 idr가 b64b로 전달됨
            `empty?: ${targetInfo.isEmpty ? 'O':'X'}\n\n`;
        */
        const userConfirm = 
            `[action]\n` +
            `loc1: ${x1},${y1}\n` +
            `loc2: ${getXY(x1,0)+"px"},${getXY(0,y1)+"px"}\n` +
            `Name: ${blockCodeInput2(targetInfo.currentBlockId)}\n` +//표지판은 idr가 b64b로 전달됨
            `empty?: ${targetInfo.isEmpty ? 'O':'X'}\n\n`;
            sendChat(true,`${userConfirm}`,"System");
       

            
                selectedDisplay.innerText--;
                /*
        selectedDisplay.style.backgroundImage = "";
        currentBlock = { element: null, originalCount: 0, id: null, count: 0 };
        blockSelected = false;
            */
    


            console.log(`상호작용 사용`);
            //alert(blockCodeInput2(targetInfo.currentBlockId));
         // 상호작용 처리 코드 수정 (useBlock2 함수 내)
            

                var computedStyleChest = window.getComputedStyle(targetBlock);
                var brightnessValueChest = parseFloat(computedStyleChest.filter.match(/brightness\(([^)]+)\)/)?.[1] || 1);

         // useBlock2 함수 내 표지판 처리 부분
            if(blockCodeInput2(targetInfo.currentBlockId) === "표지판"){
                showSignInfo(blockLocationId);
            }else if(blockCodeInput2(targetInfo.currentBlockId)=="횃불"){
            sendChat(true,"횃불 : 설치한 그 순간의 주변의 밝기를 높여준다.\n제거시 소멸","System");
            }
            
            // 수정된 코드 (useBlock2 함수 내)
                else if(blockCodeInput2(targetInfo.currentBlockId)=="닫힌문상단" || 
                blockCodeInput2(targetInfo.currentBlockId)=="닫힌문하단" ||
                blockCodeInput2(targetInfo.currentBlockId)=="열린문상단" || 
                blockCodeInput2(targetInfo.currentBlockId)=="열린문하단"){
                    //alert(targetBlock.id+""+targetInfo.currentBlockId);
            toggleDoor(targetBlock.id);
            return;
        }else if(blockCodeInput2(targetInfo.currentBlockId)=="TNT"){
            sendChat(true,"triggerTNT","System");
            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="TNT_VER2"){
            sendChat(true,"triggerTNT2","System");
            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="폭탄"){
            sendChat(true,"triggerTNT3","System");
            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="핵폭탄"){
            sendChat(true,"triggerTNT4","System");
            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="쥬크박스"){
            sendChat(true,"bgmBox","System");
            }
          
                    
            else if(blockCodeInput2(targetInfo.currentBlockId)=="조합대"){
                    sendChat(true,"조합대를 엽니다.","System");
                    showCraftingTable();
                    }
        

                  else if(blockCodeInput2(targetInfo.currentBlockId)=="모닥불"){
                    sendChat(true,"10초동안 체력 재생이 빨라집니다.","System");
                    campfire();
                    }

                else if(blockCodeInput2(targetInfo.currentBlockId) === "액자") {
                // 현재 프레임 ID 가져오기 (데이터셋에 저장된 원본 ID 사용)


                
                changeFrame(targetBlock,parseInt((Math.random()*16)+150));
                
                // 시스템 알림
                sendChat(true, `액자가 변경되었습니다.`, "System");
            }
            
                //상자부분은 바로 부셔지게 click block로 이전


            else if(blockCodeInput2(targetInfo.currentBlockId)=="상자"){
            if(brightnessValueChest< 0.1) {
                sendChat(true,"밝기가 너무 낮아 상자를 열 수 없습니다!","System");
            } else {
                sendChat(true,`${'chest1'+'['+x1+','+y1+']'}`,"System");
            }

            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="정글상자"){
                if(brightnessValueChest< 0.1) {
                sendChat(true,"밝기가 너무 낮아 상자를 열 수 없습니다!","System");
            } else {
                sendChat(true,`${'chest2'+'['+x1+','+y1+']'}`,"System");
            }
            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="황금상자"){
                if(brightnessValueChest< 0.1) {
                sendChat(true,"밝기가 너무 낮아 상자를 열 수 없습니다!","System");
            } else {
                sendChat(true,`${'chest3'+'['+x1+','+y1+']'}`,"System");
            }
            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="스타트패키지"){
                if(brightnessValueChest< 0.1) {
                sendChat(true,"밝기가 너무 낮아 상자를 열 수 없습니다!","System");
            } else {
                sendChat(true,`${'chest4'+'['+x1+','+y1+']'}`,"System");
            }
            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="흑요석상자"){
                if(brightnessValueChest< 0.1) {
                sendChat(true,"밝기가 너무 낮아 상자를 열 수 없습니다!","System");
            } else {
                sendChat(true,`${'chest5'+'['+x1+','+y1+']'}`,"System");
            }
            }
            else if(blockCodeInput2(targetInfo.currentBlockId)=="하늘상자"){
                if(brightnessValueChest< 0.1) {
                sendChat(true,"밝기가 너무 낮아 상자를 열 수 없습니다!","System");
            } else {
                sendChat(true,`${'chest6'+'['+x1+','+y1+']'}`,"System");
            }
            
            }
            
            else if(blockCodeInput2(targetInfo.currentBlockId)=="고대의상자"){
                if(brightnessValueChest< 0.1) {
                sendChat(true,"밝기가 너무 낮아 상자를 열 수 없습니다!","System");
            } else {
                sendChat(true,`${'chest8'+'['+x1+','+y1+']'}`,"System");
            }
            }
            else{
                sendChat(true,"해당 블럭은 상호작용이 없는 블럭입니다.\n현재 가능한 블럭 : 표지판,횃불,TNT,쥬크박스,상자류,문,모닥불","System");
               // sendChat(true,"해당 블럭은 상호작용이 없는 블럭입니다.\n현재 가능한 블럭 : 표지판,횃불,TNT,쥬크박스,상자류,문","System");
               // sendChat(true,"해당 블럭은 상호작용이 없는 블럭입니다.\n현재 가능한 블럭 : 표지판,횃불,TNT,쥬크박스,상자류,문","System");
                console.log("e");
            }

            if (parseInt(selectedDisplay.innerText) <= 0) {
            setTimeout(() => {
                selectedDisplay.style.backgroundImage = "";
            selectedDisplay.innerText=0;
            currentBlock = { element: null, originalCount: 0, id: null, count: 0 };
                blockSelected = false;
            }, 50);
        }
    
            return;
      
}


        if(currentBlock.id=="b117b"){
                            sendChat(true,"다이아 곡괭이 착용!...(파괴력 10)","System");
                            EquipmentState="다이아곡괭이";
                            itemBagGet("117", 1);
                            power=2.5;
                    }
                    if(currentBlock.id=="b116b"){
                    sendChat(true,"철 곡괭이 착용!...(파괴력 4))","System");
                    EquipmentState="철곡괭이";
                    itemBagGet("116", 1);
                    power=1.2;
                    }
                    if(currentBlock.id=="b115b"){
                    sendChat(true,"선인장 곡괭이 착용!...(파괴력 2)","System");
                    EquipmentState="선인장곡괭이";
                    itemBagGet("115", 1);
                    power=0.6;
                    }
                    if(currentBlock.id=="b118b"){
                    sendChat(true,"철검 착용!...(공격력 2) 단축키 a (보스 소환중일때 가능)","System");
                    WeaponState="철검";
                    itemBagGet("118", 1);
                    attackDmg=2;
                    attackDmg2 =1.75;
                    }
                    

                    if(currentBlock.id=="b121b"){
                    // 포션 쿨타임 체크 (10초)

                    const currentTime = Date.now();
                    const cooldown = 6000; // 12초 (밀리초)
                    
                    if(window.lastPotionUse && (currentTime - window.lastPotionUse < cooldown)){
                        const remain = Math.ceil((cooldown - (currentTime - window.lastPotionUse))/600);
                        sendChat(true, `포션 쿨타임 남음: ${remain}초`, "System");
                        return;
                    }
                    
                    // 포션 사용 처리
                    sendChat(true,"설치형 포션을 마셨습니다 (쿨타임 6초). Hp+25","System");
                    effectSound("potion");
                    itemBagGet("21",-1);
                    playerHp = Math.min(playerHp + 45, 100);
                    window.lastPotionUse = currentTime;
                    
                    // 쿨타임 완료 알림
                    setTimeout(() => {
                        sendChat(true, "설치형 포션 쿨타임이 완료되었습니다.", "System");
                    }, cooldown);

                    // 기존 UI 초기화 로직
                    setTimeout(() => {
                        selectedDisplay.style.backgroundImage = "";
                        selectedDisplay.innerText=0;
                        currentBlock = { element: null, originalCount: 0, id: null, count: 0 };
                        blockSelected = false;
                    }, 50);
                    return;
                }
                if(currentBlock.id=="b119b"){
                shootArrowToClick();

                return;
                }
    //이상없으면 설치
    effectSound("pick");



           // 블럭 속성 설정 (수정된 부분)
    targetBlock.className = `titlePad b${currentBlock.id}b`;
    targetBlock.dataset.bid = currentBlock.id.toString();
    targetBlock.dataset.originalBid = currentBlock.id.toString(); // 원본 ID 강제 저장
    targetBlock.dataset.stiffness = currentBlock.stiffness.toString();
    targetBlock.dataset.empty = "false";
    targetBlock.innerText = `${currentBlock.stiffness},${currentBlock.stiffness}`;
    
console.log('Installed Block:', {
    id: targetBlock.id,
    text: targetBlock.innerText,
    empty: targetBlock.dataset.empty,
    class: targetBlock.className
});
    // 5. 이미지 동적 로딩
    if (currentBlock.image) {
        targetBlock.style.backgroundImage = `url(${currentBlock.image})`;
        targetBlock.style.backgroundSize = "30px 33px"; 
    } else {
        findImageUrl('img', currentBlock.id, ['png', 'gif', 'bmp'])
            .then(url => {
                targetBlock.style.backgroundImage = url ? `url(${url})` : "";
                targetBlock.style.backgroundSize = "30px 33px";
                currentBlock.image = url;
            })
            .catch(console.error);
    }

        // 6. 인벤토리 업데이트 (수정된 부분)
    const newDisplayCount = parseInt(selectedDisplay.innerText) - 1;
    
    if(newDisplayCount < 0) {
        console.error("사용 가능한 수량이 없습니다.");
        return;
    }

    // ▼ 변경: 인벤토리에서 1개만 차감 (원본 유지) ▼
    currentBlock.element.innerText = currentBlock.originalCount - currentBlock.count;
    
    // ▼ 변경: 선택된 수량만 감소 ▼
    selectedDisplay.innerText = newDisplayCount;


    if (parseInt(selectedDisplay.innerText) <= 0) {
            setTimeout(() => {
                selectedDisplay.style.backgroundImage = "";
            selectedDisplay.innerText=0;
            currentBlock = { element: null, originalCount: 0, id: null, count: 0 };
                blockSelected = false;
            }, 50);
        }
targetBlock.onclick = function() {
  clickBlock(
    this.dataset.bid,
    parseInt(this.dataset.stiffness), // 숫자로 변환
    this.className.split(' ')[1],
    this,
    this.id
  );
};

    console.log(`블록 설치 완료: ${currentBlock.id}, 남은 수량: ${currentBlock.count}`);
}

////////////////////
// 이미지 URL 찾기 함수 (개선된 비동기 처리)
async function findImageUrl(basePath, imageName, extensions) {
    if (!imageName) return null;
    
    for (const ext of extensions) {
        const url = `${basePath}/${imageName}.${ext}`;
        try {
            const exists = await checkImageExists(url);
            if (exists) return url;
        } catch (error) {
            console.warn(`이미지 확인 오류 (${url}):`, error);
        }
    }
    return null;
}

// 이미지 존재 여부를 비동기로 확인 (Promise 처리 개선)
function checkImageExists(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false); // 오류시 reject가 아닌 false 반환
        
        // 이미지 로드 시작
        img.src = url;
    });
}



// CSS를 통한 부드러운 스크롤 설정
document.documentElement.style.scrollBehavior = 'smooth';

function updateTargetPosition(key) {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  
  switch(key) {
    case 'ArrowUp': 
      targetY = Math.max(0, targetY - vh * VIEWPORT_MULTIPLIER);
      break;
    case 'ArrowDown':
      targetY = Math.min(document.documentElement.scrollHeight - vh, targetY + vh * VIEWPORT_MULTIPLIER);
      break;
    case 'ArrowLeft':
      targetX = Math.max(0, targetX - vw * VIEWPORT_MULTIPLIER);
      break;
    case 'ArrowRight':
      targetX = Math.min(document.documentElement.scrollWidth - vw, targetX + vw * VIEWPORT_MULTIPLIER);
      break;
  }

  if(!isAnimating) {
    isAnimating = true;
    requestAnimationFrame(smoothScroll);
  }
}


var bgmFirst=true;

firstChangeColor();
function firstChangeColor(){
    if(dayTimeHour >= 8 && dayTimeHour < 20){
        changeTextColor("day");
        return;
    } else {
        changeTextColor("night");
        return;
    }
}

// 3초마다 firstChangeColor 실행
setInterval(firstChangeColor, 5000);

function dayTimeUp(){
    dayTime++;
    console.log(dayTime);
    getCurrentCenterBlock();
    checkCurrentTerrain();

    if(dayTime>=60){
        dayTimeHour++;
        dayTime=0;
        changeSkyPlus();
        calculateTimeBrightnessFactor();
    }

    
    if(dayTimeHour>=7&&dayTimeHour<20){
    timeStatus="startDay";
    }else{
        timeStatus="startNight";
    }
    if(bgmFirst==true){
        allStopMusic();
    if((timeStatus=="startDay"&&dayBgm==1)){
    musicA.play();
    dayBgm=parseInt((Math.random()*2)+1);
    }else if((timeStatus=="startDay"&&dayBgm==2)){
    musicA2.play();
    dayBgm=parseInt((Math.random()*2)+1);
    }
    else if((timeStatus=="startNight")){
    musicB.play();
    }
    bgmFirst=false;
    }

    if(dayTimeHour<12){
        document.querySelector(".dayTimeBox").innerText=`Am ${dayTimeHour}:${dayTime}`;
    }else if(dayTimeHour>=12&&dayTimeHour<24){
        document.querySelector(".dayTimeBox").innerText=`Pm ${dayTimeHour}:${dayTime}`;

    }else{
        document.querySelector(".dayTimeBox").innerText=`Am ${dayTimeHour}:${dayTime}`;
        dayTimeHour=0;
    }
    
}
     document.querySelector(".dayTimeBox").style.color="black";
        document.querySelector(".selectedBlockDisplay").style.color="black";
        document.querySelector(".itemBagBtn").style.color="black";
        document.querySelector(".itemBagBtn2").style.color="black";
        document.querySelector(".itemBag").style.color="black";
        document.querySelector(".musicSoundControl").style.color="black";
        document.querySelector(".zoomControl").style.color="black";
        document.querySelector(".naverFormBtn").style.color="black";
   function getCurrentCenterBlock() {
    const blockSize = 30;
    return {
        x: Math.floor((window.scrollX + window.innerWidth / 2) / blockSize),
        y: Math.floor((window.scrollY + window.innerHeight / 2) / blockSize)
    };
}

function changeTextColor(input) {
    // night 스타일 적용 함수
    function applyNightStyle() {
        document.querySelector(".fullScreen").style.color = "white";
        document.querySelector(".goHome").style.color = "white";
        document.querySelector(".mainBoxTop").style.color = "white";
        document.querySelector(".dayTimeBox").style.color = "white";
        document.querySelector(".selectedBlockDisplay").style.color = "white";
        document.querySelector(".itemBagBtn").style.color = "white";
        document.querySelector(".itemBagBtn2").style.color = "white";
        document.querySelector(".itemBag").style.color = "white";
        document.querySelector(".musicSoundControl").style.color = "white";
        document.querySelector(".zoomControl").style.color = "white";
        document.querySelector(".naverFormBtn").style.color = "white";
        document.querySelector(".saveDisplay2").style.color = "white";
        document.querySelector(".saveDisplay3").style.color = "white";
        document.querySelector(".saveDisplay4").style.color = "white";
        document.querySelector(".zoomUp").style.color = "white";
        document.querySelector(".zoomDown").style.color = "white";
        document.querySelector(".zoomLeft").style.color = "white";
        document.querySelector(".zoomRight").style.color = "white";
        document.querySelector(".attackControl").style.color = "white";
        document.querySelector(".saveDisplay").style.color = "white";
        document.querySelector(".hpBox").style.color = "white";
        document.querySelector(".armorBox").style.color = "white";

        document.querySelector(".fullScreen").style.borderColor = "white";
        document.querySelector(".goHome").style.borderColor = "white";
        document.querySelector(".mainBoxTop").style.borderColor = "white";
        document.querySelector(".dayTimeBox").style.borderColor = "white";
        document.querySelector(".selectedBlockDisplay").style.borderColor = "white";
        document.querySelector(".itemBagBtn").style.borderColor = "white";
        document.querySelector(".itemBagBtn2").style.borderColor = "white";
        document.querySelector(".itemBag").style.borderColor = "white";
        document.querySelector(".musicSoundControl").style.borderColor = "white";
        document.querySelector(".zoomControl").style.borderColor = "white";
        document.querySelector(".naverFormBtn").style.borderColor = "white";
        document.querySelector(".saveDisplay2").style.borderColor = "white";
        document.querySelector(".saveDisplay3").style.borderColor = "white";
        document.querySelector(".saveDisplay4").style.borderColor = "white";
        document.querySelector(".zoomUp").style.borderColor = "white";
        document.querySelector(".zoomDown").style.borderColor = "white";
        document.querySelector(".zoomLeft").style.borderColor = "white";
        document.querySelector(".zoomRight").style.borderColor = "white";
        document.querySelector(".attackControl").style.borderColor = "white";
        document.querySelector(".saveDisplay").style.borderColor = "white";
        document.querySelector(".hpBox").style.borderColor = "white";
        document.querySelector(".armorBox").style.borderColor = "white";
    }

    // day 스타일 적용 함수
    function applyDayStyle() {
        document.querySelector(".fullScreen").style.color = "black";
        document.querySelector(".goHome").style.color = "black";
        document.querySelector(".mainBoxTop").style.color = "black";
        document.querySelector(".dayTimeBox").style.color = "black";
        document.querySelector(".selectedBlockDisplay").style.color = "black";
        document.querySelector(".itemBagBtn").style.color = "black";
        document.querySelector(".itemBagBtn2").style.color = "black";
        document.querySelector(".itemBag").style.color = "black";
        document.querySelector(".musicSoundControl").style.color = "black";
        document.querySelector(".zoomControl").style.color = "black";
        document.querySelector(".naverFormBtn").style.color = "black";
        document.querySelector(".saveDisplay2").style.color = "black";
        document.querySelector(".saveDisplay3").style.color = "black";
        document.querySelector(".saveDisplay4").style.color = "black";
        document.querySelector(".zoomUp").style.color = "black";
        document.querySelector(".zoomDown").style.color = "black";
        document.querySelector(".zoomLeft").style.color = "black";
        document.querySelector(".zoomRight").style.color = "black";
        document.querySelector(".attackControl").style.color = "black";
        document.querySelector(".saveDisplay").style.color = "black";
        document.querySelector(".hpBox").style.color = "black";
        document.querySelector(".armorBox").style.color = "black";

        document.querySelector(".fullScreen").style.borderColor = "black";
        document.querySelector(".goHome").style.borderColor = "black";
        document.querySelector(".mainBoxTop").style.borderColor = "black";
        document.querySelector(".dayTimeBox").style.borderColor = "black";
        document.querySelector(".selectedBlockDisplay").style.borderColor = "black";
        document.querySelector(".itemBagBtn").style.borderColor = "black";
        document.querySelector(".itemBagBtn2").style.borderColor = "black";
        document.querySelector(".itemBag").style.borderColor = "black";
        document.querySelector(".musicSoundControl").style.borderColor = "black";
        document.querySelector(".zoomControl").style.borderColor = "black";
        document.querySelector(".naverFormBtn").style.borderColor = "black";
        document.querySelector(".saveDisplay2").style.borderColor = "black";
        document.querySelector(".saveDisplay3").style.borderColor = "black";
        document.querySelector(".saveDisplay4").style.borderColor = "black";
        document.querySelector(".zoomUp").style.borderColor = "black";
        document.querySelector(".zoomDown").style.borderColor = "black";
        document.querySelector(".zoomLeft").style.borderColor = "black";
        document.querySelector(".zoomRight").style.borderColor = "black";
        document.querySelector(".attackControl").style.borderColor = "black";
        document.querySelector(".saveDisplay").style.borderColor = "black";
        document.querySelector(".hpBox").style.borderColor = "black";
        document.querySelector(".armorBox").style.borderColor = "black";
    }

    // 실제 좌표 확인 및 스타일 적용
    if (input === "night") {
        applyNightStyle();
    } else if (input === "day") {
        const player = getCurrentCenterBlock();
        if (player && typeof player.y === "number" && player.y >= 53) {
            // y 53 이상이면 night 스타일 강제 적용
            applyNightStyle();
        } else {
            applyDayStyle();
        }
    }
}



function changeSkyPlus(){


switch (dayTimeHour) {  // time은 1~24 범위의 값
       case 0:  // 24:00 (00:00) 자정
        changeSkyImg(37);  // 가장 어두운 밤
        break;
    case 1:  // 01:00 심야
        changeSkyImg(17);  
        break;
    case 2:  // 02:00 깊은 밤
        changeSkyImg(18);  
        break;
    case 3:  // 03:00 후심야
        changeSkyImg(19);  
        break;
    case 4:  // 04:00 새벽 전
        changeSkyImg(20); 
        break;
    case 5:  // 05:00 이른 새벽
        changeSkyImg(21);  
        break;
    case 6:  // 06:00 새벽
        changeSkyImg(22);  
        break;
    case 7:  // 07:00 
        changeSkyImg(23);  
        break;
    case 8:  // 08:00 일출
        changeSkyImg(24); 
        break;
    case 9:  // 09:00 이른 아침
        changeSkyImg(25); 
        break;
    case 10:  // 10:00 아침
        changeSkyImg(26); 
        break;
    case 11:  // 11:00 늦은 아침
 
     dayMusicType=parseInt((Math.random()*2)+1);
        changeSkyImg(27);  
        break;
    case 12:  // 12:00 정오
        changeSkyImg(28);  
   

        break;
    case 13:  // 13:00 이른 오후
        changeSkyImg(29); 
        break;
    case 14:  // 14:00 오후
        changeSkyImg(30);  
        break;
    case 15:  // 15:00 늦은 오후
        changeSkyImg(31); 
        break;
    case 16:  // 16:00 해질녘 전
        changeSkyImg(32); 
        break;
    case 17:  // 17:00 해질녘
        changeSkyImg(33); 
        break;
    case 18:  // 18:00 일몰
        changeSkyImg(34);  
        break;
    case 19:  // 19:00 황혼
        changeSkyImg(35);  
        break;
    case 20:  // 20:00 초저녁
        changeSkyImg(36); 
        break;
    case 21:  // 21:00 저녁
        changeSkyImg(37); 

        break;
    case 22:  // 22:00 밤
        changeSkyImg(38); 

        break;
    case 23:  // 23:00 깊은 밤
        changeSkyImg(15); 

        break;
    case 24:  // 24:00 (00:00) 자정
        changeSkyImg(16);  // 가장 어두운 밤
        
        break;
    default:  // 잘못된 시간값 처리
        changeSkyImg(21);  // 기본값: 밝은 하늘
        break;

        
}
}
// 수정된 하늘 배경 함수
const SKY_IMAGE_CACHE = new Map();
const BIOME_IMAGE_CACHE = new Map();
const LOADED_IMAGES = new Set();
const SURFACE_LEVEL =54;  // 지상 기준 Y 좌표  //원래 53
const SKY_THRESHOLD = 30; // 하늘 영역 최대 Y 좌표
const UNDERWORLD_LEVEL = 155 ; //지하도시 입장 Y좌표

let prevBiomeState = null; 

function preloadCriticalAssets() {

    Array.from({length: 8}, (_, i) => i + 1).forEach(num => {
        const forestImg = new Image();
        forestImg.src = `biome/f${num}.png`;
        BIOME_IMAGE_CACHE.set(`f${num}`, forestImg);

        const caveImg = new Image();
        caveImg.src = `biome/cav${num}.png`;
        BIOME_IMAGE_CACHE.set(`cav${num}`, caveImg);
    });


    Array.from({length: 2}, (_, i) => i + 1).forEach(num => {
        const skyImg = new Image();
        skyImg.src = `biome/sky${num}.png`;
        BIOME_IMAGE_CACHE.set(`sky${num}`, skyImg);
    });


        Array.from({length: 3}, (_, i) => i + 1).forEach(num => {
        const underworldImg = new Image();
        underworldImg.src = `biome/underworld${num}.png`;
        BIOME_IMAGE_CACHE.set(`underworld${num}`, underworldImg);
    });

 
        Array.from({length: 4}, (_, i) => i + 1).forEach(num => {
        const desertImg = new Image();
        desertImg.src = `biome/de${num}.png`;
        BIOME_IMAGE_CACHE.set(`de${num}`, desertImg);
    });

    Array.from({length: 12}, (_, i) => i + 1).forEach(num => {
        const snowImg = new Image();
        snowImg.src = `biome/sn${num}.png`;
        BIOME_IMAGE_CACHE.set(`sn${num}`, snowImg);
    });

    Array.from({length: 7}, (_, i) => i + 1).forEach(num => {
        const jungleImg = new Image();
        jungleImg.src = `biome/ju${num}.png`;
        BIOME_IMAGE_CACHE.set(`ju${num}`, jungleImg);
    });

    Array.from({length: 5}, (_, i) => i + 1).forEach(num => {
        const snowunImg = new Image();
        snowunImg.src = `biome/snu${num}.png`;
        BIOME_IMAGE_CACHE.set(`snu${num}`, snowunImg);
    });

}


function changeSkyImg(input) {
    if (!LOADED_IMAGES.has(input)) {
        const img = new Image();
        img.src = `img/${input}.bmp`;
        img.onload = () => {
            LOADED_IMAGES.add(input);
            applySkyChange(input);
        };
    } else {
        applySkyChange(input);
    }
}

function applySkyChange(input) {
    const imageUrl = `url(img/${input}.bmp)`;
    
    requestAnimationFrame(() => {
        // ::before 요소의 배경 이미지를 CSS 변수로 제어
        document.querySelector(".mainBox").style.setProperty('--sky-image', imageUrl);
    });
}


//바이옴/////////////////////////////////////////

// getCurrentCenterBlock() 함수 보강 //좌표 알아내기
function getCurrentCenterBlock() {
    const blockSize = 30;
    return {
        x:Math.floor((window.scrollX + window.innerWidth/2) / blockSize),
        y: Math.floor((window.scrollY + window.innerHeight/2) / blockSize)
    };
}

//찐바이옴
function updateBiomeBackground() {
    const center = getCurrentCenterBlock();
    const currentY = center.y;
   


    // 현재 상태 판별
    let currentState;
    if(currentY < SKY_THRESHOLD) currentState = 'sky';

    else if((currentY >= SKY_THRESHOLD && currentY < SURFACE_LEVEL)){
        if(getCurrentTerrain()=="사막"){
            //alert("사막 바이옴 변경");
            currentState="desert"
        }else if(getCurrentTerrain()=="설원"){
            currentState="snow";
            //alert("지상 바이옴 변경");
        }else if(getCurrentTerrain()=="습지"){
            currentState="jungle";
            //alert("지상 바이옴 변경");
        }
        else 
            currentState="surface";
            //alert("지상 바이옴 변경");   
    }

    else if(currentY >= UNDERWORLD_LEVEL) currentState = 'underworld';
    else{
        if(getCurrentTerrain()=="사막"){
            currentState="desert_un";
        }else if(getCurrentTerrain()=="습지"){
            currentState="jungle_un";
        }
        else if(getCurrentTerrain()=="설원"){
            currentState="snow_un";
        }
        else{
            currentState = 'underground';

        }
    } 
    //console.log("상태 변화1"+currentState);

    // 상태 변경시에만 업데이트
    if(currentState !== prevBiomeState) {
       // console.log("상태 변화 이전/이후"+currentState+prevBiomeState);
        prevBiomeState = currentState;
    
        biomeTimeBgm(currentState);

        // 실제 바이옴 변경 로직
        switch(currentState) {
            case 'sky':

                const randomSky = Math.floor(Math.random() * 2) + 1;
                changeSkyImg2(randomSky, 'sky', 'sky');
                break;
            case 'surface':
                const randomForest = Math.floor(Math.random() * 8) + 1;
                changeSkyImg2(randomForest, 'surface', 'surface');
                break;

                case 'desert':
                const desert = Math.floor(Math.random() * 4) + 1;
                changeSkyImg2(desert, 'desert', 'desert');
                break;    

                case 'snow':
                const snow = Math.floor(Math.random() * 12) + 1;
                changeSkyImg2(snow, 'snow', 'snow');
                break;    

                case 'snow_un':
                const snow_un = Math.floor(Math.random() * 5) + 1;
                changeSkyImg2(snow_un, 'snow_un', 'snow_un');
                break;    

                case 'jungle':
                const jungle = Math.floor(Math.random() * 7) + 1;
                changeSkyImg2(jungle, 'jungle', 'jungle');
                break;  

            case 'underground':
                const randomCave = Math.floor(Math.random() * 8) + 1;
                changeSkyImg2(randomCave, 'underground', 'underground');
                break;
                case 'underworld':
                const randomCity = Math.floor(Math.random() * 3) + 1;
                changeSkyImg2(randomCity, 'underworld', 'underworld');
                break;    
                
        }
        
        // 즉시 투명도 업데이트
        updateBiomeOpacity();
    }
}
// 최초 실행 1번 -> removeStartPage
// requestAnimationFrame 기반 감지 루프
function biomeCheckLoop() {
    updateBiomeBackground();
    getCurrentTerrain();
    requestAnimationFrame(biomeCheckLoop);
}



/////////바이옴 + 시간 조건 bgm 함수
function biomeTimeBgm(biomeType){
    allStopMusic();

    
    console.log("바이옴 타입"+biomeType);
    console.log("dayBgm 수"+dayBgm);
    console.log("undergroundBgm 수"+undergroundBgm);

    if(biomeType=="surface"){

    if((timeStatus=="startDay"&&dayBgm==1)){
    musicA.play();
    dayBgm=parseInt((Math.random()*2)+1);
    return;
    }else if((timeStatus=="startDay"&&dayBgm==2)){
    musicA2.play();
    dayBgm=parseInt((Math.random()*2)+1);
    return;
    }
    else if((timeStatus=="startNight")){
    musicB.play();
    return;
    }
      
    }else if(biomeType=="desert"){
        musicDe_surface.play();
        return;
    }
    else if(biomeType=="desert_un"){
            musicDe_underground.play();       
        return;
    }
    
    else if(biomeType=="snow"){
        musicIc_surface.play();
        return;
    }
    else if(biomeType=="snow_un"){
            musicIc_underground.play();        
        return;
    }
    
    else if(biomeType=="jungle"){
        if(timeStatus="startNight"){
            musicJu_day.play();
        }    
        else if(timeStatus="startDay"){
            musicJu_night.play();
        }
        return;
    }
    else if(biomeType=="jungle_un"){
            musicJu_underground.play();        
        return;
    }
    
    else if(biomeType=="underground"){

    if((undergroundBgm==1)){
    musicB3.play();
    undergroundBgm=parseInt((Math.random()*2)+1);
    return;
    }else if((undergroundBgm==2)){
    musicB2.play();
    undergroundBgm=parseInt((Math.random()*2)+1);
    return;
    }

    }else if(biomeType=="underworld"){

    if((underworldBgm==1)){
    musicB5.play();
    underworldBgm=parseInt((Math.random()*2)+1);
    return;
    }else if((underworldBgm==2)){
    musicB6.play();
    underworldBgm=parseInt((Math.random()*2)+1);
    return;
    }

    }else if(biomeType=="sky"){
    
        if(timeStatus="startNight"){
            musicB4.play();
        }    
        else if(timeStatus="startDay"){
            musicSp_day.play();
        return;
        }
    }else{
        console.log("timeStatus,biomeType error"+timeStatus,biomeType);

    }

}

function allStopMusic(){
    musicA.pause();
    musicA2.pause();
    musicB.pause();
    musicB2.pause();
    musicB3.pause();
    musicB4.pause();
    musicB5.pause();
    musicB6.pause();
    musicB7.pause();
    musicDe_surface.pause();
    musicIc_surface.pause();
    musicSp_day.pause();
    musicJu_night.pause();
    musicJu_day.pause();
    musicIc_underground.pause();       
    musicJu_underground.pause();       
    musicDe_underground.pause();       

}



// 확장된 바이옴 변경 함수
function changeSkyImg2(imgNumber, biomeType, location) {
    // 바이옴 키 생성 로직
    let biomeKey;
    switch(biomeType) {
        case 'surface':
            biomeKey = `f${imgNumber}`;
            break;
            case 'desert':
            biomeKey = `de${imgNumber}`;
            break;

            case 'snow':
            biomeKey = `sn${imgNumber}`;
            break;

            
            case 'snow_un':
            biomeKey = `snu${imgNumber}`;
            break;

            case 'jungle':
            biomeKey = `ju${imgNumber}`;
            break;

        case 'underground':
            biomeKey = `cav${imgNumber}`;
            break;
        case 'sky':
            biomeKey = `sky${imgNumber}`;
            break;
        case 'underworld':
            biomeKey = `underworld${imgNumber}`;
            break;
        default:
            console.error('Unknown biome type:', biomeType);
            return;
    }

    // 캐시 확인 및 이미지 적용
    if(BIOME_IMAGE_CACHE.has(biomeKey)) {
        applyBiomeChange(biomeKey, location);
    } else {
        // 실시간 로드 및 캐싱
        const img = new Image();
        img.onload = () => {
            BIOME_IMAGE_CACHE.set(biomeKey, img);
            applyBiomeChange(biomeKey, location);
        };
        img.onerror = () => {
            console.error('Failed to load biome image:', biomeKey);
        };
        img.src = `biome/${biomeKey}.png`;
    }
}

function applyBiomeChange(biomeKey, location) {
    requestAnimationFrame(() => {
        // 수정 전: sky case 처리 안됨
        if(location === 'surface'||location==='sky'||location==='desert'||location==='snow'||location==='jungle'||location==='snow_un') {
            document.querySelector(".mainBox2").style.backgroundImage = 
                `url(biome/${biomeKey}.png)`;
        } else if(location === 'underground') {
            document.querySelector(".mainBox3").style.backgroundImage = 
                `url(biome/${biomeKey}.png)`;
                document.querySelector(".mainBox2").style.backgroundImage = 
                `url(biome/${biomeKey}.png)`;
        }else if(location === 'underworld') {
            document.querySelector(".mainBox4").style.backgroundImage = 
                `url(biome/${biomeKey}.png)`;
        }

        updateBiomeOpacity();
    });
}


// 이벤트 리스너 및 초기화
document.addEventListener('DOMContentLoaded', () => {
    preloadCriticalAssets();
    
    // 추가 이미지 지연 로드
    requestIdleCallback(() => {
        [17,18,19,20,22,23,24,25,26,27,29,30,31,32,33,34,36,37,38]
            .forEach(img => new Image().src = `img/${img}.bmp`);
    });

});
//바이옴 전환 투명도 1초마다 체크
let prevBiomeCheck = null;

function checkBiomeChange() {
    const currentBiome = getCurrentBiomeType();
    
    if(currentBiome !== prevBiomeCheck) {
        updateBiomeOpacity();
        prevBiomeCheck = currentBiome;
    }
}

// 1초 간격으로 실행
setInterval(checkBiomeChange, 1000);

function updateBiomeOpacity() {
    const hour = dayTimeHour % 24;
    const currentBiome = getCurrentBiomeType();
    
    // 투명도 계산 로직 (변경 없음)
    const radianOpacity = (hour - 8) * Math.PI / 12;
    let opacity = 0.6 + 0.4 * Math.cos(radianOpacity);
    
    if(hour >= 22 || hour < 4) {
        const midnightFactor = 1 - Math.abs(hour - (hour < 4 ? 22 : 24));
        opacity = 0.4 + 0.3 * midnightFactor;
    }


        // ▼▼▼ 밝기 계산 로직 수정 ▼▼▼
        let brightness;
    const radianBrightness = (hour - 12) * Math.PI / 12;
    
    // 모든 영역에 동일한 계산식 적용
    brightness = ((Math.cos(radianBrightness) + 1) / 2) * 0.8 + 0.2;

    // 하늘 영역 추가 감소 적용
    if(currentBiome === 'sky') {
        brightness *= 0.5; // 50% 감소
    }
    // 값 제한 및 적용 (변경 없음)
    const finalOpacity = currentBiome === 'sky' 
        ? Math.max(0.15, Math.min(opacity, 0.5)).toFixed(2)
        : Math.max(0.4, Math.min(opacity, 1.0)).toFixed(2);

    const finalBrightness = currentBiome === 'sky'
        ? Math.max(0.2, Math.min(brightness, 0.6)).toFixed(2)
        : Math.max(0.5, Math.min(brightness, 1.0)).toFixed(2);

    // CSS 적용 (변경 없음)
    document.querySelector(".mainBox2").style.opacity = finalOpacity;
    document.querySelector(".mainBox2").style.filter = `brightness(${finalBrightness})`;
    document.querySelector(".mainBox").style.filter = `brightness(${finalBrightness})`;
}
//바이옴 타입 판별2
function getCurrentBiomeType() {
    const center = getCurrentCenterBlock();
    const currentY = center.y;
    
    // 검색결과 기반 상수 적용
    const SKY_THRESHOLD = 30;     // paste.txt [2]에서 추출
    const SURFACE_LEVEL = 54;     // paste.txt [2]에서 추출
    const UNDERWORLD_LEVEL = 155; // paste.txt [2]에서 추출

    if(currentY <= SKY_THRESHOLD) { // 0~30: 하늘 영역
        return 'sky';
    } 
    else if(currentY > SKY_THRESHOLD && currentY < SURFACE_LEVEL){
        
        if(getCurrentTerrain()=="사막") { // 31~53: 지상 표층
        return 'desert';
        }
        else if(getCurrentTerrain()=="설원") { // 31~53: 지상 표층
        return 'snow';
        }
        else{
            return "surface";
        }
    }

    else if(currentY >= SURFACE_LEVEL && currentY < UNDERWORLD_LEVEL) { // 54~154: 일반 지하
        return 'underground';
    }
    else { // 155~: 언더월드
        return 'underworld';
    }
}



//////////////////////////
let TORCH_RADIUS = 7; // 11x11 영역 (중심에서 ±5)
let TORCH_BASE = 1.5; // 횃불 기본 밝기 250% 증가
let TORCH_ATTENUATION = 0.35; // 70%감소


let PROPAGATION_DEPTH = 1; // 자연광 전파 깊이
let BASE_BONUS = 0.3; // 자연광 기본 보너스
let ATTENUATION = 0.5; // 자연광 감쇠율

const SELF_LIT_BASE = 0.5; // 자체 발광 기본 밝기 [추가]

// ========== 하늘 노출 판단 함수 ==========
function isSkyExposed(x, y) {
    // y좌표 52 이하는 무조건 하늘로 처리
    if (y <= 52) return true;

    // 윗방향으로 모든 블록 검사 (수정: currentY >= 0 → currentY > 52)
    for (let currentY = y - 1; currentY > 52; currentY--) {
        const block = document.getElementById(`xy${x},${currentY}`);
        if (block?.dataset.empty === "false") return false;
    }
    return true; // 53층 이상에서 위쪽 블록이 모두 파괴된 경우
}



function updateBlocksBrightness() {
    const playerPos = getCurrentCenterBlockPlayer();
    const centerX = playerPos.x;
    const centerY = playerPos.y;
    
     // 가로 방향 범위 확대 (세로는 그대로 50블록 반경)
    const HORIZONTAL_RANGE = 40; // 가로 범위
    const VERTICAL_RANGE = 20;   // 세로 범위 (기존 반경 유지)
    
    const minX = Math.max(MAP_MIN_X, centerX - HORIZONTAL_RANGE);
    const maxX = Math.min(MAP_MAX_X, centerX + HORIZONTAL_RANGE);
    const minY = Math.max(MAP_MIN_Y, centerY - VERTICAL_RANGE);
    const maxY = Math.min(MAP_MAX_Y, centerY + VERTICAL_RANGE);


    // 1. 대상 블럭 필터링 (100x100 영역 내)
    const allBlocks = Array.from(document.querySelectorAll('.titlePad')).filter(block => {
        const [x, y] = block.id.replace('xy', '').split(',').map(Number);
        return x >= minX && x <= maxX && y >= minY && y <= maxY;
    });

    const brightnessMap = new Map();
    const timeBrightness = calculateTimeBrightnessFactor();

    // 2. 기본 밝기 계산 (영역 내 블럭만 처리)
    allBlocks.forEach(block => {
        const [x, y] = block.id.replace('xy', '').split(',').map(Number);
        let brightness = calculateDark(y) * timeBrightness;
        if (isSkyExposed(x, y)) brightness = Math.min(1.0, brightness + BASE_BONUS);
        brightnessMap.set(block.id, brightness);
    });

    // 3. 자체 발광 블럭 처리 (영역 내)
    allBlocks.filter(block => 
        block.className.includes('b83b') || 
        block.className.includes('b85b') || 
        block.className.includes('b86b')
    ).forEach(block => {
        brightnessMap.set(block.id, Math.min(1.0, (brightnessMap.get(block.id) || 0) + SELF_LIT_BASE));
    });

    // 4. 횃불 영향 범위 최적화 (영역 내 횃불만 처리)
    allBlocks.filter(block => block.className.includes('b62b')).forEach(block => {
        const [tx, ty] = block.id.replace('xy', '').split(',').map(Number);
        
        // 횃불 영향 범위 제한
        const torchMinX = Math.max(minX, tx - TORCH_RADIUS);
        const torchMaxX = Math.min(maxX, tx + TORCH_RADIUS);
        const torchMinY = Math.max(minY, ty - TORCH_RADIUS);
        const torchMaxY = Math.min(maxY, ty + TORCH_RADIUS);

        for (let x = torchMinX; x <= torchMaxX; x++) {
            for (let y = torchMinY; y <= torchMaxY; y++) {
                const distance = Math.max(Math.abs(x - tx), Math.abs(y - ty));
                const bonus = TORCH_BASE * Math.pow(TORCH_ATTENUATION, distance);
                const neighborId = `xy${x},${y}`;
                
                if (brightnessMap.has(neighborId)) {
                    brightnessMap.set(neighborId, Math.min(1.0, brightnessMap.get(neighborId) + bonus));
                }
            }
        }
    });

    // 5. 자연광 전파 최적화 (영역 내에서만 전파)
    const propagationQueue = allBlocks
        .filter(block => brightnessMap.get(block.id) >= BASE_BONUS)
        .map(block => ({ block, depth: 1, remainingBonus: BASE_BONUS }));

    while (propagationQueue.length > 0) {
        const { block, depth, remainingBonus } = propagationQueue.shift();
        const [x, y] = block.id.replace('xy', '').split(',').map(Number);

        // 인접 블럭 탐색 범위 제한
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx < minX || nx > maxX || ny < minY || ny > maxY) continue;
                
                const neighbor = document.getElementById(`xy${nx},${ny}`);
                if (neighbor && depth <= PROPAGATION_DEPTH) {
                    const newBonus = remainingBonus * ATTENUATION;
                    const current = brightnessMap.get(neighbor.id) || 0;
                    const newBrightness = Math.min(1.0, current + newBonus);
                    
                    if (newBrightness > current) {
                        brightnessMap.set(neighbor.id, newBrightness);
                        propagationQueue.push({ 
                            block: neighbor, 
                            depth: depth + 1, 
                            remainingBonus: newBonus 
                        });
                    }
                }
            }
        }
    }

    // 6. 밝기 적용 (영역 내 블럭만 업데이트)
    allBlocks.forEach(block => {
        const finalBrightness = Math.max(
            brightnessMap.get(block.id) || 0.5,
            block.className.includes('b83b') ? SELF_LIT_BASE : 0
        );
        block.style.setProperty('filter', `brightness(${finalBrightness.toFixed(2)})`, 'important');
    });
}

// ========== 주기적 업데이트 간격 확장 ==========
setInterval(() => {
    updateBlocksBrightness();
}, 15000);

const LIGHT_PROPAGATION = {
    DEPTH: 1,
    BASE: 0.5,
    ATTENUATION: 0.5
};


function calculateTimeBrightnessFactor() {
    const twoHourlyParams = [

    { hour: 0,  params: [0.3, 0.5, 0.125, 0.275] },   // 00:00~03:00
    { hour: 3,  params: [0.45, 0.8, 0.15, 0.2] },     // 03:00~06:00
    { hour: 6,  params: [0.6, 1.2, 0.275, 0.46] },    // 06:00~09:00
    { hour: 9,  params: [0.85, 1.8, 0.45, 0.37] },    // 09:00~12:00
    { hour: 12, params: [0.475, 1.75, 0.58, 0.36] },  // 12:00~15:00
    { hour: 15, params: [0.7, 1.5, 0.4, 0.35] },      // 15:00~18:00
    { hour: 18, params: [0.425, 0.75, 0.18, 0.275] }, // 18:00~21:00
    { hour: 21, params: [0.2, 0.4, 0.15, 0.2] }       // 21:00~24:00
];

    const adjustedHour = Math.floor(dayTimeHour / 2) * 2;
    const current = twoHourlyParams.find(e => e.hour === adjustedHour);
    
    if (current) {
        [brightness, propagationDepth, baseBonus, attenuation] = current.params;
        PROPAGATION_DEPTH = propagationDepth;
        BASE_BONUS = baseBonus;
        ATTENUATION = attenuation * (adjustedHour >= 18 || adjustedHour < 6 ? 0.5 : 1); // 야간 추가 감쇠 보정
        return brightness;
    }
    
    return 0.5;
}


// 1. MutationObserver 설정 함수
const setupCursorObserver = () => {
    const display = document.querySelector(".selectedBlockDisplay");
    if (!display) return;

    // 2. 실시간 커서 업데이트 함수
    const updateCursor = async () => {
        const style = window.getComputedStyle(display);
        const bgImage = style.backgroundImage;
        const fileName = bgImage.match(/\/([^\/]+?)\.(png|gif|bmp)/i)?.[1];
        
        // 3. 커서 변경 로직
        if (!fileName) {
            document.body.style.setProperty('cursor', 'url("cur/cur531.cur"), auto', 'important');
            return;
        }

        const exts = ['cur', 'png', 'gif', 'bmp'];
        for (const ext of exts) {
            const cursorUrl = `cur/${fileName}.${ext}`;
            try {
                const exists = await checkFileExists(cursorUrl);
                if (exists) {
                    document.body.style.setProperty('cursor', `url('${cursorUrl}'), auto`, 'important');
                    return;
                }
            } catch (error) {
                console.error('Cursor check error:', error);
            }
        }
        document.body.style.setProperty('cursor', 'url("cur/cur531.cur"), auto', 'important');
    };

    // 4. DOM 변화 감지 설정
    const observer = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
            if (mutation.attributeName === 'style') {
                updateCursor();
            }
        });
    });

    observer.observe(display, {
        attributes: true,
        attributeFilter: ['style']
    });

    // 5. 초기 실행
    updateCursor();
};

// 6. 파일 존재 확인 함수 (기존 유지)
async function checkFileExists(url) {
    try {
        const response = await fetch(url, { method: 'HEAD' });
        return response.ok;
    } catch (error) {
        return false;
    }
}

// 7. 초기화 실행
setupCursorObserver();


//표지판 텍스트 위치를 찾기 위함  0으로 x y따로
function getXY(inx,iny){
     // 새 중앙 좌표 계산 (x:150, y:30.5)
    const blockSize = 30;
    if(inx!=0&&iny==0)   return inx*blockSize
    if(inx==0&&iny!=0)    return iny*blockSize

   
}
/////////////////////////////////

const signBoxMain = document.querySelector('.signBoxMain');
const signBox = document.querySelector('.signBox');

// ▼▼▼ 표지판 생성 함수 수정 (2D 배열 통합) ▼▼▼
function createSignDisplay(blockLocationId, title, content) {
    try {
        const [x, y] = blockLocationId.replace('xy', '').split(',').map(Number);
        const targetBlock = document.getElementById(blockLocationId);
        
        // 1. 유효성 검사
        if(!targetBlock) throw new Error("블록을 찾을 수 없음");
        if(isNaN(x) || isNaN(y)) throw new Error("잘못된 좌표 형식");

        // 2. 데이터 구조 생성
        const signData = {
            id: blockLocationId,
            title: title,
            content: content,
            timestamp: new Date().toISOString()
        };

        // 3. 2D 배열 저장 (신규 시스템)
        if(x >= 0 && x < SIGN_ARRAY_WIDTH && y >= 0 && y < SIGN_ARRAY_HEIGHT) {
            signArray[x][y] = signData;
        }


        // 5. 블록 속성 설정
        targetBlock.title = title;
        targetBlock.dataset.bid = "63";
        targetBlock.dataset.empty = "false";
        targetBlock.style.backgroundImage = "url(img/63.png)";
        targetBlock.style.backgroundSize = "30px 33px";

        // 6. UI 표시 요소
        const display = document.createElement('div');
        display.className = 'sign-display';
        display.innerHTML = `<strong>${title}</strong><br>${content.replace(/\n/g, '<br>')}`;
        targetBlock.appendChild(display);

        console.log("표지판 생성 성공:", signData);

    } catch (error) {
        console.error("createSignDisplay 오류:", error);
        sendChat(true, "⚠️ 표지판 로딩이 실패했을 수도 있습니다", "System");
    }
}

// ▼▼▼ 표지판 정보 표시 함수 수정 (2D 배열 우선 사용) ▼▼▼
function showSignInfo(blockLocationId) {
    try {
        const [x, y] = blockLocationId.replace('xy', '').split(',').map(Number);
        let signData = null;

        // 1. 신규 시스템에서 조회
        if(x >= 0 && x < SIGN_ARRAY_WIDTH && y >= 0 && y < SIGN_ARRAY_HEIGHT) {
            signData = signArray[x][y];
        }

    

        // 3. 정보 표시
        effectSound("pick");
        if(signData) {
            signBox.innerHTML = `
                <h3>${signData.title}</h3>
                <p>${signData.content.replace(/\n/g, '<br>')}</p>
            `;
            signBoxMain.style.display = "block";
        } else {
            sendChat(true, "이 위치에 표지판이 없습니다", "System");
        }

    } catch (error) {
        console.error("showSignInfo 오류:", error);
        signBoxClose();
    }
}

// ▼▼▼ 기존 요소 유지 (수정 없음) ▼▼▼
function signBoxClose() {
    effectSound("click");
    signBoxMain.style.display = "none";
    signBox.innerText = "";
}


function applyExplosionDamage(explosionX, explosionY, radius, maxDamage) {
    const playerPos = getCurrentCenterBlockPlayer();
    const dx = playerPos.x - explosionX;
    const dy = playerPos.y - explosionY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    const minDamage = 5;

    if (distance <= radius) {
        const damage = Math.max(minDamage, Math.round(maxDamage * (1 - distance / radius)));
        playerHp = Math.max(0, playerHp - damage + (playerArmor / 50));
        effectSound("hurt");
        updateHpDisplay();
    }
}

function applyVerticalExplosionDamage(explosionX, explosionY, verticalRange, maxDamage) {
    const { x: playerX, y: playerY } = getCurrentCenterBlockPlayer();

    const dx = Math.abs(playerX - explosionX);
    const dy = Math.abs(playerY - explosionY);

    // 폭발 범위 밖이면 무시
    if (dx > 1 || dy > verticalRange) return;

    const normalizedDistance = dy / verticalRange; // 0.0 ~ 1.0
    const damage = Math.max(5, Math.round(maxDamage * (1 - normalizedDistance))); // 거리 기반 데미지

    playerHp = Math.max(0, playerHp - damage + (playerArmor / 50));
    effectSound("hurt");
    updateHpDisplay();
}

// ========== TNT 폭발 처리 함수 (수정본) ==========

function triggerTNT(blockId) {
    const [x, y] = blockId.replace('xy', '').split(',').map(Number);
    const tntBlock = document.getElementById(blockId);

    // 강제 스타일 적용 (CSS 충돌 해결)
    tntBlock.style.cssText = `
        animation: tnt-blink 0.3s infinite !important;
        will-change: filter;
    `;

    // 폭발 파동 효과 - 크기 300px로 축소 (기존 600px)
    const explosionWave = document.createElement('div');
    explosionWave.style.cssText = `
        position: absolute;
        width: 300px;
        height: 300px;
        background: radial-gradient(circle, rgba(255,100,0,0.3) 0%, transparent 70%);
        left: ${x*30 - 150}px;
        top: ${y*30 - 150}px;
        pointer-events: none;
        animation: explodeWave 2s ease-out;
    `;
    document.querySelector('.mainBox').appendChild(explosionWave);

    // 화면 흔들림 효과 - 강도 절반으로 감소
    const mainBox = document.querySelector('.mainBox');
    mainBox.style.animation = 'screenShake 0.8s linear';

    // 3초 후 효과 제거
    setTimeout(() => {
        // 폭발 반경 6으로 감소 (기존 12)
        const radius = 6;
        const maxDamage = 40;   // 최대 데미지
        for(let dx = -radius; dx <= radius; dx++) {
            for(let dy = -radius; dy <= radius; dy++) {
                if(dx*dx + dy*dy > radius*radius) continue;
                processExplosion(x + dx, y + dy);
            }
        }
        //데미지
                  applyExplosionDamage(x, y, radius, maxDamage);

        explosionWave.remove();
        mainBox.style.animation = '';
        tntBlock.style.animation = '';
    }, 3000);

    // 애니메이션 재정의 - 효과 강도 감소
    const style = document.createElement('style');
    style.textContent = `
        @keyframes tnt-blink {
            0%, 100% { filter: brightness(1) !important; }
            50% { filter: brightness(0.5) !important; }
        }
        @keyframes explodeWave {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        @keyframes screenShake {
            0%,100%{transform:translate(0,0);}
            25%{transform:translate(-5px,5px);}
            50%{transform:translate(5px,-3px);}
            75%{transform:translate(-3px,4px);}
        }
    `;
    document.head.appendChild(style);
    setTimeout(() => style.remove(), 3500);
}

// ========== 폭발 처리 함수 ==========
function processExplosion(targetX, targetY) {
    if(targetX < 0 || targetY < 0 || targetX >= 300 || targetY >= 200) return;

    const block = document.getElementById(`xy${targetX},${targetY}`);
    if(!block || block.dataset.empty === "true") return;
    
    // ▼▼▼ 원본 블록 ID 저장 ▼▼▼
    const originalBid = block.dataset.bid;

    // 폭발 면역 블록 처리 (원본 ID로 검사)
    const immuneBlocks = ["15", "63", "67", "68", "69", "70"];
    if(immuneBlocks.includes(originalBid)) return;

    // 폭발 효과
    block.style.transition = 'all 0.3s ease';
    block.style.transform = 'scale(1.3)';
    setTimeout(() => block.style.transform = 'scale(1)', 300);

    // 블럭 파괴 처리
    block.className = "titlePad b15b";
    block.dataset.bid = "15";
    block.dataset.stiffness = "9999";
    block.dataset.empty = "true";
    block.innerText = "9999,1.000";
    block.style.backgroundImage = "none";

    // ▼▼▼ 원본 ID로 아이템 드롭 ▼▼▼
    if(!['15', '65'].includes(originalBid)) {
        itemBagGet(originalBid, 1);
        effectSound("get");
    }
}

///////////////////////////////////


function triggerTNT2(blockId) {
const [x, y] = blockId.replace('xy', '').split(',').map(Number);
const tntBlock = document.getElementById(blockId);

// 1. 다중 레이어 파티클 시스템 추가
const createParticleLayer = (colorSet, count) => {
for(let i=0; i<count; i++) {
const particle = document.createElement('div');
particle.style.cssText = `
position: absolute;
width: ${Math.random()*20+5}px;
height: ${Math.random()*40+20}px;
background: linear-gradient(180deg,
${colorSet[0]} 0%,
${colorSet[1]} 50%,
${colorSet[2]} 100%
);
left: ${x*30 - 75}px; // ▼▼▼ X축 고정 ▼▼▼
top: ${y*30 - 300}px; // ▼▼▼ Y축 시작점 조정 ▼▼▼
transform-origin: 50% 100%;
animation:
particleRise ${Math.random()*2+1}s cubic-bezier(0.4,0,0.2,1),
particleFade ${Math.random()+0.5}s ease-out;
`;
document.querySelector('.mainBox').appendChild(particle);
}
};

// 2. 3종류의 파티클 레이어 생성
createParticleLayer(
['rgba(255,80,0,0.9)', 'rgba(255,40,0,0.7)', 'rgba(200,0,0,0.4)'],
15
);
createParticleLayer(
['rgba(255,120,0,0.7)', 'rgba(255,60,0,0.5)', 'rgba(200,30,0,0.3)'],
10
);
createParticleLayer(
['rgba(255,160,0,0.5)', 'rgba(255,80,0,0.3)', 'rgba(200,60,0,0.2)'],
8
);

// 3. 개선된 수직 그래디언트
const explosionWave = document.createElement('div');
explosionWave.style.cssText = `
position: absolute;
width: 150px;
height: 1200px;
background: linear-gradient(180deg,
rgba(255,40,0,0.6) 0%,
rgba(255,20,0,0.8) 20%,
rgba(255,60,0,0.7) 40%,
rgba(200,0,0,0.5) 60%,
rgba(150,0,0,0.3) 80%,
transparent 100%
);
left: ${x*30 - 75}px;
top: ${y*30 - 600}px;
pointer-events: none;
animation:
explodeWaveVertical 2s cubic-bezier(0.4,0,0.2,1),
waveDistortion 2s linear infinite;
`;
document.querySelector('.mainBox').appendChild(explosionWave);

// 4. 화면 흔들림 효과
const mainBox = document.querySelector('.mainBox');
mainBox.style.animation = 'screenShakeVertical 0.8s linear';

// 5. 폭발 처리 핵심 로직 추가 ▼▼▼
setTimeout(() => {
const verticalRange = 45; // 수직 범위 (y축 ±45블록)
const horizontalRange = 1; // 수평 범위 (x축 ±1블록)

// 수직 폭발 영역 처리
for(let dx = -horizontalRange; dx <= horizontalRange; dx++) {
for(let dy = -verticalRange; dy <= verticalRange; dy++) {
const verticalOffset = dy; // 수직 거리 전달
processExplosion_VER2(x + dx, y + dy, verticalOffset);
}
}

    const maxDamage = 50; // TNT2의 최대 데미지
    applyVerticalExplosionDamage(x, y, verticalRange, maxDamage);

// 효과 제거
explosionWave.remove();
mainBox.style.animation = '';
tntBlock.style.animation = '';
}, 3000);

// 6. 애니메이션 재정의
const style = document.createElement('style');
style.textContent = `
@keyframes tnt-ver2-blink {
0%,100% { filter: brightness(2) hue-rotate(180deg); }
50% { filter: brightness(0.7) hue-rotate(90deg); }
}
@keyframes explodeWaveVertical {
0% { transform: scaleY(0); opacity: 1; }
100% { transform: scaleY(3); opacity: 0; }
}
@keyframes screenShakeVertical {
0%,100%{transform:translateY(0);}
25%{transform:translateY(-15px);}
50%{transform:translateY(10px);}
75%{transform:translateY(-8px);}
}
`;
document.head.appendChild(style);
setTimeout(() => style.remove(), 3500);
}

function processExplosion_VER2(targetX, targetY, verticalOffset) {
    if(targetX < 0 || targetY < 0 || targetX >= 300 || targetY >= 200) return;

    const block = document.getElementById(`xy${targetX},${targetY}`);
    if(!block || block.dataset.empty === "true") return;
    
    // ▼▼▼ 원본 블록 ID 저장 ▼▼▼
    const originalBid = block.dataset.bid;

    // 폭발 면역 블록 처리 (원본 ID로 검사)
    const immuneBlocks = ["15", "63", "69", "70"];
    if(immuneBlocks.includes(originalBid)) return;

// 수직 거리에 따른 파괴력 계산 (거리↑ → 파괴력↓)
const power = Math.max(0, 1 - Math.abs(verticalOffset/45));
if(Math.random() > power) return;

    // 블럭 파괴 처리
    block.className = "titlePad b15b";
    block.dataset.bid = "15";
    block.dataset.stiffness = "9999";
    block.dataset.empty = "true";
    block.innerText = "9999,1.000";
    block.style.backgroundImage = "none";

    // ▼▼▼ 원본 ID로 아이템 드롭 처리 ▼▼▼
    if(!['15', '65', '73'].includes(originalBid) && Math.random() < 0.7) {
        itemBagGet(originalBid, Math.floor(1 + power*3));
        effectSound("get");
    }
}

//////////////////////////////////////////////////////////
//작은 폭탄

function triggerTNT3(blockId) {
    const [x, y] = blockId.replace('xy', '').split(',').map(Number);
    const tntBlock = document.getElementById(blockId);

    // 간소화된 폭발 애니메이션
    tntBlock.style.cssText = `
        animation: tnt-blink 0.2s infinite !important;
        will-change: filter;
    `;

    // 단순화된 폭발 웨이브
    const explosionWave = document.createElement('div');
    explosionWave.style.cssText = `
        position: absolute;
        width: 200px;
        height: 200px;
        background: radial-gradient(circle, rgba(255,80,0,0.2) 0%, transparent 70%);
        left: ${x*30 - 100}px;
        top: ${y*30 - 100}px;
        pointer-events: none;
        animation: explodeWave 1.33s ease-out;
    `;
    document.querySelector('.mainBox').appendChild(explosionWave);

    // 1.5배 빠른 처리 (원본 3000ms → 2000ms)
    setTimeout(() => {
        const radius = 4; // 원본 12의 1/3
        for(let dx = -radius; dx <= radius; dx++) {
            for(let dy = -radius; dy <= radius; dy++) {
                if(dx*dx + dy*dy > radius*radius) continue;
                processExplosion3(x + dx, y + dy);
            }
        }
        const maxDamage = 20;
          applyExplosionDamage(x, y, radius, maxDamage);

        explosionWave.remove();
        tntBlock.style.animation = '';
    }, 2000);

    // 애니메이션 재정의
    const style = document.createElement('style');
    style.textContent = `
        @keyframes tnt-blink {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(0.7); }
        }
        @keyframes explodeWave {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
    `;
    document.head.appendChild(style);
    setTimeout(() => style.remove(), 2333); // 3500/1.5 ≈ 2333
}

// ========== 간소화된 폭발 처리 ==========
function processExplosion3(targetX, targetY) {
    if(targetX < 0 || targetY < 0 || targetX >= 300 || targetY >= 200) return;

    const block = document.getElementById(`xy${targetX},${targetY}`);
    if(!block || block.dataset.empty === "true") return;
    
    const originalBid = block.dataset.bid;

    // 폭발 면역 블록 처리
    const immuneBlocks = ["15", "63", "67", "68", "69", "70","80","81","83","86","84"];
    if(immuneBlocks.includes(originalBid)) return;

    // 단순화된 효과
    block.style.transition = 'all 0.2s ease'; // 1.5배 빠름
    block.style.transform = 'scale(1.2)';
    setTimeout(() => block.style.transform = 'scale(1)', 200);

    // 블럭 파괴 처리
    block.className = "titlePad b15b";
    block.dataset.bid = "15";
    block.dataset.stiffness = "9999";
    block.dataset.empty = "true";
    block.innerText = "9999,1.000";
    block.style.backgroundImage = "none";

    // 아이템 드롭
    if(!['15', '65'].includes(originalBid)) {
        itemBagGet(originalBid, 1);
        effectSound("get");
    }
}
//////////////////////////////////////////
function triggerTNT4(blockId) {
    const [x, y] = blockId.replace('xy', '').split(',').map(Number);
    const tntBlock = document.getElementById(blockId);
    const mainBox = document.querySelector('.mainBox');

    // 1. CSS 키프레임 강제 주입
    if (!document.getElementById('nuclear-animations')) {
        const style = document.createElement('style');
        style.id = 'nuclear-animations';
        style.textContent = `
            @keyframes nuclear-blink {
                0%, 100% { 
                    filter: brightness(4) saturate(4) !important;
                    transform: scale(1) translateZ(0) !important;
                }
                50% { 
                    filter: brightness(0.3) saturate(0.3) !important;
                    transform: scale(1.3) translateZ(0) !important;
                }
            }
            @keyframes spark-fly {
                0% { opacity: 1; transform: translate(0,0) scale(1); }
                100% { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(0.3); }
            }
            @keyframes shockwave {
                0% { transform: scale(0); opacity: 1; }
                100% { transform: scale(5); opacity: 0; }
            }
            @keyframes nuclear-flash {
                0% { transform: scale(0); opacity: 1; }
                80% { opacity: 0.8; }
                100% { transform: scale(10); opacity: 0; }
            }
            @keyframes screen-shake {
                0%,100%{transform:translate(0,0);}
                10%{transform:translate(-25px,15px) rotate(-1deg);}
                20%{transform:translate(20px,-10px) rotate(2deg);}
                30%{transform:translate(-15px,20px) rotate(1deg);}
                40%{transform:translate(10px,-15px) rotate(-2deg);}
                50%{transform:translate(-20px,10px) rotate(3deg);}
            }
        `;
        document.head.appendChild(style);
    }

    // 2. 사운드 스케줄링
    effectSound("nuclear1");
    setTimeout(() => effectSound("nuclear2"), 7000);
    setTimeout(() => effectSound("nuclear3"), 15000);

    // 3. 핵폭탄 시각 효과
    tntBlock.style.cssText = `
        animation: nuclear-blink 0.15s infinite !important;
        position: fixed !important;
        z-index: 99999 !important;
        transform: translateZ(0);
        mix-blend-mode: screen;
    `;

    // 4. 이펙트 컨테이너 생성
    const effectContainer = document.createElement('div');
    effectContainer.style.cssText = `
        position: fixed;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        overflow: visible;
        z-index: 99998;
        transform: translateZ(0);
    `;
    document.body.appendChild(effectContainer);

    // 5. 360도 불꽃 생성
    let sparkInterval = setInterval(() => {
        const rect = tntBlock.getBoundingClientRect();
        const baseX = rect.left + rect.width/2;
        const baseY = rect.top + rect.height/2;

        // 8방향 불꽃 생성
        for(let i=0; i<8; i++){
            const angle = (Math.PI*2/8)*i + Math.random()*0.5;
            const distance = 50 + Math.random()*100;
            const spark = createSpark(baseX, baseY, angle, distance);
            effectContainer.appendChild(spark);
            setTimeout(() => spark.remove(), 1000);
        }
    }, 50);

    // 6. 15초 후 폭발 처리
    setTimeout(() => {
        const rect = tntBlock.getBoundingClientRect();
        const centerX = rect.left + rect.width/2;
        const centerY = rect.top + rect.height/2;

        // 순간적인 섬광 효과
        const flash = document.createElement('div');
        flash.style.cssText = `
            position: absolute;
            left: ${centerX - 100}px;
            top: ${centerY - 100}px;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, 
                rgba(255,255,255,1) 0%, 
                rgba(255,200,100,0.8) 30%, 
                rgba(255,100,50,0) 70%);
            animation: nuclear-flash 0.5s ease-out;
            z-index: 99999;
        `;
        effectContainer.appendChild(flash);

        // 3중 충격파 (그라데이션 강화)
        createShockwave(centerX, centerY, 1, 'rgba(255,255,0,0.8)', 10);
        createShockwave(centerX, centerY, 1.5, 'rgba(255,165,0,0.6)', 8);
        createShockwave(centerX, centerY, 2, 'rgba(255,0,0,0.4)', 6);

        // 미세 입자 효과
        for(let i=0; i<200; i++){
            const particle = createParticle(centerX, centerY);
            effectContainer.appendChild(particle);
            setTimeout(() => particle.remove(), 2000);
        }

        // 화면 흔들림 효과
        mainBox.style.animation = 'screen-shake 1.2s linear';
        setTimeout(() => mainBox.style.animation = '', 1200);

        // 블록 파괴
        destroyBlocks(x, y);

        // 정리
        setTimeout(() => {
            effectContainer.remove();
            tntBlock.style.cssText = '';
            clearInterval(sparkInterval);
        }, 3000);


 applyExplosionDamage(x, y, 55, 120);

    }, 15000);

    // 보조 함수들 --------------------------------------------------
    function createSpark(x, y, angle, distance) {
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        const hue = Math.random()*20 + 30;
        
        const spark = document.createElement('div');
        spark.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            width: ${8 + Math.random()*8}px;
            height: ${8 + Math.random()*8}px;
            background: linear-gradient(
                to bottom,
                hsl(${hue}, 100%, 70%),
                hsl(${hue+10}, 100%, 50%)
            );
            border-radius: 50%;
            animation: spark-fly 0.8s ease-out forwards;
            box-shadow: 0 0 15px hsl(${hue}, 100%, 50%);
            --dx: ${dx}px;
            --dy: ${dy}px;
            transform: translateZ(0);
        `;
        
        // 파티클 꼬리 효과
        const trail = document.createElement('div');
        trail.style.cssText = `
            position: absolute;
            width: 70%;
            height: 70%;
            background: inherit;
            filter: blur(3px);
            animation: inherit;
        `;
        spark.appendChild(trail);
        
        return spark;
    }

    function createShockwave(x, y, scale, color, thickness) {
        const wave = document.createElement('div');
        wave.style.cssText = `
            position: absolute;
            left: ${x - 100*scale}px;
            top: ${y - 100*scale}px;
            width: ${200*scale}px;
            height: ${200*scale}px;
            border: ${thickness}px solid ${color};
            border-radius: 50%;
            animation: shockwave ${1.5/scale}s ease-out;
            box-shadow: 0 0 ${20*scale}px ${color};
            transform: translateZ(0);
        `;
        effectContainer.appendChild(wave);
        setTimeout(() => wave.remove(), 1500/scale);
    }

    function createParticle(x, y) {
        const angle = Math.random()*Math.PI*2;
        const distance = 50 + Math.random()*200;
        const hue = Math.random()*30 + 20;
        
        const particle = document.createElement('div');
        particle.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            width: 4px;
            height: 4px;
            background: hsl(${hue}, 100%, 50%);
            border-radius: 50%;
            animation: spark-fly ${0.5 + Math.random()*1}s ease-out forwards;
            --dx: ${Math.cos(angle)*distance}px;
            --dy: ${Math.sin(angle)*distance}px;
            transform: translateZ(0);
            opacity: ${0.7 + Math.random()*0.3};
        `;
        return particle;
    }

    function destroyBlocks(cx, cy) {
        const radius = 60;
        for(let dx = -radius; dx <= radius; dx++) {
            for(let dy = -radius; dy <= radius; dy++) {
                if(dx*dx + dy*dy > radius*radius) continue;
                processExplosion4(cx + dx, cy + dy);
            }
        }
    }

}

function processExplosion4(targetX, targetY) {
    if(targetX < 0 || targetY < 0 || targetX >= 300 || targetY >= 200) return;

    const block = document.getElementById(`xy${targetX},${targetY}`);
    if(!block || block.dataset.empty === "true") return;

    // ▼▼▼ 블록 파괴 강제 실행 ▼▼▼
    block.style.transition = 'all 0.3s ease';
    block.style.transform = 'scale(1.5)';
    setTimeout(() => {
        block.style.transform = 'scale(1)';
        block.className = "titlePad b15b";
        block.dataset.bid = "15";
        block.dataset.stiffness = "9999";
        block.dataset.empty = "true";
        block.innerText = "9999,1.000";
        block.style.backgroundImage = "none";
    }, 300);
}


////////////////////////////////////////////////////////////
//엔터키로 입력
document.getElementById('chat-input').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        sendChat(false, 'none', 'user');
 
        this.value = ''; // 입력값 초기화
    }
});
//샌드챗 (confirm prompt대신 사용)
function sendChat(autoCheck,autoText,status) {
    const input = document.getElementById('chat-input');
    const text = input.value.trim();
    const text2 = (autoText.toString()).trim();
    //alert(text2);//왜 기존 좌표값만 action?

    var textXY = getCurrentCenterBlockPlayer(); // {x: 33, y: 52} 등 반환
    var textXYElement = document.getElementById(`${textXY.x},${textXY.y}`);
    //console.log("textXy"+textXY);
    //showSpeechBubble(`${textXYElement}`, text);

    if(autoCheck==false&&autoText=="none"){
        if (text) {
        const chatLog = document.getElementById('chat-log');
        const now = new Date();
        const date = now.toISOString().split('T')[0];
        const time = now.toLocaleTimeString();
        const msgDiv = document.createElement('div');
        msgDiv.textContent = `[${date} ${time}] : ${text} `;
        chatLog.appendChild(msgDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        input.value = '';
        checkChat(text);
        return;
        }
    }
    if(autoCheck==true&&autoText!="none"){
        const chatLog = document.getElementById('chat-log');
        const msgDiv = document.createElement('div');
        msgDiv.textContent = `[${status}] : ${text2} `;
        chatLog.appendChild(msgDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        input.value = '';
        checkChat(text2);
        return;
    }
    
}

var tntFirst=true;
function checkChat(inText){
    //console.log(inText);
if(inText=="triggerTNT"){
    if(tntFirst==true){
        sendChat(true,"폭탄의 불발 확률이 있습니다.","server");
        tntFirst=false;
    }
    sendChat(true,"Fire! 5......4.....3...","TNT");
    effectSound("TNT");
    setTimeout(() =>triggerTNT(useBlock2BlockLocationId),2000);
  
    //alert("bomb!");
}
if(inText=="triggerTNT2"){
    if(tntFirst==true){
        sendChat(true,"폭탄의 불발 확률이 있습니다.","server"); 
        tntFirst=false;
    }
    sendChat(true,"VER2 TNT! 5....4...3..","TNT_VER2");
    effectSound("TNT");
    setTimeout(() =>triggerTNT2(useBlock2BlockLocationId),2500);
  
    //alert("bomb!");
}
if(inText=="triggerTNT3"){
    if(tntFirst==true){
        sendChat(true,"폭탄의 불발 확률이 있습니다.","server");
        tntFirst=false;
    }
    sendChat(true,"3...2...1..","bomb");
    effectSound("TNT");
    setTimeout(() =>triggerTNT3(useBlock2BlockLocationId),1000);
  
    //alert("bomb!");
}
if(inText=="triggerTNT4"){
        if(tntFirst==true){
        sendChat(true,"폭탄의 불발 확률이 있습니다.","server");
        tntFirst=false;
    }
    sendChat(true,"15...14....","nuclear : Waring");

    setTimeout(() =>triggerTNT4(useBlock2BlockLocationId),500);
  
    //alert("bomb!");
}
if(inText=="changeFrameImg"){
    sendChat(true,"change! ","액자를 변경합니다");


    //al
}
if(inText=="/help"){
    sendChat(true,"u can use gamemode0,1 !","System");
}
if(inText=="bgmBox"){
    sendChat(true,`${bgmBox()}`,"System");
}

if(inText=="signTitle"){
    sendChat(true,`${signInput1()}`,"제목");
}
if(inText=="signContent"){
    sendChat(true,`${signInput2()}`,"내용");
}
if(inText=="gamemode1"){
    sendChat(true,`${gameModeChange(1)}`,"[System] : gamemode1");
}
if(inText=="gamemode0"){
    sendChat(true,`${gameModeChange(0)}`,"[System] : gamemode0");
}
// 1. '['와 ']'의 위치를 찾는다
const leftBracket = inText.indexOf('[');
const rightBracket = inText.indexOf(']');

// 2. 올바른 형식인지 검사
if (leftBracket !== -1 && rightBracket !== -1 && rightBracket > leftBracket) {
    // 3. 중괄호 안의 내용을 추출
    const coordStr = inText.substring(leftBracket + 1, rightBracket); // "15,30"
    // 4. 쉼표로 분리
    const coords = coordStr.split(',');
    if (coords.length === 2) {
        // 5. 숫자로 변환
        const x = parseInt(coords[0], 10);
        const y = parseInt(coords[1], 10);
        // x와 y를 원하는 곳에 사용
        if(inText.includes("chest1")){
            sendChat(true,`${aboutChest(1,x,y)}`,"상자 오픈!");
        }
        if(inText.includes("chest2")){
            sendChat(true,`${aboutChest(2,x,y)}`,"정글 상자 오픈!");
        }
        if(inText.includes("chest3")){
            sendChat(true,`${aboutChest(3,x,y)}`,"항금 상자 오픈!");
        }

        if(inText.includes("chest4")){
            sendChat(true,`${aboutChest(4,x,y)}`,"스타트 페키지 오픈!");
        }
        if(inText.includes("chest5")){
            sendChat(true,`${aboutChest(5,x,y)}`,"흑요석 상자 오픈!");
        }
        if(inText.includes("chest6")){
            sendChat(true,`${aboutChest(6,x,y)}`,"하늘 상자 오픈!");
        }

        if(inText.includes("chest8")){
            sendChat(true,`${aboutChest(8,x,y)}`,"고대의 상자 오픈!");
        }
        console.log("chest x값:", x, "chest y값:", y);
    
    }
}

}


/////////////

// ▼▼▼ 수정된 표지판 입력 함수들 ▼▼▼
const MAX_TITLE_LENGTH = 20;
const MAX_CONTENT_LENGTH = 100;

function signInput1() {
    const input = document.getElementById('chat-input');
    const text = input.value.trim();
    
    if (!text) {
        sendChat(true, "❌ 제목은 1자 이상 입력해야 합니다", "System");
        return;
    }
    
    signTitle = text.slice(0, MAX_TITLE_LENGTH);
    sendChat(true, `📌 제목 설정: "${signTitle}" (${signTitle.length}/${MAX_TITLE_LENGTH}자)`, "System");
    

    
    clearAndResetInput();
}

function signInput2() {
    const input = document.getElementById('chat-input');
    const text = input.value.trim();
    
    if (!text) {
        sendChat(true, "❌ 내용은 1자 이상 입력해야 합니다", "System");
        return;
    }
    
    signContent = text.slice(0, MAX_CONTENT_LENGTH);
    sendChat(true, `📝 내용 설정: "${signContent}" (${signContent.length}/${MAX_CONTENT_LENGTH}자)`, "System");
    
    // 설치 가능 상태 알림
    if (signTitle && signContent) {
        sendChat(true, "✅ 이제 원하는 위치에 표지판을 설치할 수 있습니다", "System");
    }
    
    clearAndResetInput();
}

// ▼▼▼ 공통 유틸리티 함수 ▼▼▼
function clearAndResetInput() {
    const input = document.getElementById('chat-input');
    input.value = '';
    input.focus();
    
    // 채팅 로그 정리
    const chatLog = document.getElementById('chat-log');
    if(chatLog.children.length > 50) {
        chatLog.removeChild(chatLog.firstElementChild);
    }
}

//////////////
var reSizeCount=20;
var reSizeCounting=1;

function chatReSize(){
  
    reSizeCount+=10;
    reSizeCounting++;

    if(reSizeCount<=60){
    reSizeCountX=reSizeCount+"%";
    reSizeCountY=(reSizeCount*10)+"px";

    document.getElementById('chat-box').style.width=`${reSizeCountX}`;
    document.getElementById('chat-log').style.height=`${reSizeCountY}`;
    document.getElementById('chat-size-btn').innerText=`${(reSizeCounting)+"/5"}`;
    }
    else if(reSizeCount>60){
        reSizeCount=20;
        reSizeCounting=1;
        reSizeCountX=reSizeCount+"%";
        reSizeCountY=30+"px";
    document.getElementById('chat-box').style.width="30%"
    document.getElementById('chat-log').style.height="120px"
    document.getElementById('chat-size-btn').innerText=`${(reSizeCounting)+"/5"}`;
    return;
    }

   


}

var chatOpenStatus=true;
function chatOpen(){
    if(chatOpenStatus==true){
        document.getElementById('chat-log').style.display="none";
        document.getElementById('chat-open-btn').innerText="open";
        chatOpenStatus=false;
    }else{
        document.getElementById('chat-log').style.display= "block";
        document.getElementById('chat-open-btn').innerText="close";
        chatOpenStatus=true;//close
    }


}
//효과음 파트
//https://www.myinstants.com/en/instant/minecraft-tnt-explosion-23424/
//https://creatorset.com/products/minecraft-stone-breaking-sound-effect?srsltid=AfmBOoptBR3tqVqgQ7KjZb2hbbIN0EtH9Kg2TF4YuHQJTCIcGOFLJNTr
//https://minecraft.fandom.com/wiki/Category:Block_sounds
//https://terraria.wiki.gg/wiki/Music_Boxes
//https://terraria.fandom.com/wiki/Music_Boxes 
const sounds = {
    TNT: new Audio("sound/tnt.mp3"),
    TNTSmall: new Audio("sound/tnt.mp3"),
    pick: new Audio("sound/pick.ogg"),
    get: new Audio("sound/get.ogg"),
    click: new Audio("sound/click.ogg"),
    stone: new Audio("sound/stone.mp3"),
    bgmBoxBasic: new Audio("sound/bgmBoxBasic.x-wav"),
    chestO: new Audio("sound/chestO.ogg"),
    chestC1: new Audio("sound/chestC1.ogg"),
    chestC3: new Audio("sound/chestC2.ogg"),
    chestC4: new Audio("sound/chestC3.ogg"),
    door_open: new Audio("sound/door_open.mp3"),
    door_close: new Audio("sound/door_close.mp3"),
    Beacon_power1: new Audio("sound/Beacon_power1.ogg"),
    Beacon_power2: new Audio("sound/Beacon_power2.ogg"),
    Beacon_power3:new Audio("sound/Beacon_power3.ogg"),
    nuclear1: new Audio("sound/nuclear1.mp3"),
    nuclear2: new Audio("sound/nuclear2.mp3"),
    nuclear3: new Audio("sound/nuclear3.mp3"),
    hurt: new Audio("sound/hurt.mp3"),
    attack1: new Audio("sound/attack1.mp3"),
    attack2: new Audio("sound/attack2.mp3"),
    attack3: new Audio("sound/attack3.mp3"),
    potion: new Audio("sound/potion.mp3"),
    bow: new Audio("sound/bow.mp3"),
    wall: new Audio("sound/crashWall.mp3"),
    coin: new Audio("sound/coin.mp3"),
    scream: new Audio("sound/scream.mp3"),
    playerDie: new Audio("sound/playerDie.mp3"),
    bloodDown: new Audio("sound/bloodDown.mp3"),
    quest: new Audio("sound/quest.mp3"),
    bitWin: new Audio("sound/bitWin.mp3"),
    bossWin: new Audio("sound/bossWin.mp3"),
    teleport: new Audio("sound/teleport.mp3"),
    explode: new Audio("sound/explode.mp3"),
    heal: new Audio("sound/heal.mp3"),

};

sounds.stone.loop = false;
sounds.nuclear1.loop = false;
sounds.nuclear2.loop = false;
sounds.nuclear3.loop = false;
sounds.TNTSmall.playbackRate = 2.0;



//https://pixabay.com/sound-effects
//mp3노래
function effectSound(type){
    const sound = sounds[type];
    if(sound){
        sound.currentTime = 0;
        sound.play();
    }
    if(sound=="nuclear2"){
        nuclear1.pause();    
    }if(sound=="nuclear3"){
        nuclear1.pause();
        nuclear2.pause();
    }
}

function bgmBox() {
    // 재생 횟수 랜덤 설정 (2~5회)
    const playCount = Math.floor(Math.random() * 16) + 4;
    let currentPlay = 0;

    

    // 재생 간격 랜덤 설정 (0.2~0.4초)
    const playInterval = () => {
        if(currentPlay < playCount) {
            sounds.bgmBoxBasic.playbackRate = Math.floor(Math.random() * 1.25) + 1;
            effectSound("bgmBoxBasic");
            currentPlay++;
           
            // 다음 재생까지의 간격 설정
            const nextDelay = Math.random() * 300 + 50; // 200ms~400ms
            setTimeout(playInterval, nextDelay);
        }
    }

    // 최초 실행
    playInterval();
}
// 상자별 드랍 테이블 (아이템 ID 기준)

const CHEST_LOOT = {
    1: { // 일반 상자
        items: [
            { id: 10, name: "조약돌", chance: 0.4 },    // ID 10
            { id: 16, name: "점토", chance: 0.35 },     // ID 16
            { id: 3, name: "진흙", chance: 0.25 },      // ID 3
            { id: 48, name: "나뭇잎", chance: 0.2 },    // ID 48
            { id: 62, name: "횃불", chance: 0.15 },      // ID 62
            { id: 11, name: "철광석", chance: 0.25 },
            { id: 12, name: "루비", chance: 0.2 },  // ID 11
            { id: 48, name: "나뭇잎", chance: 0.3 },  // ID 11
            { id: 121, name: "포션", chance:0.015 },
            { id: 120, name: "화살", chance:0.015}


              // ID 11

        ]
    },
    2: { // 정글 상자
        items: [
            { id: 50, name: "벌통", chance: 0.4 },      // ID 50
            { id: 51, name: "꿀블럭", chance: 0.3 },    // ID 51
            { id: 12, name: "루비", chance: 0.15 },     // ID 12
            { id: 13, name: "에메랄드", chance: 0.1 },  // ID 13
            { id: 11, name: "철광석", chance: 0.3 },    // ID 11
            { id: 52, name: "흑요석", chance: 0.15 }, 
            { id: 53, name: "화강암", chance: 0.2 }, 
            { id: 61, name: "던전가시", chance: 0.3 },    // ID 11
            { id: 121, name: "포션", chance:0.03 },
            { id: 120, name: "화살", chance:0.03 }
               // ID 11
               // ID 11

        ]
    },
    3: { // 황금 상자
        items: [
            { id: 14, name: "다이아몬드", chance: 0.2 }, // ID 14
            { id: 54, name: "신비한블럭", chance: 0.25 },  // ID 54
            { id: 46, name: "우주하늘", chance: 0.25 },   // ID 46
            { id: 65, name: "TNT", chance: 0.1 }, 
            { id: 73, name: "TNT_VER2", chance: 0.15 },
            { id: 85, name: "폭탄", chance: 0.4 }, 
            { id: 66, name: "쥬크박스", chance: 0.25 },    // ID 66
            { id: 61, name: "던전가시", chance: 0.2 },
            { id: 13, name: "에메랄드", chance:0.3 },
            { id: 121, name: "포션", chance:0.05 },
            { id: 120, name: "화살", chance:0.05 }


        ]
    },
    4: { // 스타트패키지
        items: [
        { id: 62, name: "횃불", chance: 1.6 },
        { id: 96, name: "조합대", chance: 0.85 },
        { id: 63, name: "표지판", chance: 0.85 },
        { id: 49, name: "제작나무", chance: 0.45 },
        { id: 10, name: "조약돌", chance: 0.45 },
        { id: 1, name: "잔디", chance: 0.45 },
        { id: 85, name: "폭탄", chance: 0.65 }, 
        { id: 65, name: "TNT", chance: 0.2 },
        { id: 73, name: "TNT_VER2", chance: 0.1 },
        { id: 16, name: "점토", chance: 0.35 },
        { id: 3, name: "진흙", chance: 0.35 },
        { id: 66, name: "쥬크박스", chance:0.425 },
        // 경도 2 신규 아이템
        { id: 78, name: "유리", chance: 0.9 },       // 경도 1
        { id: 79, name: "트리", chance: 0.4 },      // 경도 3
        { id: 76, name: "닫힌문상단", chance: 0.8 },  // 경도 2
        { id: 77, name: "닫힌문하단", chance: 0.8 },  // 경도 2
        { id: 83, name: "불타는화염", chance: 0.1 }, // 경도 5
        { id: 85, name: "무지개블럭", chance: 0.1 },  // 경도 5
        { id: 67, name: "상자", chance: 0.2 },      // 경도 10
        { id: 69, name: "황금상자", chance: 0.06 },    // 경도 30  
        { id: 55, name: "물", chance: 0.36 },      // 경도 10
        { id: 86, name: "용암", chance: 0.13 },   // 경도 30
        // 3차 업데이트 신규 블록 추가
        { id: 97, name: "모루", chance: 0.1 },
        { id: 98, name: "화로", chance: 0.1 },
        { id: 99, name: "모닥불", chance: 0.1 },
        { id: 100, name: "거미줄", chance: 0.1 },
        { id: 101, name: "얼음", chance: 0.1 },
        { id: 102, name: "단단한얼음", chance: 0.1 },
        { id: 103, name: "눈", chance: 0.1 },
        { id: 104, name: "눈블럭", chance: 0.1 },
        { id: 105, name: "크리스탈블럭", chance: 0.1 },
        { id: 106, name: "모래", chance: 0.1 },
        { id: 107, name: "모래벽돌", chance: 0.1 },
        { id: 108, name: "사암", chance: 0.1 },
        { id: 109, name: "선인장", chance: 0.1 },
        { id: 110, name: "광산수레", chance: 0.1 },
        { id: 111, name: "철로", chance: 0.1 },
        { id: 112, name: "핵폭탄", chance: 0.025 },
        { id: 113, name: "밧줄", chance: 0.9 },
        { id: 113, name: "연기", chance: 0.1 },
        { id: 149, name: "액자", chance: 0.3 }
        ]
    },
    5: { // 흑요석상자
        items: [
            { id: 62, name: "횃불", chance: 0.9 },        
            { id: 65, name: "TNT", chance: 0.2 },   
            { id: 73, name: "TNT_VER2", chance: 0.25 },
            { id: 85, name: "폭탄", chance: 0.3 }, 
            { id: 83, name: "불타는화염", chance: 0.3 },
            { id: 85, name: "무지개블럭", chance: 0.25 },
            { id: 69, name: "황금상자", chance:0.3 },
            { id: 86, name: "용암", chance:0.4 },
            { id: 66, name: "쥬크박스", chance:0.3 },
            { id: 14, name: "다이아몬드", chance:0.25 },
            { id: 13, name: "에메랄드", chance:0.45 },
            { id: 81, name: "지옥석", chance:0.3 },
            { id: 82, name: "단단한지옥석", chance:0.3 },
            { id: 80, name: "재블럭", chance:0.3 }


        ]
    },
    6: { // 하늘상자
        items: [
            { id: 62, name: "횃불", chance: 0.9 },
            { id: 63, name: "표지판", chance:0.5 },        
            { id: 65, name: "TNT", chance: 0.35 },   
            { id: 73, name: "TNT_VER2", chance: 0.35 }, 
            { id: 112, name: "핵폭탄", chance: 0.5 }, 
            { id: 85, name: "폭탄", chance: 0.5 }, 
            { id: 67, name: "상자", chance:0.13 },
            { id: 69, name: "황금상자", chance:0.07 },
            { id: 68, name: "정글상자", chance:0.095 },
            { id: 7, name: "구름", chance:0.5 },
            { id: 8, name: "먹구름", chance:0.5 },
            { id: 9, name: "흐린구름", chance:0.5 },
            { id:55, name: "물", chance:0.5 }
    ]
    },
      
    7: { // 흑요석상자 (중복 제거 통합 버전)
    items: [
        { id: 10, name: "조약돌", chance: 0.1 },
        { id: 16, name: "점토", chance: 0.1 },
        { id: 3, name: "진흙", chance: 0.1 },
        { id: 48, name: "나뭇잎", chance: 0.1 },
        { id: 62, name: "횃불", chance: 0.1 },
        { id: 11, name: "철광석", chance: 0.1 },
        { id: 12, name: "루비", chance: 0.1 },
        { id: 50, name: "벌통", chance: 0.1 },
        { id: 51, name: "꿀블럭", chance: 0.1 },
        { id: 13, name: "에메랄드", chance: 0.1 },
        { id: 52, name: "흑요석", chance: 0.1 },
        { id: 53, name: "화강암", chance: 0.1 },
        { id: 61, name: "던전가시", chance: 0.1 },
        { id: 96, name: "조합대", chance: 0.1 },
        { id: 63, name: "표지판", chance: 0.1 },
        { id: 49, name: "제작나무", chance: 0.1 },
        { id: 1, name: "잔디", chance: 0.1 },
        { id: 85, name: "폭탄", chance: 0.1 },
        { id: 65, name: "TNT", chance: 0.1 },
        { id: 73, name: "TNT_VER2", chance: 0.1 },
        { id: 66, name: "쥬크박스", chance: 0.1 },
        { id: 78, name: "유리", chance: 0.1 },
        { id: 79, name: "트리", chance: 0.1 },
        { id: 76, name: "닫힌문상단", chance: 0.1 },
        { id: 77, name: "닫힌문하단", chance: 0.1 },
        { id: 83, name: "불타는화염", chance: 0.1 },
        { id: 67, name: "상자", chance: 0.03 },
        { id: 69, name: "황금상자", chance: 0.03 },
        { id: 55, name: "물", chance: 0.1 },
        { id: 86, name: "용암", chance: 0.1 },
        { id: 97, name: "모루", chance: 0.1 },
        { id: 98, name: "화로", chance: 0.1 },
        { id: 99, name: "모닥불", chance: 0.1 },
        { id: 100, name: "거미줄", chance: 0.1 },
        { id: 101, name: "얼음", chance: 0.1 },
        { id: 102, name: "단단한얼음", chance: 0.1 },
        { id: 103, name: "눈", chance: 0.1 },
        { id: 104, name: "눈블럭", chance: 0.1 },
        { id: 105, name: "크리스탈블럭", chance: 0.1 },
        { id: 106, name: "모래", chance: 0.1 },
        { id: 107, name: "모래벽돌", chance: 0.1 },
        { id: 108, name: "사암", chance: 0.1 },
        { id: 109, name: "선인장", chance: 0.1 },
        { id: 110, name: "광산수레", chance: 0.1 },
        { id: 111, name: "철로", chance: 0.1 },
        { id: 112, name: "핵폭탄", chance: 0.1 },
        { id: 113, name: "밧줄", chance: 0.1 },
        { id: 149, name: "액자", chance: 0.1 }
    ]
},

8: { // 고대의상자
        items: [

            { id: 70, name: "스타트패키지", chance:0.25},     
            { id: 126, name: "고대의상자", chance:0.25},        
            { id: 112, name: "핵폭탄", chance: 0.05}, 
            { id: 119, name: "철활", chance:0.5 },
            { id: 120, name: "화살", chance:6 },
            { id: 121, name: "포션", chance:1 },
            { id:118, name: "철검", chance:0.3 },
            { id: 52, name: "흑요석", chance:1.5 },
            { id: 53, name: "화강암", chance:1.5 },
            { id: 100, name: "거미줄", chance:0.1 },
            { id: 11, name: "철광석", chance:0.2 },
            { id: 16, name: "벌통", chance:0.2 },
            { id: 17, name: "꿀블럭", chance:0.2 },
            { id:117, name: "다이아곡괭이", chance:0.05 }
    ]
    },

};


// 확률 계산 함수
function getRandomItem(chestType) {
    const lootTable = CHEST_LOOT[chestType];
    let total = lootTable.items.reduce((sum, item) => sum + item.chance, 0);
    let random = Math.random() * total;
    
    for(const item of lootTable.items) {
        if(random < item.chance) {
            return item;
        }
        random -= item.chance;
    }
    return lootTable.items[0];
}



var getChestItem;
// aboutChest 함수 수정 (상자 파괴 로직 추가)
function aboutChest(inputNum,chestX,chestY) {

    if(inputNum==7){


   // 3. 아이템 드랍 로직 (기존 코드 유지)
   const itemCount = Math.floor(Math.random() * 40) + 25;
    const itemMap = {}; 
    for (let i = 0; i < itemCount; i++) {
        const item = getRandomItem(inputNum);
        itemBagGet(item.id, 1);
        itemMap[item.name] = (itemMap[item.name] || 0) + 1;
    }

    // 4. 결과 반환 (기존 코드 유지)
    const resultParts = [];
    for (const [name, count] of Object.entries(itemMap)) {
        resultParts.push(`${name}(${count})`);
    }
    
    getChestItem = resultParts.join(', ');
    chestSound();
    
    return `${getChestItem}를 획득하셨습니다. (총 ${itemCount}개)`;
    return;
    }else{


    // 1. 중앙 좌표 계산 및 블럭 선택
    //const position = getCurrentCenterBlock();
    const chestId = `xy${chestX},${chestY}`;
    const chestBlock = document.getElementById(chestId);

    // 2. 블럭 존재 여부 확인
    if (!chestBlock) {
        console.error("상자 블럭을 찾을 수 없습니다.");
        return "오류 발생";
    }

    // 3. 아이템 드랍 로직 (기존 코드 유지)
    const itemCount = Math.floor(Math.random() * 35) + 15;
    const itemMap = {}; 
    for (let i = 0; i < itemCount; i++) {
        const item = getRandomItem(inputNum);
        itemBagGet(item.id, 1);
        itemMap[item.name] = (itemMap[item.name] || 0) + 1;
    }

    // ▼▼▼ 추가: 상자 블럭 파괴 처리 ▼▼▼
    // 하늘 블럭 속성 설정
    chestBlock.className = "titlePad b15b";
    chestBlock.dataset.bid = "15";
    chestBlock.dataset.stiffness = "9999";
    chestBlock.dataset.empty = "true";
    chestBlock.innerText = "9999,1.000";
    chestBlock.style.backgroundImage = "";
    
    // 클릭 이벤트 재설정
    chestBlock.onclick = function() {
        clickBlock(
            this.dataset.bid,
            parseInt(this.dataset.stiffness),
            this.className.split(' ')[1],
            this,
            this.id
        );
    };

    // 4. 결과 반환 (기존 코드 유지)
    const resultParts = [];
    for (const [name, count] of Object.entries(itemMap)) {
        resultParts.push(`${name}(${count})`);
    }
    
    getChestItem = resultParts.join(', ');
    chestSound();
    
    return `${getChestItem}를 획득하셨습니다. (총 ${itemCount}개)`;
}
}

// 기존 chestSound 함수에 아이템 획득 사운드 추가
function chestSound() {
    effectSound("chestO");
    setTimeout(() => {
        var chestSelection = Math.floor(Math.random() * 3) + 1;
        effectSound(`chestC${chestSelection}`);
   
    }, 2500);
}
////////////////////////////////
////////////////////////////////////////
const allowItems = [
  "15", "111", "96", "97", "98", "99", "66", "63", "62", "67", "68", "69","74","75","76","77",
  "70", "71", "110", "65", "73", "95", "112", "113","86","55","109","103","106","125","126",
  "b15b", "b111b", "b96b", "b97b", "b98b", "b99b", "b66b", "b63b","b74b","b75b","b76b","b77b",
  "b62b", "b67b", "b68b", "b69b", "b70b", "b71b", "b110b", "b65b","b86b","b55b","b109b","b103b","b106b",
  "b73b", "b95b", "b112b", "b113b","b125b","126b" // b코드b 형태 추가
];
const dangerousBlock = [
  "86", "61", "55","109","81","82","83",
  "b86b", "b61b","b55b","109","b81b","b82b","b83b"

];
// 맵 경계 설정 (실제 맵 크기에 맞게 조정 필요)
const MAP_MIN_X = 0;
const MAP_MAX_X = 300;
const MAP_MIN_Y = 0;
const MAP_MAX_Y = 200;
const BLOCK_SIZE = 30;

// 카메라 클램핑 경계 계산을 위한 변수
let isCameraLocked = true;

let centerX = 150
let centerY = 50;
function getCurrentCenterBlockPlayer() {
    // 화면 중앙 좌표 계산
    let viewportCenterX = window.scrollX + window.innerWidth / 2;
    let viewportCenterY = window.scrollY + window.innerHeight / 2;
    
    // 블록 단위 좌표 변환
     centerX = Math.floor(viewportCenterX / BLOCK_SIZE);
    centerY = Math.floor(viewportCenterY / BLOCK_SIZE);

    // 맵 경계 근처인지 확인 및 카메라 고정 상태 업데이트
    checkMapBoundary(centerX, centerY);
    
    // 플레이어 좌표만 제한 (맵 바깥으로 나가지 않도록)
    if (centerX < MAP_MIN_X) centerX = MAP_MIN_X;
    if (centerX > MAP_MAX_X) centerX = MAP_MAX_X;
    if (centerY < MAP_MIN_Y) centerY = MAP_MIN_Y;
    if (centerY > MAP_MAX_Y) centerY = MAP_MAX_Y;

    return {
        x: centerX,
        y: centerY
    };
}

// 맵 경계 근처 여부 확인 및 카메라 고정 상태 업데이트 함수
function checkMapBoundary(playerX, playerY) {
    // 화면 크기의 절반을 블록 단위로 계산
    const halfScreenBlocksX = Math.floor(window.innerWidth / (2 * BLOCK_SIZE));
    const halfScreenBlocksY = Math.floor(window.innerHeight / (2 * BLOCK_SIZE));
    
    // 카메라 고정 해제 경계 (맵 경계에서 화면 절반 크기만큼 안쪽)
    const leftBoundary = MAP_MIN_X + halfScreenBlocksX;
    const rightBoundary = MAP_MAX_X - halfScreenBlocksX;
    const topBoundary = MAP_MIN_Y + halfScreenBlocksY;
    const bottomBoundary = MAP_MAX_Y - halfScreenBlocksY;
    
    // 플레이어가 경계 근처에 있는지 확인
    const isNearBoundary = 
        playerX <= leftBoundary || 
        playerX >= rightBoundary || 
        playerY <= topBoundary || 
        playerY >= bottomBoundary;
    
    // 경계 근처에 있으면 카메라 고정 해제, 아니면 고정
    isCameraLocked = !isNearBoundary;
}

// 이전 플레이어 위치 저장 변수
let prevPlayerX = -1;
let prevPlayerY = -1;
const PLAYER_BORDER_STYLE = "1px solid white";
var targetPlayerBlock;

// 스크롤 위치 저장을 위한 변수 추가
let lastScrollX = 0;
let lastScrollY = 0;

/////////////////////////////////////////////////
// 플레이어 이미지 태그를 전역에서 재사용
let playerImgElement = null;


let lastPlayerDirection = 'R'; // L/R 기본값
let lastMoveTime = Date.now();
let isIdle = false;
let idleTimeout = null;
let idleCheckTimeout =null;


function resetIdleState() {
    isIdle = false;
    lastMoveTime = Date.now();
    if (idleCheckTimeout) clearTimeout(idleCheckTimeout);
    idleCheckTimeout = setTimeout(() => {
        if (Date.now() - lastMoveTime >= 3000) {
            isIdle = true;
            highlightPlayerPosition();
        }
    }, 3000); // 3초 후에 딱 1회 체크
}




        function getBlock(x, y) {
        const key = `xy${x},${y}`;
        return domCache[key] || (domCache[key] = document.getElementById(key));
    }
       



    let passedBlocks = []; // 지나간 블럭 저장 배열
let prevPlayerPosition = { x: null, y: null };

// 3초마다 블럭 원래 크기 복구
setInterval(() => {
    passedBlocks.forEach(block => {
        if (block && block.style) {
            block.style.transform = 'scale(1)';
        }
    });
    passedBlocks = []; // 배열 비우기
}, 3000);

function highlightPlayerPosition() {
    const { x: currentX, y: currentY } = getCurrentCenterBlockPlayer();
    const currentBlock = document.getElementById(`xy${currentX},${currentY}`);

    // 위치 변경 감지
    if (currentX !== prevPlayerX || currentY !== prevPlayerY) {
        resetIdleState();

        // 이전 블럭 저장
        if (prevPlayerPosition.x !== null && prevPlayerPosition.y !== null) {
            const prevBlock = getBlock(prevPlayerPosition.x, prevPlayerPosition.y);
            if (prevBlock && prevBlock !== currentBlock) {
                passedBlocks.push(prevBlock);
                prevBlock.style.transform = 'scale(1.25)';
                prevBlock.style.transition = 'transform 0.1s ease-in-out';
                prevBlock.style.boxShadow = ''; // 이전 블럭의 표시 효과 제거
                prevBlock.style.border = '';
                prevBlock.style.borderRadius = '0% / 0%';
            }
        }

        prevPlayerPosition = { x: currentX, y: currentY };
    }

    // 현재 블럭 처리
    if (currentBlock) {
        currentBlock.style.transform = 'scale(1.25)';
        currentBlock.style.transition = 'transform 0.1s ease-in-out';
    }

    // ---------- 기존 이미지 관련 코드 ----------
    let imageLoaded = true;

    // 이전 위치에서 이미지 제거
    if (playerImgElement?.parentElement) {
        playerImgElement.parentElement.removeChild(playerImgElement);
    }

    // 이미지 엘리먼트 생성/갱신
    if (!playerImgElement) {
        playerImgElement = document.createElement('img');
        playerImgElement.style.position = 'absolute';
        playerImgElement.style.left = '0';
        playerImgElement.style.top = '0';
        playerImgElement.style.width = '100%';
        playerImgElement.style.height = '100%';
        playerImgElement.style.pointerEvents = 'none';
        playerImgElement.style.zIndex = '10';
    }

    // 상태에 따른 이미지 경로 설정
   
       // 이미지 변경 로직 개선
    const newImgSrc = isIdle 
        ? `img/playerStay${lastPlayerDirection}.png`
        : `img/playerMove${lastPlayerDirection}.gif`;
    
    if (playerImgElement.src !== newImgSrc) {
        playerImgElement.src = newImgSrc; // 변경 시에만 src 업데이트
    }


    
        if (currentBlock) {
           currentBlock.style.borderRadius = '50% / 30%';
        currentBlock.style.boxShadow = '0 1px 1px 0px #ffec00';

        }

    // DOM 조작
    if (currentBlock) {
        currentBlock.style.position = 'relative';
        // 이미지가 정상적으로 로드된 경우에만 append
        if (imageLoaded) {
            currentBlock.appendChild(playerImgElement);
        }
    }

    // 위치 정보 갱신
    prevPlayerX = currentX;
    prevPlayerY = currentY;
}


// 초기화
resetIdleState();

// 실시간 위치 추적 인터벌
const trackingInterval = setInterval(() => {
    highlightPlayerPosition();
}, 50);

// 초기화 함수
function initPlayerTracking() {
    highlightPlayerPosition();
    window.addEventListener('resize', highlightPlayerPosition);
    window.addEventListener('scroll', highlightPlayerPosition);
    
    // 초기 스크롤 위치 저장
    lastScrollX = window.scrollX;
    lastScrollY = window.scrollY;
}

// 페이지 로드 시 추적 시작
window.addEventListener('load', initPlayerTracking);

// 추적 중지 함수
function stopPlayerTracking() {
    clearInterval(trackingInterval);
    window.removeEventListener('resize', highlightPlayerPosition);
    window.removeEventListener('scroll', highlightPlayerPosition);
}


let playerHp = 100;
let playerArmor =1;

let ArmorState=null;//갑옷
let WeaponState="맨손";//무기
let EquipmentState=null//장비

const MAX_HP = 100;

let inRedZone = false;
let inOrangeZone = false;


const heartBeatRed = new Audio('sound/heartBeat.mp3');
heartBeatRed.loop = true;

const heartBeatOrange = new Audio('sound/heartBeat2.mp3');
heartBeatOrange.loop = true;

function updateHpDisplay() {
  const hpElement = document.querySelector('.hpBox');
  const hpPercent = (playerHp / MAX_HP) * 100;
  hpElement.style.width = `${hpPercent}px`;
  hpElement.title = `HP: ${playerHp}/${MAX_HP}`;

  // 🔴 빨간색: 0~20%
  if (hpPercent <= 20) {
    hpElement.style.backgroundColor = '#ff0000';

    if (!inRedZone) {
      // 빨간 구간에 처음 진입 → 오렌지 사운드 멈추고 레드 사운드 재생
      stopHeartBeat(); // 모든 사운드 중지
      heartBeatRed.play().catch(err => console.error("빨간 사운드 재생 오류:", err));
      inRedZone = true;
      inOrangeZone = false;
    }

  }
  // 🟠 주황색: 21~40%
  else if (hpPercent <= 40) {
    hpElement.style.backgroundColor = '#ffa500';

    if (!inOrangeZone) {
      stopHeartBeat();
      heartBeatOrange.play().catch(err => console.error("주황 사운드 재생 오류:", err));
      inRedZone = false;
      inOrangeZone = true;
    }

  }
  // 🟡 노랑/🟢 초록: 41% 이상
  else {
    if (hpPercent <= 60) {
      hpElement.style.backgroundColor = 'yellow';
    } else {
      hpElement.style.backgroundColor = '#00ff00';
    }

    // 사운드 정지
    if (inRedZone || inOrangeZone) {
      stopHeartBeat();
      inRedZone = false;
      inOrangeZone = false;
    }
  }
}

// 🔇 모든 사운드 정지 함수
function stopHeartBeat() {
  heartBeatRed.pause();
  heartBeatRed.currentTime = 0;

  heartBeatOrange.pause();
  heartBeatOrange.currentTime = 0;
}


// ================ [플레이어 이동 관련 전역 변수] ================
var SCROLL_STEP_GLOBAL = null;
var direction_global = null;
var targetX_global = null, targetY_global = null;
var targetBlock_global = null;
var meetWall = null;
var waring_wall = 0;

// ================ [중력 시스템 전역 변수 추가] ================
var isPlayerFalling = false;
var fallSpeed = 1;
var gravity = 0.2;
var maxFallSpeed = 3;

// ================ [개선된 플레이어 이동 함수] ================
function tryMovePlayer(direction) {
    const { x, y } = getCurrentCenterBlockPlayer();
    let targetX = x, targetY = y;

    lastScrollX = window.scrollX;
    lastScrollY = window.scrollY;

    const SCROLL_STEP = BLOCK_SIZE;
    SCROLL_STEP_GLOBAL = SCROLL_STEP;
    direction_global = direction;
    targetX_global = x;
    targetY_global = y;

    
    switch (direction) {
        case 'ArrowUp': targetY--; targetY_global--; break;
        case 'ArrowDown': targetY++; targetY_global++; break;
        case 'ArrowLeft': targetX--; targetX_global--; break;
        case 'ArrowRight': targetX++; targetX_global++; break;
    }

    const targetBlock = document.getElementById(`xy${targetX},${targetY}`);
    targetBlock_global = document.getElementById(`xy${targetX},${targetY}`);

    // 충돌 검사
    let isWall = false;
    if (targetBlock) {
        const isAllowMove = allowItems.includes(targetBlock.dataset.bid);
        const isDangerousBlock=dangerousBlock.includes(targetBlock.dataset.bid);
        setTimeout(() => targetBlock.style.boxShadow = '', 500);
        updateHpDisplay();
          //console.log(isDangerousBlock);
        if ((creativeMode == false && !isAllowMove)&& !(isDangerousBlock)) {
            console.log(`충돌! 블럭 ID: ${targetBlock.id}, BID: ${targetBlock.dataset.bid}`);

            playerHp = Math.max(0, (playerHp - 0.5));

            targetBlock.style.boxShadow = '0 0 10px 3px orange';
            isWall = true;
            meetWall = true;
            waring_wall++;
            effectSound("wall");
        }
       

        else if ((creativeMode == false && isAllowMove)&& (isDangerousBlock)) {
            console.log(`충돌! 블럭 ID: ${targetBlock.id}, BID: ${targetBlock.dataset.bid}`);
            targetBlock.style.boxShadow = '0 0 10px 3px red';
            if(targetBlock.dataset.bid=="86"||targetBlock.dataset.bid=="b86b"){
                playerHp = Math.max(0, playerHp - 25 + (playerArmor/50));
                effectSound("");

            }
            if(targetBlock.dataset.bid=="61"||targetBlock.dataset.bid=="b61b"){
                playerHp = Math.max(0, playerHp - 12+ (playerArmor/50));
                effectSound("hurt");
            }
            if(targetBlock.dataset.bid=="55"||targetBlock.dataset.bid=="b55b"){
                playerHp = Math.max(0, playerHp - 2+ (playerArmor/50));
effectSound("hurt");
            }
            if(targetBlock.dataset.bid=="109"||targetBlock.dataset.bid=="b109b"){
                playerHp = Math.max(0, playerHp - 6+ (playerArmor/50));
effectSound("hurt");
            }

    }        
    else if ((creativeMode == false&& !isAllowMove)&& (isDangerousBlock)){//통과되지는 않는데 블럭
        if(targetBlock.dataset.bid=="81"||targetBlock.dataset.bid=="b81b"){
                playerHp = Math.max(0, playerHp - 7 + (playerArmor/50));
effectSound("hurt");
            }
            if(targetBlock.dataset.bid=="82"||targetBlock.dataset.bid=="b82b"){
                playerHp = Math.max(0, playerHp - 6+ (playerArmor/50)) ;
effectSound("hurt");
            }
            if(targetBlock.dataset.bid=="83"||targetBlock.dataset.bid=="b83b"){
                playerHp = Math.max(0, playerHp - 12.5 + (playerArmor/50));
effectSound("hurt");
            }

    }
    }



    if (!isWall) {
        const moveStep = creativeMode ? SCROLL_STEP*5 : SCROLL_STEP;
        
        // 방향별 이동 처리
        switch (direction) {
            case 'ArrowUp':
            case 'ArrowDown': 
                if (creativeMode || !isPlayerFalling) {
                    scrollWithClamping(0, (direction === 'ArrowUp') ? -moveStep : moveStep);
                }
                break;
                
            case 'ArrowLeft':
            case 'ArrowRight':
                scrollWithClamping((direction === 'ArrowLeft') ? -moveStep : moveStep, 0);
                break;
        }
    } else {
        window.scrollTo(lastScrollX, lastScrollY);
    }
}

// ================ [카메라 클램핑 기능을 포함한 스크롤 함수] ================
function scrollWithClamping(deltaX, deltaY) {
    // 플레이어의 현재 위치 (블록 단위)
    const { x: playerX, y: playerY } = getCurrentCenterBlockPlayer();
    
    // 화면 크기 절반 (픽셀 단위)
    const halfScreenWidth = window.innerWidth / 2;
    const halfScreenHeight = window.innerHeight / 2;
    
    // 새로운 스크롤 위치 계산
    let newScrollX = window.scrollX + deltaX;
    let newScrollY = window.scrollY + deltaY;
    
    // 카메라 클램핑 (맵 경계에서 카메라 제한)
    if (isCameraLocked) {
        // 기본 화면 중앙 고정 방식
        window.scrollBy(deltaX, deltaY);
    } else {
        // 맵 경계 근처에서는 맵 끝까지 카메라 이동 허용
        const minScrollX = MAP_MIN_X * BLOCK_SIZE;
        const maxScrollX = (MAP_MAX_X * BLOCK_SIZE) - window.innerWidth;
        const minScrollY = MAP_MIN_Y * BLOCK_SIZE;
        const maxScrollY = (MAP_MAX_Y * BLOCK_SIZE) - window.innerHeight;
        
        // 경계 내로 제한
        newScrollX = Math.max(minScrollX, Math.min(newScrollX, maxScrollX));
        newScrollY = Math.max(minScrollY, Math.min(newScrollY, maxScrollY));
        
        window.scrollTo(newScrollX, newScrollY);
    }
}

// 전역 변수 추가 (이동 쿨다운 관리)
let lastAirMoveTime = 0;
const AIR_MOVE_COOLDOWN = 1000; // 1초(1000ms)

function applyGravity() {
    if (creativeMode) return;

    const { x, y } = getCurrentCenterBlockPlayer();
    const blockBelow = document.getElementById(`xy${x},${y+1}`);

    // 낙하 가능 조건 검사
    if (blockBelow && (blockBelow.dataset.bid === "15"||blockBelow.dataset.bid === "86"||blockBelow.dataset.bid === "55"||blockBelow.dataset.bid === "100"||blockBelow.dataset.bid === "106"||blockBelow.dataset.bid === "103")){
        if (fallSpeed < maxFallSpeed) fallSpeed += gravity;
        
        scrollWithClamping(0, SCROLL_STEP_GLOBAL * fallSpeed);
        
        if (!isPlayerFalling) {
            isPlayerFalling = true;
            console.log("낙하 시작!");
        }
    } else {
        if (isPlayerFalling) {
            isPlayerFalling = false;
            fallSpeed = 1;
            console.log("착지!");
        }
    }
}


function isBlockBelow(x, y) {
    const belowBlock = document.getElementById(`xy${x},${y + 1}`);
    if (!belowBlock) return false;
    return allowItems.includes(belowBlock.dataset.bid) === false;
}

// 키 입력 핸들러 수정
window.addEventListener('keydown', function(e) {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        
  
        
        tryMovePlayer(e.key);
    }
    
    if (e.key === 'ArrowLeft') {
        lastPlayerDirection = 'L';
        resetIdleState();
    } else if (e.key === 'ArrowRight') {
        lastPlayerDirection = 'R';
        resetIdleState();
    }
});

// 중력 적용 인터벌
const gravityInterval = setInterval(applyGravity, 275);

// 벽 충돌 경고 시스템
//, 시스탬창도 개선

const plusHp = setInterval(() => {


    if(playerHp<100){
        playerHp+=0.5;
    }
    if(playerHp<=1){
    sendChat(true,"사망하였습니다. 장비/도구/갑옷 초기화됩니다.","Server");
ArmorState=null;//갑옷
WeaponState="맨손";//무기
EquipmentState=null;
    playerHp=70;
    power=1;
    attackDmg=1;
        playerArmor=1;
                document.querySelector(".armorBox").style.width = `${playerArmor}px`;
    setAllItemsToZero();
     goHomeScreen();
    }
    updateHpDisplay();
}, 500);

var fallingHeight=0;
const gravityHit = setInterval(() => {
    if(isPlayerFalling==true){
      fallingHeight+=2.5;
    }else if(isPlayerFalling==false&&fallingHeight!=0){
        if(fallingHeight>=15){
            playerHp-=fallingHeight+ (playerArmor/8);
        effectSound("hurt");
        }
        fallingHeight=0;
    }
    updateHpDisplay();
}, 100);

// 이탈 포인트 감소 시스템
const wallPointReducer = setInterval(() => {
    waring_wall = Math.max(waring_wall - 1, 0);
}, 10000);
//////////////////////////////////////////////////////////////////////
//보스 관련함수
function getEquipmentImageName(value) {
  const valueMap = {
    '나무갑옷': '127', '선인장갑옷': '128', '벌갑옷': '129',
    '흑요석갑옷': '130', '네크로갑옷': '131',
    '철검': '118', '철활': '119', '맨손': '132',
    '선인장곡괭이': '115', '철곡괭이': '116', '다이아곡괭이': '117'
  };
  if (!valueMap[value]) {
    console.log(`${valueMap[value]}`);return '';
    }else{
        console.log(`img/${valueMap[value]}.png`);
  return `img/${valueMap[value]}.png`;
    }

}

window.addEventListener('load', () => {
  const containers = {
    armor: document.querySelector('.saveDisplay2'),
    weapon: document.querySelector('.saveDisplay3'),
    tool: document.querySelector('.saveDisplay4')
  };

  setInterval(() => {
    const states = {
      armor: ArmorState,
      weapon:WeaponState,
      tool:EquipmentState
    };

    Object.entries(containers).forEach(([type, container]) => {
      if (!container) return;
      container.innerHTML = '';

      const state = states[type];
      if (!state) return;

      const img = new Image();
      img.className = `equipment-icon ${type}`;
      img.src = getEquipmentImageName(state);
      img.onerror = (e) => console.error(`이미지 로드 실패: ${e.target.src}`);
      container.appendChild(img);
    });
  }, 5000);
});



///////////////////

//▼▼▼ 보스 체력바 업데이트 함수 ▼▼▼
function updateBossBar(currentHp) {
    const bossBar = document.querySelector(".bossBar");
    bossBar.style.display = "block";
    
    // 1HP = 10px, 최대 1000px
    const pixelWidth = currentHp * 10;
    bossBar.style.width = `${pixelWidth}px`;
    
    // 체력 백분율 계산 (색상 변화용)
    const percent = (currentHp / BOSS_MAX_HP) * 100;
    
    // 색상 변화
    if(percent <= 20) {
        bossBar.style.backgroundColor = '#ff0000';
    } else if(percent <= 40) {
        bossBar.style.backgroundColor = '#ffa500';
    }
    else if(percent <= 60){
        bossBar.style.backgroundColor = 'yellow';
    }
    else {
        bossBar.style.backgroundColor = '#00ff00';
    }
    
    // 텍스트 업데이트
    bossBar.textContent = `보스 체력: ${Math.round(currentHp)}/${BOSS_MAX_HP}`;
}


var bossGlobalX=null;
var bossGlobalY=null;
// ▼▼▼ 보스 시스템 전체 코드 (플레이어 이동 로직 제외) ▼▼▼
// 보스 최적화 버전 전체 코드

const BOSS_MAX_HP = 100;
let hp = BOSS_MAX_HP;
let bossAliveGlobal = false;
let attackDmg = 1;
let attackDmg2 = 1;
let keydownListenerAdded = false;

let isInvincible = false;
let invincibilityTimer = null;

function activateInvincibility() {
    console.log("[무적] 활성화");
    
    // 기존 타이머 취소
    if (invincibilityTimer) {
        clearTimeout(invincibilityTimer);
        console.log("[무적] 기존 타이머 취소");
    }
    
    isInvincible = true;
    
    invincibilityTimer = setTimeout(() => {
        isInvincible = false;
        invincibilityTimer = null;
        console.log("[무적] 비활성화");
    }, 1000);
}


// DOM 캐시
const domCache = {};

// 보스 바 쓰로틀링
let lastBossBarUpdate = 0;
function updateBossBarWithCooldown(hp) {
    const now = Date.now();
    if (now - lastBossBarUpdate >= 400) {
        updateBossBar(hp);
        sendChat(true, `공격력 :${attackDmg2} 체력 : ${BossSystem.getHp()}`, "BOSS");
        playRandomAttackSound();
        BossSystem.takeDamage(attackDmg2);
        lastBossBarUpdate = now;
    } else {
        sendChat(true, `공격 쿨타입입니다!`, "BOSS");
    }
}

// 보스 체력바 최적화
function updateBossBar(currentHp) {
    const bossBar = domCache.bossBar || (domCache.bossBar = document.querySelector(".bossBar"));
    bossBar.style.display = "block";
    bossBar.style.width = `${currentHp * 10}px`;
    const percent = (currentHp / BOSS_MAX_HP) * 100;
    if(percent <= 35) bossBar.style.backgroundColor = '#ff0000';
    else if(percent <= 50) bossBar.style.backgroundColor = '#ffa500';
    else if(percent <= 65) bossBar.style.backgroundColor = 'yellow';
    else bossBar.style.backgroundColor = '#00ff00';
    bossBar.textContent = `보스 체력: ${Math.round(currentHp)}/${BOSS_MAX_HP}`;
}


// 보스 시스템
const BossSystem = (function() {
    // 상태 변수
    let bossX = 50, bossY = 50;
    let prevBossX = -1, prevBossY = -1;
    let isAlive = true;
    let isEnraged = false;
    let velocityY = 0;
    let isJumping = false;
    let aiInterval = 600;
    let regenInterval =900;
    let physicsInterval = 2100;
    let jumpHeight = 8;
    let jumpInterval = 800;
    let lastJumpTime = Date.now();
    let originalAIInterval = 450;
    let lastPhysics = 0, lastAI = 0, lastRegen = 0;
    let lastBloodDownTime = 0; // 마지막 사운드 재생 시간 (timestamp)
    const BLOOD_DOWN_COOLDOWN = 300; // 쿨타임(ms) – 1초
    // 상수
    const GRAVITY = 0.8;
    const JUMP_HEIGHT_MAX = 60;
    const JUMP_INTERVAL_MIN = 500;
    const JUMP_INTERVAL_MAX = 2500;

    // 내부 유틸
    function getBlock(x, y) {
        const key = `xy${x},${y}`;
        return domCache[key] || (domCache[key] = document.getElementById(key));
    }
    function clearPreviousEffects() {
        for(let x = -2; x <= 2; x++) for(let y = -2; y <= 2; y++) {
            const block = getBlock(prevBossX + x, prevBossY + y);
            if(block) {
                block.style.border = "";
                block.style.boxShadow = "";
                block.style.transform = "";
                block.style.transition = "";
            }
        }
    }
    function applyNewEffects(isEnraged = false) {
        const borderColor = isEnraged ? "#ffa500" : "#00BFFF";
        const glowColor = isEnraged ? "#ffa50077" : "#00BFFF77";
        const scale = isEnraged ? 2 : 1;
        for(let x = -2; x <= 2; x++) for(let y = -2; y <= 2; y++) {
            const block = getBlock(bossX + x, bossY + y);
            if(block) {
                block.style.border = `1px solid ${borderColor}`;
                block.style.boxShadow = `0 0 16px 8px ${glowColor}`;
                block.style.transform = `scale(${scale})`;
                block.style.transition = 'transform 0.5s, border-color 0.2s, box-shadow 0.2s';
            }
        }
    }
    function isOnGround() {
        const checkPoints = [{x:0,y:3}, {x:1,y:3}, {x:-1,y:3}];
        return checkPoints.some(p => {
            const block = getBlock(bossX + p.x, bossY + p.y);
            return block && !allowItems.includes(block.dataset.bid);
        });
    }
    function constrainPosition() {
        const player = getCurrentCenterBlockPlayer();
        const minBossY = Math.max(MAP_MIN_Y + 2, player.y - 5);
        const maxBossY = Math.min(MAP_MAX_Y - 2, player.y + 30);
        bossX = Math.max(MAP_MIN_X + 2, Math.min(bossX, MAP_MAX_X - 2));
        bossY = Math.max(minBossY, Math.min(bossY, maxBossY));
    }
    // 점프력 계산
    const calculateJumpForce = (height) => -Math.sqrt(2 * Math.abs(GRAVITY) * height);

    // 메인 루프
    function mainLoop(ts) {
        if (!isAlive) return;
        const now = performance.now();
        // AI
        if (now - lastAI > aiInterval) {
            BossSystem.ai();
            lastAI = now;
        }
        // Physics
        if (now - lastPhysics > physicsInterval) {
            physicsUpdate();
            lastPhysics = now;
        }
        // Regen
        if (now - lastRegen > regenInterval) {
            regenerateHealth();
            lastRegen = now;
        }
        requestAnimationFrame(mainLoop);
    }
    function regenerateHealth() {
        if (!isAlive) return;
        if (hp < BOSS_MAX_HP) {
            hp = Math.min(hp + 1, BOSS_MAX_HP);
            updateBossBar(hp);
        }
    }
    function physicsUpdate() {
        if (!isAlive) return;
        const player = getCurrentCenterBlockPlayer();
        BossSystem.checkCollision(player);
        if (!isOnGround()) {
            velocityY += GRAVITY;
            bossY += Math.round(velocityY);
        } else {
            velocityY = 0;
            isJumping = false;
        }
        constrainPosition();
    }

    // 텔레포트 기능을 위한 새 변수 추가
    let lastTeleportTime = 0;
    let teleportInterval = 12000; // 10초마다 텔레포트 (밀리초 단위)
    let teleportThreshold = 50; // 체력이 이 값 이하일 때 텔레포트 발동

    
    // 상수 및 기존 유틸리티 함수들...

    // 메인 루프에 텔레포트 검사 추가
    function mainLoop(ts) {
        if (!isAlive) return;
        const now = performance.now();
        
        // 텔레포트 체크 추가
        if (hp <= teleportThreshold && now - lastTeleportTime > teleportInterval) {
            teleportAbovePlayer();
            lastTeleportTime = now;
        }
        
        // 기존 AI 체크
        if (now - lastAI > aiInterval) {
            BossSystem.ai();
            lastAI = now;
        }
        
        // 기존 Physics 체크
        if (now - lastPhysics > physicsInterval) {
            physicsUpdate();
            lastPhysics = now;
        }
        
        // 기존 Regen 체크
        if (now - lastRegen > regenInterval) {
            regenerateHealth();
            lastRegen = now;
        }
        
        requestAnimationFrame(mainLoop);
    }
    
    // 텔레포트 함수 구현
    function teleportAbovePlayer() {
        const player = getCurrentCenterBlockPlayer();
        
        // 이전 위치의 효과 제거
        if(prevBossX !== -1) clearPreviousEffects();
        
        // 보스 위치 업데이트 - 플레이어 머리 위 10칸으로 이동
        bossX = player.x + (Math.floor(Math.random() * 20) - 10);
        bossY = player.y - (Math.floor(Math.random() * 30) +5);
        
        // 위치 제약 적용
        constrainPosition();
        
        // 새 위치에 효과 적용
        applyNewEffects(isEnraged);
        
        // 이전 위치 기록 업데이트
        prevBossX = bossX;
        prevBossY = bossY;
        
        // 시각적/청각적 피드백 제공
        sendChat(true, "보스가 텔레포트했습니다!", "시스템");
        effectSound("teleport");
        //effectSound("teleport"); // 텔레포트용 효과음이 있다고 가정
    }

    // API
    return {
        init: function() {
            const player = getCurrentCenterBlockPlayer();
            bossX = player.x + Math.floor(Math.random() * 61) - 30;
            bossY = player.y - 10;
            constrainPosition();
            this.updatePosition();
            aiInterval = 550; physicsInterval = 2000; regenInterval = 900;
            lastAI = lastPhysics = lastRegen = performance.now();
            isAlive = true; isEnraged = false; hp = BOSS_MAX_HP;
            lastTeleportTime = performance.now(); // 텔레포트 시간 초기화 추가
            requestAnimationFrame(mainLoop);
            
        },

       
        getHp: () => hp,
        setHp: (value) => { hp = value; },
        getPosition: () => ({ x: bossX, y: bossY }),
        updatePosition: function() {
            if(prevBossX !== -1) clearPreviousEffects();
            applyNewEffects(isEnraged);
            prevBossX = bossX;
            prevBossY = bossY;
        },
        move: function(dir) {
            if(!isAlive) return;
            if(dir === 'up') bossY--;
            else if(dir === 'down') bossY++;
            else if(dir === 'left') bossX--;
            else if(dir === 'right') bossX++;
            constrainPosition();
            this.updatePosition();
        },
        ai: function() {
            const player = getCurrentCenterBlockPlayer();
            const dx = player.x - bossX;
            const dy = player.y - bossY;
            const angle = Math.atan2(dy, dx);
            if (Math.abs(Math.cos(angle)) > 0.5) this.move(Math.cos(angle) > 0 ? 'right' : 'left');
            if (Math.abs(Math.sin(angle)) > 0.5) this.move(Math.sin(angle) > 0 ? 'down' : 'up');
            const now = Date.now();
            if(now - lastJumpTime > jumpInterval) {
                this.jump(jumpHeight);
                lastJumpTime = now;
                jumpInterval = Math.max(JUMP_INTERVAL_MIN, jumpInterval - 50);
            }
        },
        jump: function(height) {
            if(isOnGround()) {
                velocityY = calculateJumpForce(height);
                isJumping = true;
                setTimeout(() => {
                    const player = getCurrentCenterBlockPlayer();
                    const distance = Math.hypot(player.x - bossX, player.y - bossY);
                    if(distance > 3) jumpHeight = Math.min(jumpHeight + 1, JUMP_HEIGHT_MAX);
                    else { jumpHeight = 2; jumpInterval = 1250; }
                    
               
       


                }, 500);
            }
        },
        checkCollision: function(player) {
            if(!isAlive) return;
            if(Math.abs(player.x - bossX) <= 2 && Math.abs(player.y - bossY) <= 2) {
                playerHp = Math.max(0, (playerHp - (28 -(Math.floor(Math.random() * playerArmor) + playerArmor/3) )));
                effectSound("hurt");
                activateInvincibility(); 
                updateHpDisplay();
                this.takeDamage(attackDmg);
                playRandomAttackSound();
            }
        },

     // 추가: 텔레포트 임계값 설정 함수
        setTeleportThreshold: function(value) {
            teleportThreshold = value;
        },
        
        // 추가: 텔레포트 간격 설정 함수
        setTeleportInterval: function(ms) {
            teleportInterval = ms;
        }, 


        updateBossState: function() {
            const shouldEnrage = (hp / BOSS_MAX_HP) <= 0.35;
            if(shouldEnrage && !isEnraged) {
                isEnraged = true;
                aiInterval = 260; physicsInterval = 1400; regenInterval = 400;
                applyNewEffects(true);
                sendChat(true, "보스가 분노합니다! 체력회복/속도/공격주기가 빨라집니다.", "시스템");
                effectSound("bloodDown");
            } else if(!shouldEnrage && isEnraged) {
                isEnraged = false;
                aiInterval = originalAIInterval;
                applyNewEffects(false);
            }
        },

        
       
        takeDamage: function(amount) {
            if(!isAlive) return;
            hp = Math.max(0, hp - amount);
            updateBossBar(hp);
            this.updateBossState();
            if(playerHp<=10 && hp<80){
                hp = Math.max(0, hp +5);
                updateBossBar(hp);
                sendChat(true, `플레이어 체력이 낮아 보스가 체력을 회복합니다!`, "Server");
            }
            // 피격 효과
            (function flashEffect() {
                const flashColor = "#ff0000";
                const originalColor = isEnraged ? "#ffa500" : "#00BFFF";
                const originalColor2 = isEnraged ? "#ffa50077" : "#00BFFF77";
                for(let x = -2; x <= 2; x++) for(let y = -2; y <= 2; y++) {
                    const block = getBlock(bossX + x, bossY + y);
                    if(block) {
                        block.style.transition = "border-color 0.1s";
                        block.style.borderColor = flashColor;
                        block.style.boxShadow = `0 0 16px 8px ${originalColor2}`;
                    }
                }
                setTimeout(() => {
                    for(let x = -2; x <= 2; x++) for(let y = -2; y <= 2; y++) {
                        const block = getBlock(bossX + x, bossY + y);
                        if(block) {
                            block.style.borderColor = originalColor;
                            block.style.boxShadow = `0 0 16px 8px ${originalColor2}`;
                        }
                    }
                }, 300);
            })();
            if(hp === 0) {
                isAlive = false;
                clearPreviousEffects();
                const bossBar = domCache.bossBar || (domCache.bossBar = document.querySelector(".bossBar"));
                bossBar.style.display = 'none';
                applyNewEffects(false);
                sendChat(true, "보스 처치!", "Server");
                showFlashEffect();
                
                bossAliveGlobal = false;
                musicSlime_king.pause();
                const trophyId = 122 + Math.floor(Math.random() * 3);
                itemBagGet(trophyId, 1);
                const trophyNames = {122: "동트로피", 123: "은트로피", 124: "금트로피"};
                sendChat(true, `${trophyNames[trophyId]}를 획득했습니다!`, "Server");
                bossStart = false;
                effectSound("bossWin");
            }
        }
    };
})();
//////////////////////////////////////
const skyBlockCodes = ["15", "b15b"]; // 하늘블럭 코드

ZOMBIE_TYPES = {
  TIER1A:  { color: '#ccffcc', prob: 13.0, health: 3, damage: 7, jump: 5 },
  TIER1B:  { color: '#bbffbb', prob: 11.5, health: 3, damage: 8, jump: 6 },
  
  TIER2A:  { color: '#00ff00', prob: 9.5, health: 4, damage: 9, jump: 7 },
  TIER2B:  { color: '#00ee00', prob: 8.5, health: 4, damage: 10, jump: 8 },
  
  TIER3A:  { color: '#ffffaa', prob: 6.5, health: 5, damage: 10, jump: 8 },
  TIER3B:  { color: '#ffff99', prob: 5.0, health: 5, damage: 11, jump: 9 },
  
  TIER4A:  { color: '#ffff33', prob: 3.5, health: 6, damage: 12, jump: 10 },
  TIER4B:  { color: '#ffff00', prob: 2.5, health: 6, damage: 13, jump: 11 },
  
  TIER5A:  { color: '#ffdd88', prob: 2.3, health: 8, damage: 14, jump: 11 },
  TIER5B:  { color: '#ffcc66', prob: 2.0, health: 8, damage: 15, jump: 12 },
  
  TIER6A:  { color: '#ffb733', prob: 1.8, health: 9, damage: 15, jump: 12 },
  TIER6B:  { color: '#ffa500', prob: 1.6, health: 9, damage: 16, jump: 13 },
  
  TIER7A:  { color: '#ffb6c1', prob: 1.4, health: 12, damage: 18, jump: 19 },
  TIER7B:  { color: '#ffc0cb', prob: 1.2, health: 12, damage: 19, jump: 20 },
  
  TIER8A:  { color: '#ff7f7f', prob: 1.1, health: 14, damage: 19, jump: 21 },
  TIER8B:  { color: '#ff6666', prob: 0.9, health: 14, damage: 20, jump: 22 },
  
  TIER9A:  { color: '#ff3333', prob: 0.7, health: 15, damage: 21, jump: 24 },
  TIER9B:  { color: '#ff0000', prob: 0.6, health: 15, damage: 22, jump: 25 },
  
  TIER10A: { color: '#444444', prob: 0.4, health: 25, damage: 24, jump: 34 },
  TIER10B: { color: '#555555', prob: 0.3, health: 25, damage: 25, jump: 35 }
};
/*



*/
let attackFirst=true;
const ZombieSystem = (function() {
const MAX_ZOMBIES = 3;
const SPAWN_INTERVAL = 40000;
let activeZombies = [];

class Zombie {
constructor(type) {
this.type = type;
this.x = 0;
this.y = 0;
this.health = type.health;
this.velocityY = 0;
this.lastJump = Date.now();
this.jumpInterval = 2000 + Math.random() * 3000;
this.element = this.initDOM();
this.isDead = false;
}

initDOM() {
const elem = document.createElement('div');
elem.className = 'zombie';
elem.style.cssText = `
width:30px; height:30px; position:absolute;
box-shadow:0 0 10px ${this.type.color}77;
z-index:900;
`;
document.body.appendChild(elem);
return elem;
}

updatePosition() {
this.element.style.transform = `translate(${this.x * 30}px, ${this.y * 30}px)`;
}




isGrounded() {
const belowX = Math.round(this.x);
const belowY = Math.round(this.y + 1);
const block = document.getElementById(`xy${belowX},${belowY}`);

// 허용 블럭 체크 강화
if (block) {
const itemCode = block.dataset.item || '';
if (allowItems.includes(itemCode)) return false;
if (block.dataset.empty === "true") return false;
}
return !!block;
}

applyPhysics() {
if (!this.isGrounded()) {
this.velocityY += 0.5; // 중력 증가
this.y += this.velocityY * 0.1;
if (this.y > 150) this.remove();
} else {
this.velocityY = 0;
}
}

moveTowards(targetX, targetY) {
const dx = targetX - this.x;
const dy = targetY - this.y;
const dist = Math.hypot(dx, dy);

if (dist > 15) return;

// 2D 이동 벡터 계산
const speed = 0.9 + Math.random() * 0.6; // 속도 증가
if (dist > 0.1) {
this.x += (dx / dist) * speed;
this.y += (dy / dist) * speed * 1.5; // Y축 이동 추가 (80% 수평 속도)
}

// 장애물 회피 점프
if (Math.abs(dy) > 2 && this.isGrounded()) {
this.jump();
}
}

jump() {
if (this.isGrounded() && Date.now() - this.lastJump > this.jumpInterval) {
this.velocityY = -Math.sqrt(4.5 * 0.8 * this.type.jump); // 점프력 증가
this.lastJump = Date.now();
this.jumpInterval = 750 + Math.random() * 1000;
}
}


takeDamage(dmg) {
if (this.isDead) return;
this.health -= dmg;

// 피격 이펙트 표시
showDamageEffect(this.x, this.y, dmg);

this.element.style.transform = `translate(${this.x * 30}px, ${this.y * 30}px) scale(1.2)`;
setTimeout(() => {
this.element.style.transform = `translate(${this.x * 30}px, ${this.y * 30}px) scale(1)`;
}, 100);
playRandomAttackSound();
if (this.health <= 0) this.remove();
}

remove() {
if (this.isDead) return;
this.isDead = true;
this.element.remove();
const idx = ZombieSystem.activeZombies.indexOf(this);
if (idx > -1) ZombieSystem.activeZombies.splice(idx, 1);
}
}

function getRandomZombieType() {
const total = Object.values(ZOMBIE_TYPES).reduce((sum, t) => sum + t.prob, 0);
let random = Math.random() * total;
for (const type of Object.values(ZOMBIE_TYPES)) {
if (random < type.prob) return type;
random -= type.prob;
}
return ZOMBIE_TYPES.GREEN;
}
    function isNight() {
        return typeof dayTimeHour !== 'undefined' && (dayTimeHour >= 18 || dayTimeHour < 6);
    }



function spawnZombie() {
if (!isNight() || activeZombies.length >= MAX_ZOMBIES) return;
const player = getCurrentCenterBlockPlayer();
if (!player) return;
const type = getRandomZombieType();
const zombie = new Zombie(type);

// 플레이어 주변 랜덤 위치 생성
const angle = Math.random() * Math.PI * 2;
const dist = 12 + Math.random() * 14;
zombie.x = Math.round(player.x + Math.cos(angle) * dist);

// 땅 찾기 로직
let foundGround = false;
for (let y = Math.round(player.y); y < player.y + 20; y++) {
const block = document.getElementById(`xy${Math.floor(zombie.x)},${y}`);
if (block && block.dataset.empty === "false") {
zombie.y = y - 1;
foundGround = true;
break;
}
}
if (!foundGround) {
zombie.remove();
return;
}

activeZombies.push(zombie);
}

function updateZombies() {
const player = getCurrentCenterBlockPlayer();
if (!player) return;

activeZombies.forEach(zombie => {
// 플레이어 위치 보정 (머리 위가 아닌 중심점)
const targetY = player.y; // 플레이어 발 위치 추적

zombie.applyPhysics();
zombie.moveTowards(player.x, targetY); // Y축 목표치 수정
zombie.jump();
zombie.updatePosition();


const dx = player.x - zombie.x;
const dy = (player.y - 0.5) - zombie.y;
if (Math.hypot(dx, dy) < 1) {
if (typeof playerHp !== 'undefined' && !isInvincible) {
playerHp -= zombie.type.damage;
if(attackFirst==true){
      sendChat(true, "좀비한테 공격당했습니다.a키 혹은 좌측의 a버튼으로 공격 가능합니다.", "System");
    attackFirst=false;
    
}
effectSound("hurt");
activateInvincibility(); // 무적 활성화
updateHpDisplay && updateHpDisplay();
}
}

});
}

// 피격 이펙트 함수
function showDamageEffect(x, y, damage) {
const effect = document.createElement('div');
effect.textContent = `-${damage}`;
effect.style.cssText = `
position: absolute;
left: ${x * 30}px;
top: ${y * 30 - 20}px;
color: #ff0000;
font-weight: bold;
font-size: 20px;
pointer-events: none;
z-index: 1000;
animation: damageFloat 1s ease-out;
`;
document.body.appendChild(effect);
setTimeout(() => effect.remove(), 1000);
}

// CSS 애니메이션 추가
const style = document.createElement('style');
style.textContent = `
@keyframes damageFloat {
0% { transform: translateY(0); opacity: 1; }
100% { transform: translateY(-50px); opacity: 0; }
}
.zombie { pointer-events:none; }
`;
document.head.appendChild(style);

return {
activeZombies,
spawnZombie,
updateZombies,
Zombie
};
})();

// 시스템 초기화

let zombieSpawnLoop=null;
let zombieUpdateLoop=null;
zombieSpawnLoop = setInterval(ZombieSystem.spawnZombie, 40000);
zombieUpdateLoop = setInterval(ZombieSystem.updateZombies, 250);

// 시스템 초기화

////////////////////


let isWeaponVisible = true; // 무기 고정 이미지 표시 여부
let weaponHideTimeout = null; // 무기 숨김 타임아웃 핸들러
let keydownListenerAdded2 = false; // 중복 리스너 방지용
let keydownListenerAdded3 = true; // 중복 리스너 방지용

let lastAttack2 = 0; // 함수 외부에서 선언

function attackActiveBtn() {
    effectSound("click");

    const now = Date.now();
    if (now - lastAttack2 < 500) return; // 0.5초 쿨타임 적용
    lastAttack2 = now;
    
    playRandomAttackSound();
    
    const player = getCurrentCenterBlockPlayer();
    const bossPos = BossSystem.getPosition();
    
    // 무기 고정 이미지 숨기기
    isWeaponVisible = false;
    if (weaponHideTimeout) clearTimeout(weaponHideTimeout);
    weaponHideTimeout = setTimeout(() => {
        isWeaponVisible = true;
    }, 500); // 0.5초 후 다시 보임

    // 철검 회전 애니메이션 실행
    createSwordAnimation(player.x, player.y);

    const dist = Math.hypot(player.x - bossPos.x, player.y - bossPos.y);
    // ▼▼▼ 수정된 보스/좀비 처리 ▼▼▼
    // 1. 보스 데미지 처리 (Non-blocking)
    if (dist <= 4.5) {
        BossSystem.takeDamage(attackDmg2); // 보스 체력 감소
        updateBossBarWithCooldown(BossSystem.getHp());
    }

    requestAnimationFrame(() => {
        for (const zombie of [...ZombieSystem.activeZombies]) {
            const dx = player.x - zombie.x;
            const dy = player.y - zombie.y;
            if (Math.hypot(dx, dy) <= 3.1) {
                zombie.takeDamage(attackDmg || 10);
            }
        }
    });
}

window.addEventListener('load', () => {
    // 스타일 삽입
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        @keyframes swordRotate {
            from { transform: rotate(-30deg);}
            to { transform: rotate(316deg);}
        }
        .rotating-sword {
            position: absolute;
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            animation: swordRotate 0.2s linear;
            pointer-events: none;
            z-index: 1000;
        }
    `;
    document.head.appendChild(styleElement);

    // 보스 상태 초기화
    if (!bossAliveGlobal) {
        bossAliveGlobal = true;
    }


   

    if (!keydownListenerAdded2) {
        keydownListenerAdded2 = true;
        let lastAttack = 0;

        window.addEventListener('keydown', (e) => {
            // 공격키 a
               
            if (e.key.toLowerCase() === 'a') {
                const now = Date.now();
                if (now - lastAttack < 1000) return; // 0.5초 이내 중복 방지
                lastAttack = now;
  playRandomAttackSound();
                const player = getCurrentCenterBlockPlayer();
                const bossPos = BossSystem.getPosition();
                //playRandomAttackSound();

                if (!player || !bossPos) {
                    console.log("보스가 소환되지 않았습니다");
                    return;
                }

                // 무기 고정 이미지 숨기기
                isWeaponVisible = false;
                if (weaponHideTimeout) clearTimeout(weaponHideTimeout);
                weaponHideTimeout = setTimeout(() => {
                    isWeaponVisible = true;
                }, 500); // 0.5초 후 다시 보임

                // 철검 회전 애니메이션 실행
                createSwordAnimation(player.x, player.y);

                const dist = Math.hypot(player.x - bossPos.x, player.y - bossPos.y);
              // ▼▼▼ 수정된 보스/좀비 처리 ▼▼▼
                // 1. 보스 데미지 처리 (Non-blocking)
                if (dist <= 4.5) {
                    BossSystem.takeDamage(attackDmg2); // 보스 체력 감소[9]
                    updateBossBarWithCooldown(BossSystem.getHp());
                }



                    requestAnimationFrame(() => {
                    for (const zombie of [...ZombieSystem.activeZombies]) {
                    const dx = player.x - zombie.x;
                    const dy = player.y - zombie.y;
                    if (Math.hypot(dx, dy) <= 3.1) {
                    
                    zombie.takeDamage(attackDmg || 10);
                    playRandomAttackSound();
                    }
                    }
                    });



    
            }

            // 포션키 1
            if (e.key.toLowerCase() === '1') {
                // 포션 수량 체크
                if (document.getElementById("i596").innerText >= 1) {
                    const currentTime = Date.now();
                    const cooldown = 9000; // 9초 (밀리초)
                    
                    if (window.lastPotionUse && (currentTime - window.lastPotionUse < cooldown)) {
                        const remain = Math.ceil((cooldown - (currentTime - window.lastPotionUse)) / 90);
                        sendChat(true, `즉발 포션 쿨타임 남음: ${(remain / 10).toFixed(1)}초`, "System");
                        return;
                    }

                    // 포션 사용 처리
                    sendChat(true, "즉발 포션을 마셨습니다(쿨타임 9초) / 단축키 : 1. Hp+25", "System");
                    effectSound("potion");
                    itemBagGet("121", -1);
                    playerHp = Math.min(playerHp + 50, 100);
                    window.lastPotionUse = currentTime;

                    // 쿨타임 완료 알림
                    setTimeout(() => {
                        sendChat(true, "즉발 포션 쿨타임이 완료되었습니다. / 단축키 1", "System");
                    }, cooldown);

                    sendChat(true, `즉발 포션을 마셨습니다. /단축키 1 남은 포션 : ${document.getElementById("i596").innerText}`, "server");
                } else {
                    sendChat(true, `즉발 포션이 부족합니다.`, "server");
                }
            }
        }, true);
    }
});


// 효과음
function playRandomAttackSound() {
    const sounds = ["attack1", "attack2", "attack3"];
    effectSound(sounds[Math.floor(Math.random() * sounds.length)]);
}

// 철검 회전 애니메이션 함수
function createSwordAnimation(playerX, playerY) {
    // 플레이어 주변 3x3 블록에 애니메이션 적용
    for (let x = playerX; x <= playerX ; x++) {
        for (let y = playerY-2; y <= playerY-2; y++) {
            // 중앙(플레이어 위치)은 제외할 경우 아래 조건 사용
            // if (x === playerX && y === playerY) continue;
            
            const blockElement = document.getElementById(`xy${x},${y}`);
            if (blockElement) {
                // 철검 이미지 생성
                const swordImg = document.createElement('img');
                if(WeaponState=="맨손") swordImg.src = 'img/132.png';
                else if(WeaponState=="철검") swordImg.src = 'img/118.png';
                else swordImg.src = 'img/132.png';
                swordImg.className = 'rotating-sword';
                
                // 블록에 이미지 추가
                blockElement.style.position = 'relative';
                blockElement.appendChild(swordImg);
                
                // 애니메이션 종료 후 이미지 제거
                swordImg.addEventListener('animationend', () => {
                    blockElement.removeChild(swordImg);
                });
            }
        }
    }
}


//////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
var creativeMode=false;
function gameModeChange(inputNum){
if(inputNum==0){
    sendChat(true,"서바이벌 모드로 변경되었습니다.","server Mode");
    creativeMode=false;
    power=0.2;
    setAllItemsToZero();
    itemBagGet(64,999);//상호작용
    return;
    
}else if(inputNum==1){
    sendChat(true,"크레이티브 모드로 변경되었습니다.","server Mode");
    creativeMode=true;
    setAllItemsTo999();
    power=10;
    return;
}

}
///////////////
function setAllItemsTo999() {
    // itemBagGet에 사용할 모든 블럭 ID 배열
    const allItemIds = [
    1, 2, 3, 4, 7, 8, 10, 11, 12, 13, 14, 46, 48, 49, 50, 51, 52, 
    53, 54, 55,57, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 
    73, 76, 77, 78,79,80, 81, 82, 83, 84, 86, 95, 96, 97, 98, 99, 
    100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 
    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 
    124,125,126, 149
    ];

    allItemIds.forEach(function(bid) {
        // 현재 수량 확인
        let elementId = null;
        switch(bid.toString()) {
            case "1": elementId = "i00"; break;    // 잔디
    case "2": elementId = "i01"; break;    // 흙
    case "3": elementId = "i02"; break;    // 진흙
    case "4": elementId = "i03"; break;    // 나무
    case "7": elementId = "i21"; break;    // 구름
    case "8": elementId = "i22"; break;    // 먹구름
    case "10": elementId = "i06"; break;   // 조약돌
    case "11": elementId = "i07"; break;   // 철광석
    case "12": elementId = "i08"; break;   // 루비
    
    //▼▼▼ 특수 블록 ▼▼▼
    case "13": elementId = "i10"; break;   // 에메랄드
    case "14": elementId = "i11"; break;   // 다이아
    case "46": elementId = "i12"; break;   // 우주하늘
    case "48": elementId = "i04"; break;   // 나뭇잎
    case "49": elementId = "i090"; break;  // 제작나무
    case "50": elementId = "i16"; break;   // 벌통
    case "51": elementId = "i17"; break;   // 꿀블럭
    case "52": elementId = "i14"; break;   // 흑요석
    
    //▼▼▼ 시설물 ▼▼▼
    case "53": elementId = "i192"; break;  // 화강암
    case "54": elementId = "i13"; break;   // 신비한블럭
    case "55": elementId = "i37"; break;   // 물
    case "57": elementId = "i191"; break;   // 던전블록1
    case "61": elementId = "i05"; break;   // 던전가시
    case "62": elementId = "i15"; break;   // 횃불
    case "63": elementId = "i09"; break;   // 표지판
    case "64": elementId = "i092"; break;  // 상호작용
    
    //▼▼▼ 폭발물 ▼▼▼
    case "65": elementId = "i19"; break;   // TNT
    case "66": elementId = "i190"; break;  // 쥬크박스
    case "73": elementId = "i20"; break;   // TNT_VER2
    
    //▼▼▼ 문 관련 ▼▼▼
    case "76": elementId = "i24"; break;   // 닫힌문상단
    case "77": elementId = "i25"; break;   // 닫힌문하단

    //트리
    case "79": elementId = "i23"; break;   // 트리

    
    //▼▼▼ 지옥 블록 ▼▼▼
    case "80": elementId = "i26"; break;   // 재블럭
    case "81": elementId = "i27"; break;   // 지옥석
    case "82": elementId = "i28"; break;   // 단단한지옥석
    case "83": elementId = "i29"; break;   // 불타는화염
    case "84": elementId = "i290"; break;  // 핏빛돌
    
    //▼▼▼ 상자 ▼▼▼
    case "67": elementId = "i31"; break;   // 상자
    case "68": elementId = "i32"; break;   // 정글상자
    case "69": elementId = "i33"; break;   // 황금상자
    case "70": elementId = "i34"; break;   // 스타트패키지
    case "71": elementId = "i36"; break;   // 흑요석상자
    case "72": elementId = "i35"; break;   // 하늘상자
    case "126": elementId = "i61"; break;   // 고대의상자

    //▼▼▼ 액체 ▼▼▼
    case "86": elementId = "i38"; break;   // 용암
    case "78": elementId = "i39"; break;   // 유리
    
    //▼▼▼ 동굴 블록 ▼▼▼
    case "95": elementId = "i390"; break;  // 폭탄

    //case "96": elementId = "i43"; break;   // 조합대

    case "97": elementId = "i40"; break;   // 모루
    case "98": elementId = "i41"; break;   // 화로
    case "99": elementId = "i42"; break;   // 모닥불
    
    //▼▼▼ 사막 블록 ▼▼▼
    case "100": elementId = "i292"; break; // 거미줄
    case "101": elementId = "i44"; break;  // 얼음
    case "102": elementId = "i45"; break;  // 단단한얼음
    case "103": elementId = "i46"; break;  // 눈
    case "104": elementId = "i47"; break;  // 눈블럭
    case "105": elementId = "i48"; break;  // 크리스탈블럭
    case "106": elementId = "i49"; break;  // 모래
    case "107": elementId = "i490"; break; // 모래벽돌
    case "108": elementId = "i392"; break; // 사암
    case "109": elementId = "i391"; break; // 선인장
    
    //▼▼▼ 기계 ▼▼▼
    case "110": elementId = "i491"; break; // 광산수레
    case "111": elementId = "i492"; break; // 철로
    case "112": elementId = "i54"; break;  // 핵폭탄
    
    //▼▼▼ 장식 ▼▼▼
    case "113": elementId = "i18"; break;  // 밧줄(사다리)
    case "114": elementId = "i091"; break; // 연기
    case "149": elementId = "i291"; break; // 액자
    
    //▼▼▼ 도구 ▼▼▼
    case "115": elementId = "i590"; break; // 선인장곡괭이
    case "116": elementId = "i591"; break; // 철곡괭이
    case "117": elementId = "i592"; break; // 다이아곡괭이
    
    //▼▼▼ 무기/아이템 ▼▼▼
    case "118": elementId = "i593"; break; // 철검
    case "119": elementId = "i594"; break; // 철활
    case "120": elementId = "i595"; break; // 화살
    case "121": elementId = "i596"; break; // 포션
    
    //▼▼▼ 트로피 ▼▼▼
    case "122": elementId = "i597"; break; // 동트로피
    case "123": elementId = "i598"; break; // 
    case "124": elementId = "i599"; break; // 
    case "125": elementId = "i60"; break; // 플랫폼

            default: return;
        }
        const el = document.getElementById(elementId);
        if (!el) return;
        const current = parseInt(el.innerText) || 0;
        const diff = 999 - current;
        if (diff > 0) {
            itemBagGet(bid, diff);
        }
    });
}


function setAllItemsToZero() {
    const allItemIds = [
    1, 2, 3, 4, 7, 8, 10, 11, 12, 13, 14, 46, 48, 49, 50, 51, 52, 
    53, 54, 55,57, 61, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 
    73, 76, 77, 78,79,80, 81, 82, 83, 84, 86, 95, 96, 97, 98, 99, 
    100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 
    112, 114, 115, 116, 117, 118, 119, 120, 122, 123, 
    124,126,149
    ];

    allItemIds.forEach(function(bid) {
        let elementId = null;
        switch(bid.toString()) {
    //▼▼▼ 기본 블록 ▼▼▼
    case "1": elementId = "i00"; break;    // 잔디
    case "2": elementId = "i01"; break;    // 흙
    case "3": elementId = "i02"; break;    // 진흙
    case "4": elementId = "i03"; break;    // 나무
    case "7": elementId = "i21"; break;    // 구름
    case "8": elementId = "i22"; break;    // 먹구름
    case "10": elementId = "i06"; break;   // 조약돌
    case "11": elementId = "i07"; break;   // 철광석
    case "12": elementId = "i08"; break;   // 루비
    
    //▼▼▼ 특수 블록 ▼▼▼
    case "13": elementId = "i10"; break;   // 에메랄드
    case "14": elementId = "i11"; break;   // 다이아
    case "46": elementId = "i12"; break;   // 우주하늘
    case "48": elementId = "i04"; break;   // 나뭇잎
    case "49": elementId = "i090"; break;  // 제작나무
    case "50": elementId = "i16"; break;   // 벌통
    case "51": elementId = "i17"; break;   // 꿀블럭
    case "52": elementId = "i14"; break;   // 흑요석
    
    //▼▼▼ 시설물 ▼▼▼
    case "53": elementId = "i192"; break;  // 화강암
    case "54": elementId = "i13"; break;   // 신비한블럭
    case "55": elementId = "i37"; break;   // 물
    case "57": elementId = "i191"; break;   // 던전블록1
    case "61": elementId = "i05"; break;   // 던전가시
    case "63": elementId = "i09"; break;   // 표지판
    //case "64": elementId = "i092"; break;  // 상호작용
    
    //▼▼▼ 폭발물 ▼▼▼
    case "65": elementId = "i19"; break;   // TNT
    case "66": elementId = "i190"; break;  // 쥬크박스
    case "73": elementId = "i20"; break;   // TNT_VER2
    
    //▼▼▼ 문 관련 ▼▼▼
    case "76": elementId = "i24"; break;   // 닫힌문상단
    case "77": elementId = "i25"; break;   // 닫힌문하단
    

    //트리
    case "79": elementId = "i23"; break;   // 트리

    //▼▼▼ 지옥 블록 ▼▼▼
    case "80": elementId = "i26"; break;   // 재블럭
    case "81": elementId = "i27"; break;   // 지옥석
    case "82": elementId = "i28"; break;   // 단단한지옥석
    case "83": elementId = "i29"; break;   // 불타는화염
    case "84": elementId = "i290"; break;  // 핏빛돌
    
    //▼▼▼ 상자 ▼▼▼
    case "67": elementId = "i31"; break;   // 상자
    case "68": elementId = "i32"; break;   // 정글상자
    case "69": elementId = "i33"; break;   // 황금상자
    case "70": elementId = "i34"; break;   // 스타트패키지
    case "71": elementId = "i36"; break;   // 흑요석상자
    case "72": elementId = "i35"; break;   // 하늘상자
    case "126": elementId = "i61"; break;   // 하늘상자
    
    //▼▼▼ 액체 ▼▼▼
    case "86": elementId = "i38"; break;   // 용암
    case "78": elementId = "i39"; break;   // 유리
    
    //▼▼▼ 동굴 블록 ▼▼▼
    case "95": elementId = "i390"; break;  // 폭탄
   // case "96": elementId = "i43"; break;   // 조합대
    case "97": elementId = "i40"; break;   // 모루
    case "98": elementId = "i41"; break;   // 화로
    case "99": elementId = "i42"; break;   // 모닥불
    
    //▼▼▼ 사막 블록 ▼▼▼
    case "100": elementId = "i292"; break; // 거미줄
    case "101": elementId = "i44"; break;  // 얼음
    case "102": elementId = "i45"; break;  // 단단한얼음
    case "103": elementId = "i46"; break;  // 눈
    case "104": elementId = "i47"; break;  // 눈블럭
    case "105": elementId = "i48"; break;  // 크리스탈블럭
    case "106": elementId = "i49"; break;  // 모래
    case "107": elementId = "i490"; break; // 모래벽돌
    case "108": elementId = "i392"; break; // 사암
    case "109": elementId = "i391"; break; // 선인장
    
    //▼▼▼ 기계 ▼▼▼
    case "110": elementId = "i491"; break; // 광산수레
    case "111": elementId = "i492"; break; // 철로
    case "112": elementId = "i54"; break;  // 핵폭탄
    
    //▼▼▼ 장식 ▼▼▼
    //case "113": elementId = "i18"; break;  // 밧줄(사다리)
    case "114": elementId = "i091"; break; // 연기
    case "149": elementId = "i291"; break; // 액자
    
    //▼▼▼ 도구 ▼▼▼
    case "115": elementId = "i590"; break; // 선인장곡괭이
    case "116": elementId = "i591"; break; // 철곡괭이
    case "117": elementId = "i592"; break; // 다이아곡괭이
    
    //▼▼▼ 무기/아이템 ▼▼▼
    case "118": elementId = "i593"; break; // 철검
    case "119": elementId = "i594"; break; // 철활
    case "120": elementId = "i595"; break; // 화살
    
    //▼▼▼ 트로피 ▼▼▼
    case "122": elementId = "i597"; break; // 동트로피
    case "123": elementId = "i598"; break; // 
    case "124": elementId = "i599"; break; // 
    
            default: return;
        }
        const el = document.getElementById(elementId);
        if (!el) return;
        const current = parseInt(el.innerText) || 0;
        if (current > 0) {
            itemBagGet(bid, -current); // 현재 수량만큼 차감
        }
    });
}
////////////
var soundVal2=1//0~1(최대값)

function soundVolControl(){

    if(soundVal2==1){
        soundVal2=0;
        document.querySelector(".musicSoundControl").innerText = `${soundVal2.toFixed(1)}`;
    soundVolumePlus(soundVal2);
    sendChat(true,`음소거 상태입니다.: ${soundVal2.toFixed(1)}`,"server");
    effectSound("click");

        return;
    }
    else{
        soundVal2+=0.2;
    document.querySelector(".musicSoundControl").innerText = `${soundVal2.toFixed(1)}`;
    soundVolumePlus(soundVal2);
    sendChat(true,`볼륨이 수정되었습니다 0(최소)~1(최대) : ${soundVal2.toFixed(1)}`,"server");
    effectSound("click");

        return;
    }

    
    
}

const musicList = [
    musicA, musicA2, musicB, musicB2, musicB3, musicB4, musicB5, musicB6, musicB7,
    musicDe_surface, musicDe_underground,
    musicJu_day, musicJu_night, musicJu_underground,
    musicOc_day, musicOc_night,
    musicIc_surface, musicIc_underground,
    musicSp_day,
    musicSlime_king
];

// 볼륨 조절 함수
function soundVolumePlus(inputNum){
    var inputNum2 = parseFloat(inputNum).toFixed(1);
    musicList.forEach(music => {
        if (music) music.volume = inputNum2;
    });
}



let nowZoom = 1;
let zoomTimeout = null;

function zoom(direction) {

    effectSound("click");
    if(direction=="up"||direction=="down"){
    nowZoom += 0.2;
    if (nowZoom > 1.4) nowZoom = 1;

    }else if(direction=="left"||direction=="right"){
    nowZoom += 0.2;
    if (nowZoom > 1.4 ) nowZoom = 1;
    }else{//init
    nowZoom =1;
    }


    // 방향별 기준점 설정 (수정된 부분)
    const originMap = {
        up: "top center",   // 하단 중앙
        down: "bottom center",    // 상단 중앙
        left: "left center",   // 좌측 중앙
        right: "right center"  // 우측 중앙
    };

    const zoomRoot = document.getElementById("zoomRoot");
    zoomRoot.style.transformOrigin = originMap[direction]; // 방향 적용
    zoomRoot.style.transform = `scale(${nowZoom})`;


    // 타이머 리셋
    if (zoomTimeout) clearTimeout(zoomTimeout);
    zoomTimeout = setTimeout(() => {
        zooms();
        nowZoom = 1;
        zoomRoot.style.transform = "scale(1)";
        zoomRoot.style.transformOrigin = "center";
    }, 30000);
}
//////////////////////////////////



/////////////////////////
function toggleDoor(blockId) {
const block = document.getElementById(blockId);
if (!block) return;

// 1. 단일 블록 상태 판별
const isTop = block.classList.contains('b74b') || block.classList.contains('b76b');
const isClosed = block.classList.contains('b76b') || block.classList.contains('b77b');

// 2. 단일 블록 상태 전환
if(isClosed) {
block.className = isTop ? "titlePad b74b" : "titlePad b75b";
effectSound("door_open");
} else {
block.className = isTop ? "titlePad b76b" : "titlePad b77b";
effectSound("door_close");
}

// 3. 이미지 경로 동기화
const bid = block.className.match(/b(\d+)b/)[1];
block.style.backgroundImage = `url(img/${bid}.png)`; // 추가된 코드

// 4. 데이터 속성 동기화
block.dataset.bid = bid;

// 5. 이벤트 리스너 유지
block.onclick = () => toggleDoor(blockId);
effectSound("click");
}

function naverForm() {
    effectSound("click");
    const formBox = document.querySelector(".naverFormBox");
    const wasVisible = formBox.style.display === "flex" || formBox.style.display === "block";

    // 상태 전환 및 UI 업데이트
    if (wasVisible) {
        formBox.style.display = "none";
        document.body.style.overflow = 'auto';
        sendChat(true, "폼 창을 닫았습니다.", "server");
    } else {
        formBox.style.display = "flex";
        document.body.style.overflow = 'hidden';
        sendChat(true, "폼 창을 엽니다. 닫기 버튼으로 닫을 수 있습니다.", "server");
        
        // 닫기 버튼 동적 생성
        if (!formBox.querySelector('.naverFormClose')) {
            const closeBtn = document.createElement('div');
            closeBtn.className = 'naverFormClose';
            closeBtn.innerHTML = '×';
            closeBtn.onclick = naverForm; // 동일 함수 재사용
            formBox.appendChild(closeBtn);
        }

        // iframe 크기 조정
        const iframe = formBox.querySelector("iframe");
        if (iframe) {
            iframe.style.width = "100%";
            iframe.style.height = "100%";
            iframe.style.border = "none";
        }
    }

    // 배경 블러 효과 토글
    document.body.classList.toggle('form-open', !wasVisible);
}

function naverFormClose(){
    sendChat(true,`폼 창을 닫았습니다.`,"server");
    const formBox = document.querySelector(".naverFormBox");
    formBox.style.display = "none";
}

// ▼▼▼ 새 함수 추가 ▼▼▼
// 수정된 changeFrame 함수
function changeFrame(targetElement, frameId) {
    console.log("액자"+targetElement,frameId);
    const newId = frameId.toString().padStart(3, '0');
    const imageUrl = `img/${newId}.png`; // 확장자 변경

    // 배경 이미지 설정
    targetElement.style.backgroundImage = `url(${imageUrl})`;
    targetElement.style.backgroundSize = 'cover';
    targetElement.style.backgroundRepeat = 'no-repeat';

    // 메타데이터 업데이트
    targetElement.dataset.originalBid = newId;
    targetElement.title = `액자 (${newId}번)`;

    // 클래스 업데이트
    targetElement.className = `titlePad b${newId}b`;

    // 이미지 캐싱
    if(!LOADED_IMAGES.has(newId)) {
        const img = new Image();
        img.src = imageUrl;
        img.onload = () => LOADED_IMAGES.add(newId);
    }
}


// 150-166번 클래스 자동 생성
function generateFrameClasses() {
    let css = '';
    for(let i = 150; i <= 166; i++) {
        css += `.b${i}b { 
            background-image: url("img/${i}.bmp");
            background-size: 30px 33px !important;
        }\n`;
    }
    const style = document.createElement('style');
    style.textContent = css;
    document.head.appendChild(style);
}


let nowZoom2=100;

function zooms() {
nowZoom+=20;
   document.body.style.zoom = nowZoom2 + "%";
   if(nowZoom2 == 70) {
      alert("더 이상 축소할 수 없습니다."); // 화면 축소율이 70% 이하일 경우 
      nowZoom2=100;
   }
   if(nowZoom2 == 200) {
      alert("더 이상 확대할 수 없습니다."); // 화면 확대율이 200% 이상일 경우 
      nowZoom2=100;
   }
}
//////////////////////////////////////////////

function saveMap() {
    sendChat(true, "맵 저장을 시작합니다...", "System");
    effectSound("click");
    
    const mapData = {
        version: "3.0",
        metadata: {
            timestamp: new Date().toISOString(),
            dayTime: dayTime,
            dayTimeHour: dayTimeHour,
            userName: userName,
            resolution: `${window.innerWidth}x${window.innerHeight}`
        },
        blocks: [],
        signs: [],
        gameMode:[]
    };

// 블록 데이터 수집 (400x200 그리드 전체 스캔)
for (let y = 0; y < 200; y++) {
    for (let x = 0; x < 300; x++) {
        const block = document.getElementById(`xy${x},${y}`);
        if (block && block.dataset.bid !== "15") {
            mapData.blocks.push({
                x: x,
                y: y,
                bid: String(block.dataset.bid) // 숫자를 문자열로 변환만 수행
            });
        }
    }
}

    // ▼▼▼ 표지판 데이터 수집 추가 ▼▼▼
    for (let x = 0; x < SIGN_ARRAY_WIDTH; x++) {
        for (let y = 0; y < SIGN_ARRAY_HEIGHT; y++) {
            const sign = signArray[x][y];
            if (sign?.title || sign?.content) {
                mapData.signs.push({
                    x: x,
                    y: y,
                    title: sign.title.substring(0, 50), // 최대 50자
                    content: sign.content.substring(0, 200), // 최대 200자
                    timestamp: sign.timestamp
                });
            }
        }
    }

        mapData.gameMode.push({state :`${creativeMode}`});



    // 파일 생성 및 다운로드
    const jsonData = JSON.stringify(mapData, null);
    const blob = new Blob([jsonData], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
  

const now = new Date();

const year = now.getFullYear();
const month = (now.getMonth() + 1).toString().padStart(2, '0');
const day = now.getDate().toString().padStart(2, '0');
const hours = now.getHours().toString().padStart(2, '0');
const minutes = now.getMinutes().toString().padStart(2, '0');

// 결과: WebCraftMapYYYYMMDDHHMM.txt
const filename = `${userjoinName}${month}${day}${hours}${minutes}.txt`;


    const tempLink = document.createElement('a');
    tempLink.href = url;
    tempLink.download = filename;
    tempLink.style.display = 'none';
    document.body.appendChild(tempLink);
    tempLink.click();
    document.body.removeChild(tempLink);
    URL.revokeObjectURL(url);

    sendChat(true, `맵 저장 완료! 블록: ${mapData.blocks.length}개`, "System");
    return true;
}

// ▼▼▼ 맵 불러오기 함수 ▼▼▼
function loadMap() {
    // 1. 파일 입력 요소 생성
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt';
    fileInput.style.display = 'none';

    // 2. 파일 선택 이벤트 처리
    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) {
            document.body.removeChild(fileInput);
            return;
        }

        const reader = new FileReader();
        
        // 3. 파일 읽기 성공 시
        reader.onload = function(e) {
            try {
                // 데이터 파싱
                const rawData = JSON.parse(e.target.result);
                
                // 데이터 검증
                if (!rawData.blocks || !Array.isArray(rawData.blocks)) {
                    throw new Error("잘못된 맵 파일 형식");
                }

                // 데이터 변환
                loadedMapData.blocks = rawData.blocks.map(b => ({
                    x: Number(b.x),
                    y: Number(b.y),
                    bid: String(b.bid).padStart(2, '0')
                })).filter(b => 
                    b.x >= 0 && b.x < 300 && 
                    b.y >= 0 && b.y < 200 &&
                    b.bid !== "15"
                );

                 // ▼▼▼ gameMode 상태 처리 추가 ▼▼▼
                 loadedMapData.gameMode = Array.isArray(rawData.gameMode) 
                    ? rawData.gameMode 
                    : [{ state: "false" }];
                    
                     // ▼▼▼ 표지판 데이터 처리 추가 ▼▼▼
                     if(rawData.signs && Array.isArray(rawData.signs)) {
                    loadedMapData.signs = rawData.signs
                        .map(s => ({
                            x: Number(s.x),
                            y: Number(s.y),
                            title: String(s.title || ""),
                            content: String(s.content || ""),
                            timestamp: s.timestamp || new Date().toISOString()
                        }))
                        .filter(s => 
                            s.x >= 0 && s.x < SIGN_ARRAY_WIDTH &&
                            s.y >= 0 && s.y < SIGN_ARRAY_HEIGHT
                        );
                }


                // 월드 재생성
                document.querySelector(".mainBox").innerHTML = "";
                sendChat(true, "맵 불러오기 완료!", "System");
                confirm("로딩 성공! 시작버튼을 눌러주세요");
                console.log(loadedMapData);
//const bid2 = getBidByCoordinate(29, 1); 
////console.log(bid); // "55"
//alert(blockCodeInput2(bid2));
//console.log("mmmmmmmmmmmmmmmmmmmmmmmmm"+blockCodeInput2(bid2));
loadedGame=true;
                
            } catch (error) {
                console.error("Load Error:", error);
                sendChat(true, `불러오기 실패: ${error.message}`, "System");
                effectSound("stone");
            }
            document.body.removeChild(fileInput); // 최종 제거
        };

        // 4. 파일 읽기 실패 시
        reader.onerror = function() {
            sendChat(true, "파일 읽기 오류!", "System");
            effectSound("stone");
            document.body.removeChild(fileInput);
        };

        // 5. 실제 파일 읽기 실행
        reader.readAsText(file);
    });

    // 6. DOM 추가 및 클릭 이벤트 트리거
    document.body.appendChild(fileInput);
    fileInput.click();
}

function getBidByCoordinate(x, y) {
    // 1. 좌표 유효성 검사
    x = Number(x);
    y = Number(y);
    if(isNaN(x) || isNaN(y) || x < 0 || x >= 300 || y < 0 || y >= 200) {
        console.error("잘못된 좌표:", x, y);
        return "15";
    }

    // 2. 저장 데이터에서 블록 검색
    const block = loadedMapData.blocks.find(b => 
        Number(b.x) === x && 
        Number(b.y) === y
    );

    // 3. "undefined" 값 처리 추가 ▼▼▼
    const bid = block?.bid?.toString().toLowerCase();
    if(bid === "undefined" || bid === "null" || bid === "nan") {
        console.warn(`잘못된 bid 값 발견: ${x},${y} -> 기본값 적용`);
        return "15";
    }

    // 4. 결과 반환 (모든 경우 문자열 보장)
    return bid || "15";
}

function getSignInfo(x, y) {
    return loadedMapData.signs.find(s => 
        s.x === x && 
        s.y === y
    );
}
function getGameModeState() {
    return loadedMapData.gameMode?.[0]?.state;
}

function showCraftingTable(){
document.querySelector(".craftDisplay").style.display = "block";
}
function closeCraftingTable(){
    event.stopPropagation(); // 이벤트 버블링 방지
document.querySelector(".craftDisplay").style.display = "none";

}
function craftItem(input){
if(input=="선인장곡괭이"){

    if(document.getElementById("i391").innerText>=5&&document.getElementById("i03").innerText>=3){
        itemBagGet("109", -5);//선인장
        itemBagGet("4", -3);//나무
    sendChat(true, "제작 완료! 설치후 상호작용 해주세요", "선인장곡괭이");
    itemBagGet("115", 1);
    effectSound("get");
        //EquipmentState="선인장곡괭이";
    }else{
        sendChat(true, "재료가 부족합니다.", "선인장곡괭이");
    }

}else if(input=="철곡괭이"){
    
    if(document.getElementById("i07").innerText>=10&&document.getElementById("i03").innerText>=6){
        itemBagGet("11", -10);
        itemBagGet("4", -6);//나무
        sendChat(true, "제작 완료! 클릭후 터치해주세요", "철곡괭이");
    itemBagGet("116", 1);
    effectSound("get");
        //EquipmentState="철곡괭이";
    }else{
        sendChat(true, "재료가 부족합니다.", "철곡괭이");
    }
    
}
else if(input=="다이아곡괭이"){
    effectSound("get");
    if(document.getElementById("i11").innerText>=7&&document.getElementById("i03").innerText>=10){
    itemBagGet("14", -7);
    itemBagGet("4", -10);//나무
        sendChat(true, "제작 완료! 클릭후 터치해주세요", "다이아곡괭이");
    itemBagGet("117", 1);
    //EquipmentState="다이아곡괭이";
    effectSound("get");
    }else{
        sendChat(true, "재료가 부족합니다.", "다이아곡괭이");
    }


}

else if(input=="철검"){
    
    if(document.getElementById("i07").innerText>=5&&document.getElementById("i03").innerText>=2){
        itemBagGet("11", -5);   
        itemBagGet("4", -2);//나무
        sendChat(true, "제작 완료! 클릭후 터치해주세요 단축키 a (보스 소환중만 가능)", "철검");
        //WeaponState="철검";
    itemBagGet("118", 1);
    effectSound("get");
    }else{
        sendChat(true, "재료가 부족합니다. 단축키 a (보스 소환중만 가능) ", "철검");
    }
    
}


else if(input=="철활"){
    
    if((document.getElementById("i07").innerText>=2&&document.getElementById("i03").innerText>=5)&&document.getElementById("i191").innerText>=1){
        itemBagGet("11", -2);//철광석2
        itemBagGet("4", -5);//나무
        itemBagGet("100", -1);//거미줄1
      //WeaponState="철활";
        sendChat(true, "제작 완료! 클릭후 터치해주세요 사용법 : 빈화면 터치", "철활");
    itemBagGet("119", 1);
    effectSound("get");
    }else{
        sendChat(true, "재료가 부족합니다. 사용법 : 빈화면 터치 ", "철활");
    }
    
}

else if(input=="화살"){
    
    if(document.getElementById("i06").innerText>=1&&document.getElementById("i03").innerText>=1){
        itemBagGet("10", -1);   
        itemBagGet("4", -1);//나무
        sendChat(true, "5개 제작 완료! 클릭후 터치해주세요", "화살");
    itemBagGet("120", 5);
    effectSound("get");
    }else{
        sendChat(true, "재료가 부족합니다.", "화살");
    }
    
}


else if(input=="포션"){
    
    if(document.getElementById("i21").innerText>=1){
        itemBagGet("7", -1);
        sendChat(true, "2개 제작 완료! (사용 단축키 : 1 ) or 클릭후 터치해주세요", "포션");
    itemBagGet("121", 2);
    effectSound("get");
    }else{
        sendChat(true, "재료가 부족합니다. (사용 단축키 : 1 ) or 클릭후 터치해주세요 ", "포션");
    }
    
}

else if(input=="랜덤박스"){
    if(document.getElementById("i31").innerText>=1&&document.getElementById("i33").innerText>=1){
    itemBagGet("67", -1);//상자
    itemBagGet("69", -1);//황금상자
    sendChat(true,`${aboutChest(7,'x','y')}`,"랜덤 박스 오픈!");
    }else{
        sendChat(true, "재료가 부족합니다.", "랜덤박스");
    }


}



else if (input === "슬라임킹") {

   const allMusicTracks = [
  musicA, musicA2, musicB, musicB2, musicB3, musicB4, musicB5, musicB6, musicB7,
  musicDe_surface, musicDe_underground,
  musicJu_day, musicJu_night, musicJu_underground,
  musicOc_day, musicOc_night,
  musicIc_surface, musicIc_underground,
  musicSp_day,
  beforeBoss
]; 
  const itemCount = parseInt(document.getElementById("i34").innerText);
  
  if (itemCount >= 1) {
    // 아이템 차감
    itemBagGet("70", -1); // 스타트패키지
    itemBagGet("121", 3);

    // 시스템 메시지 출력
    sendChat(true, "공격은 충돌 혹은 a키를 사용하세요", "바닥에서 진동이 느껴진다....");

    // 음악 및 제작창 초기화
    allStopMusic();
    closeCraftingTable();
    beforeBoss.play();

    // 흔들림 시작
    void zoomRoot.offsetWidth;
    zoomRoot.classList.add("shake-active");

    const shakeInterval = setInterval(() => {
      const x = Math.random() * 15;
      const y = Math.random() * 15;
      zoomRoot.style.transform = `translate(${x}px, ${y}px)`;
    }, 100);

    // 밝기 감소 시작
    let brightness = 1.0;
    const brightnessInterval = setInterval(() => {
      brightness = Math.max(0.25, brightness - 0.045);

      [".mainBox", ".mainBox2", ".mainBox3", ".mainBox4"].forEach(selector => {
        const el = document.querySelector(selector);
        if (el) el.style.filter = `brightness(${brightness})`;
      });
    }, 100);

    // 10초 후 보스 등장
    setTimeout(() => {
      effectSound("explode");

      // 흔들림, 밝기 해제
      clearInterval(shakeInterval);
      clearInterval(brightnessInterval);
      zoomRoot.style.transform = "translate(0, 0)";
      zoomRoot.classList.remove("shake-active");

      [".mainBox", ".mainBox2", ".mainBox3", ".mainBox4"].forEach(selector => {
        const el = document.querySelector(selector);
        if (el) el.style.filter = "";
      });

      // 연출 및 보스 시작
      showFlashEffect();
      beforeBoss.pause();
      musicSlime_king.play();
      
      bossAliveGlobal = true;

      // 모든 음악 강제 정지 반복
      const musicStopInterval = setInterval(() => {
        if (!bossAliveGlobal) {
          clearInterval(musicStopInterval);
          return;
        }
        allMusicTracks.forEach(track => track.pause());
      }, 3000);

      BossSystem.init();
      bossStart = true;
      document.querySelector(".bossBar").style.display = "block";
    }, 10000);

  } else {
    sendChat(true, "재료가 부족합니다.", "???소환");
  }
}

else if(input=="나무갑옷"){
    if(document.getElementById("i31").innerText>=1&&document.getElementById("i33").innerText>=1){
  ArmorState="나무갑옷";
    itemBagGet("4", -15);//나무
playerArmor = 5;
    sendChat(true,`장착! 현재 방어력 : ${playerArmor}`,"나무갑옷");
document.querySelector(".armorBox").style.width = `${playerArmor*1.25}px`;

    }else{
        sendChat(true, "재료가 부족합니다.", "갑옷제작");
    }


}
else if(input=="선인장갑옷"){
    if(document.getElementById("i391").innerText>=10){
    itemBagGet("109", -10);//선인장
      ArmorState="선인장갑옷";
     playerArmor=8;
    sendChat(true,`장착! 현재 방어력 : ${playerArmor}`,"선인장갑옷");
    document.querySelector(".armorBox").style.width = `${playerArmor*1.4}px`;
    }else{
        sendChat(true, "재료가 부족합니다.", "갑옷제작");
    }


}
else if(input=="벌갑옷"){
    if(document.getElementById("i16").innerText5=1&&document.getElementById("i17").innerText>=5){
    itemBagGet("50", -5);//벌통`
    itemBagGet("51", -5);//꿀블럭
      ArmorState="벌갑옷";
     playerArmor=11;
    sendChat(true,`장착! 현재 방어력 : ${playerArmor}`,"벌갑옷");
    document.querySelector(".armorBox").style.width = `${playerArmor*1.55}px`;
    }else{
        sendChat(true, "재료가 부족합니다.", "갑옷제작");
    }


}
else if(input=="흑요석갑옷"){
    if(document.getElementById("i14").innerText>=7&&document.getElementById("i192").innerText>=7){
    itemBagGet("52", -7);//흑요석
    itemBagGet("53", -7);//화강암
      ArmorState="흑요석갑옷";
     playerArmor=14;
    sendChat(true,`장착! 현재 방어력 : ${playerArmor}`,"흑요석갑옷");
    document.querySelector(".armorBox").style.width = `${playerArmor*1.7}px`;
    }else{
        sendChat(true, "재료가 부족합니다.", "갑옷제작");
    }


}
else if(input=="네크로갑옷"){
    if(document.getElementById("i292").innerText>=1&&document.getElementById("i07").innerText>=15){
    itemBagGet("100", -10);//거미줄
    itemBagGet("11", -15);//철광석
      ArmorState="네크로갑옷";
     playerArmor=18;
    sendChat(true,`장착! 현재 방어력 : ${playerArmor}`,"네크로갑옷");
    document.querySelector(".armorBox").style.width = `${playerArmor*1.9}px`;
    }else{
        sendChat(true, "재료가 부족합니다.", "갑옷제작");
    }


}
}


// 번쩍임 효과 함수
function showFlashEffect() {
  const flash = document.getElementById("flashScreen");
  flash.style.display = "block";
  flash.className = "flash-effect";
  setTimeout(() => {
    flash.style.display = "none";
    flash.className = "";
  }, 500);
}
let isArrowActive = false;
const BOSS_HIT_RANGE = 1; // 보스 충돌 범위 (x±2, y±2)

function shootArrowToClick() {
    if(isArrowActive) return;
    isArrowActive = true;

    const playerBlock = getCurrentCenterBlock();
    const blockElem = document.getElementById(`xy${playerBlock.x},${playerBlock.y}`);
    if(!blockElem) { isArrowActive = false; return; }

    const rect = blockElem.getBoundingClientRect();
    const startX = rect.left + rect.width/2;
    const startY = rect.top + rect.height/2;

    function handleShoot(e) {
        document.removeEventListener('click', handleShoot);
        if(document.getElementById("i60").innerText <1) {
            sendChat(true, "화살이 부족합니다. 제작으로 만들 수 있습니다.", "System");
            isArrowActive = false;
            return;
        }
        itemBagGet("120", -1);
        effectSound("bow");
        const arrow = document.createElement('div');
        arrow.className = 'arrow';
        document.body.appendChild(arrow);
        arrow.style.left = startX + 'px';
        arrow.style.top = startY + 'px';

        let posX = startX, posY = startY;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const distance = Math.sqrt(dx*dx + dy*dy);
        const speed = 65;
        let vx = (dx / distance) * speed;
        let vy = (dy / distance) * speed - 2;
        const gravity = 4;

        function animate() {
            vy += gravity;
            posX += vx;
            posY += vy;

            arrow.style.left = posX + 'px';
            arrow.style.top = posY + 'px';

               // ▼▼▼ 추가: 180도 회전 코드 ▼▼▼
    const angle = Math.atan2(vy, vx) * 180 / Math.PI;
    arrow.style.transform = `rotate(${angle}deg)`;
    // ▲▲▲ 추가 끝 ▲▲▲

            // 화살 블럭 좌표 계산
            const scrollX = window.scrollX || window.pageXOffset;
            const scrollY = window.scrollY || window.pageYOffset;
            const blockX = Math.floor((posX + scrollX) / BLOCK_SIZE);
            const blockY = Math.floor((posY + scrollY) / BLOCK_SIZE);

            // 1. 블럭 충돌 체크
            const currentBlock = document.getElementById(`xy${blockX},${blockY}`);
            if(currentBlock) {
                const bid = currentBlock.dataset.bid;
                
                // 허용 아이템 체크
                if(!allowItems.includes(bid)) {
                    currentBlock.style.outline = '2px solid #f90';
                    setTimeout(() => currentBlock.style.outline = '', 200);
                    arrow.remove();
                    isArrowActive = false;

                    //effectSound("arrowHit");
                    
                    return;
                }
            }

            // 2. 보스 충돌 체크
            const bossPos = BossSystem.getPosition();
            if(bossPos && 



               Math.abs(blockX - bossPos.x) <= BOSS_HIT_RANGE && 
               Math.abs(blockY - bossPos.y) <= BOSS_HIT_RANGE) {
                BossSystem.takeDamage(attackDmg*1.8);
                arrow.remove();
                playRandomAttackSound();
                
                isArrowActive = false;
                return;
            }

            // 화면 밖 처리
            if(posY > window.innerHeight + 100 || posX < -100) {
                arrow.remove();
                isArrowActive = false;
            } else {
                requestAnimationFrame(animate);
            }
        }
        requestAnimationFrame(animate);
    }

    document.addEventListener('click', handleShoot);
    sendChat(true, "쏠 방향을 클릭하세요!", "활/화살");
}

//갑옷 ,무기 ,장비 상태를 위로 띄워줌
////////////////////////////

function showSpeechBubble(characterElement, message, duration = 5000) {
  // 기존 말풍선 제거
  const existingBubble = document.querySelector('.speech-bubble');
  if (existingBubble) {
    existingBubble.remove();
  }
  
  // 말풍선 요소 생성
  const bubble = document.createElement('div');
  bubble.className = 'speech-bubble';
  bubble.style.cssText = `
    top: ${getCurrentCenterBlockPlayer().y - 40}px; /* 캐릭터 머리 위 위치 */
    left: ${getCurrentCenterBlockPlayer().x}px;
    transform: translate(-50%, -100%); /* 중앙 정렬 */
  `;

  // 가시성 테스트를 위한 임시 스타일
  bubble.style.border = '2px solid red';
  bubble.style.background = 'rgba(255,255,255,0.95)';


  // 타이핑 효과를 위한 요소 생성
  const textElement = document.createElement('div');
  textElement.className = 'texty';
  bubble.appendChild(textElement);
  
  // 말풍선을 body에 추가
  document.body.appendChild(bubble);
  
  
    var textXY = getCurrentCenterBlockPlayer(); // {x: 33, y: 52} 등 반환


  bubble.style.left = `${textXY.x}px`;
  bubble.style.bottom = `${window.innerHeight - textXY.y + 10}px`;
  
  // 타이핑 효과 시작
  let i = 0;
  const typingInterval = setInterval(() => {
    if (i < message.length) {
      textElement.innerText += message.charAt(i);
      i++;
    } else {
      clearInterval(typingInterval);
    }
  }, 30);
  
  // 일정 시간 후 말풍선 제거
  setTimeout(() => {
    bubble.classList.add('fade-out');
    setTimeout(() => {
      if (bubble.parentElement) {
        bubble.remove();
      }
    }, 500);
  }, duration);
  
  return bubble;
}



// API 폼 열기
function apiForm() {
    effectSound("click");
    const formBox = document.querySelector(".apiFormBox");
    const wasVisible = formBox.style.display === "flex" || formBox.style.display === "block";

    // 상태 전환 및 UI 업데이트
    if (wasVisible) {
        formBox.style.display = "none";
        document.body.style.overflow = 'auto';
    } else {
        formBox.style.display = "flex";
        document.body.style.overflow = 'hidden';

        // 닫기 버튼 활성화
        const closeBtn = formBox.querySelector('.apiFormClose');
        if (closeBtn) {
            closeBtn.style.display = 'block'; // 버튼을 보이게 설정
        }

        // iframe 크기 조정
        const iframe = formBox.querySelector("iframe");
        if (iframe) {
            iframe.style.width = "100%";
            iframe.style.height = "100%";
            iframe.style.border = "none";
        }
    }

    // 배경 블러 효과 토글
    document.body.classList.toggle('form-open', !wasVisible);
}

// API 폼 닫기
function apiFormClose() {
    const formBox = document.querySelector(".apiFormBox");
    formBox.style.display = "none";

    // 닫기 버튼 숨기기
    const closeBtn = formBox.querySelector('.apiFormClose');
    if (closeBtn) {
        closeBtn.style.display = 'none'; // 버튼을 숨깁니다.
    }

    // 스크롤 복원
    document.body.classList.remove('form-open');
}

//모닥불
let isHealing = false;       // 중복 방지 플래그
let healingInterval = null;  // 전역 인터벌 ID 저장용

function campfire() {
    if (isHealing) return; // 이미 회복 중이면 중복 실행 막기

    effectSound("heal");
    isHealing = true;

    const healAmount = 2.5;
    const intervalTime = 1000;
    const duration = 10000;
    const maxHp = 100;

    healingInterval = setInterval(() => {
        if (playerHp < maxHp) {
            playerHp = Math.min(maxHp, playerHp + healAmount);
            updateHpDisplay();
        }
    }, intervalTime);

    setTimeout(() => {
        clearInterval(healingInterval);
        isHealing = false;
    }, duration);
}



// userAgent 정보 출력
//sendChat(true, "UserAgent 정보: " + userAgent, "System");

</script>

</html>
